(function($) { "use strict"; var bossInterval; var dpsInterval; var localSaveInterval; var cloudSaveInterval; var autoClickerDuration; var autoClickerInterval; var powerShotDuration; var specialForceDuration; var luckyCoinDuration; var grimReaperDuration; var grimReaperInterval; var skillCooldownInterval = []; var adventureTimerInterval = []; var currentEnemyHP = new Decimal(0); var lastDateTimeClick = Date.now(); var availableArtifact = []; var activeTutorNumber = 1; var notifCanPrestige = true; var maxHeroLevelBuy = 0; var maxWeaponLevelBuy = 0; var maxPartnerLevelBuy = []; var maxSkillLevelBuy = []; var initGame = function() { let backDateStatus = true; showGameVersion(); backDateStatus = loadGame(); if(!backDateStatus){ if(hero.userName != ""){ updateData(); insertDailyTask(); if(!hero.lastPrestigeShow){ let textOrbs = "Orb"; if(hero.lastPrestigeOrbs > 1) textOrbs = "Orbs"; componentAction ("prestige-text", "replaceText", numberFormat(hero.lastPrestigeOrbs)+" "+textOrbs); $("#modalPrestigeForm").modal('show'); hero.lastPrestigeShow = true; } initDisplay(); insertAvailableArtifact(); calculateAllArtifactDamage(); saveGame(); currentEnemyHP = initDungeon(); }else $("#user-name").focus(); }else $("#modalBackDateConfirm").modal('toggle'); }; var loadGame = function () { let backDateStatus = true; if(localStorage.getItem("hero")){ hero = JSON.parse(localStorage.getItem("hero")); backDateStatus = calcOfflineTime(); }else{ firstTimeVisit(); backDateStatus = false; } return backDateStatus; }; var saveGame = function () { if(hero.userID != "" && hero.userName != ""){ localSaveGame(); localSaveInterval = setInterval(function() { localSaveGame(); },setting.localSaveTimer*1000); } }; var localSaveGame = function () { let onlineDuration = 0; if(localStorage.getItem("hero"))localStorage.removeItem("hero"); if(!($("#modalOfflineForm").data('bs.modal') || {})._isShown && !($("#modalRewardAdventureConfirm").data('bs.modal') || {})._isShown && !($("#modalListRewardAdventureConfirm").data('bs.modal') || {})._isShown){ if(hero.gameVersion.localeCompare(setting.gameVersion) != 0){ $("#modalDevLog").modal("show"); componentAction("gameVersion", "replaceText", setting.gameVersion); hero.gameVersion = setting.gameVersion; } } if(hero.lastActiveDatetime > 0) onlineDuration = (Date.now() - hero.lastActiveDatetime) / 1000; updateDailyTask(11, onlineDuration); hero.totalOnlineDuration = new Decimal(hero.totalOnlineDuration).plus(onlineDuration); hero.lastActiveDatetime = Date.now(); localStorage.setItem("hero", JSON.stringify(hero)); }; var cloudSaveGame = function () { }; var resetGame = function (isPrestige=false){ hero.heroLevel = 1; hero.weaponLevel = 0; hero.dps = 0; hero.dpc = 1; hero.weaponDpc = 0; hero.floor = 1; hero.maxFloor = 1; hero.coin = 0; hero.countSkill = 0; hero.unlockSkill = []; hero.weaponAreaShow = 0; if(isPrestige){ let totalDps = 0; hero.countPartner = 0; hero.unlockPartner = []; for(let i=0;i<hero.unlockPet.length;i++){ let unlockPet = hero.unlockPet[i]; switch(unlockPet.id){ case 0: let heroDpc = calcNextHeroDpc(unlockPet.currBonus); hero.heroLevel = unlockPet.currBonus; hero.dpc = heroDpc; break; case 1: let weaponDpc = calcNextWeaponDpc(unlockPet.currBonus); hero.weaponLevel = unlockPet.currBonus; hero.weaponDpc = weaponDpc; break; case 2: hero.floor = unlockPet.currBonus + 1; hero.maxFloor = unlockPet.currBonus + 1; break; default: let partnerId = unlockPet.id - 3; let newObjPartner = { id: partnerId, level: 0, dps: 0 }; hero.unlockPartner.push(newObjPartner); let nextDps = new Decimal(calcNextPartnerDps(partnerId,unlockPet.currBonus)); let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); unlockPartner.dps = nextDps; totalDps += nextDps; hero.dps = totalDps; hero.countPartner++; break; } } } }; var updateData = function (){ if(hero.highestPartnerUnlock){ delete hero.highestPartnerUnlock; hero.highestUnlockPartner = []; } if(hero.highestPartnerLevel) delete hero.highestPartnerLevel; if(hero.highestPartnerLevel) delete hero.highestPartnerLevel; if(hero.totalPartnerLevel) delete hero.totalPartnerLevel; if(hero.highestUnlockPet) delete hero.highestUnlockPet; if(!hero.countZone) hero.countZone = 0; if(!hero.unlockZone) hero.unlockZone = []; if(!hero.dailyTask) hero.dailyTask = []; if(!hero.randomArtifactId) hero.randomArtifactId = [];if(!hero.highestUnlockPartner) hero.highestUnlockPartner = []; if(hero.totalArtifactUnlock == 0) hero.totalArtifactUnlock = hero.countArtifact; if(!hero.percentageBonusDpc) hero.percentageBonusDpc = 0; if(!hero.percentageBonusDps) hero.percentageBonusDps = 0; if(!hero.percentageBonusCoin) hero.percentageBonusCoin = 0; if(!hero.percentageBonusOrbs) hero.percentageBonusOrbs = 0; }; var firstTimeVisit = function () { let currentDatetime = new Date(); let date = currentDatetime.getDate(); let month = currentDatetime.getMonth() + 1; let year = currentDatetime.getFullYear().toString().substr(-2); let hour = currentDatetime.getHours(); let min = currentDatetime.getMinutes(); let sec = currentDatetime.getSeconds(); let firstID = parseInt(year,10).toString(36)+month.toString(36)+date.toString(36)+hour.toString(36)+min.toString(36)+sec.toString(36); let userID = firstID.toUpperCase()+randomString(10-firstID.length); componentAction("user-id", "inputText", userID); $("#modalLoginForm").modal('show'); }; var randomString = function (len) { let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let charactersLength = characters.length; let result = ""; for ( var i = 0; i < len; i++ ) { result += characters.charAt(Math.floor(Math.random() * charactersLength)); } return result; }; var initDungeon = function() { let enemyHP = initEnemy(); enemy.maxHp = enemyHP; componentAction ("current-enemy-hp,max-enemy-hp", "replaceText", numberFormat(enemyHP)); initDisplay(); return enemyHP; }; var initDisplay = function() { updateUpgradeLevelFeeHero(); updateUpgradeLevelFeeWeapon(); updateUpgradeLevelFeeAllPartner(); showBuyArea(); showBodyArea(); showWeaponArea(); showPartnerArea(); showSkillArea(); showAutoProgress(); showOrbsArea(); showFloorNumber(); showPrestigeArea(); updateUpgradeLevelFeeAllSkill(); updateUserName(); updateHeroDpc(); updateHeroCoin(); updateHeroDps(); updateWeaponDpc(); updateHeroLevel(); updatePartner(); updateSkill(); updateWeaponLevel(); checkCooldownAdventureTimer(); startDpsInterval(); saveGame(); }; var initEnemy = function(){ let baseEnemyHP = new Decimal(setting.enemyHPMultiplier).pow(hero.floor-1).mul(enemy.baseHp); let enemyHpPercentage = new Decimal(100).sub(hero.bonusEnemyHpPercentage).div(100); let enemyHP = baseEnemyHP.mul(enemyHpPercentage); if(bossInterval)bossInterval = clearInterval(bossInterval); if(hero.floor % enemy.bossFloor == 0){ let bossHpPercentage = new Decimal(100).sub(hero.bonusBossHpPercentage).div(100); componentAction ("current-enemy-name", "replaceText", enemy.listBoss[Math.floor(Math.random() * enemy.listBoss.length)]); $("#timer-bar").animate({width: "100%"},10); enemyHP = enemyHP.mul(2.5); enemyHP = enemyHP.mul(bossHpPercentage); componentAction ("timer-bar", "addClass", "timer-bar-bgcolor"); let maxBossTimer = new Decimal(setting.baseBossTimeLimit).plus(hero.bonusBossTimeLimit); let bossTimer = maxBossTimer; bossInterval = setInterval(function() { bossTimer = bossTimer.sub(1); let widthTimerBar = new Decimal(bossTimer).div(maxBossTimer).mul(100); $("#timer-bar").animate({width: (widthTimerBar)+"%"},10); if(bossTimer.equals(0)){ componentAction ("timer-bar", "removeClass", "timer-bar-bgcolor"); hero.floor--; enemyHP = initDungeon(); currentEnemyHP = enemyHP; componentAction ("progress-bar", "animate", 100); hero.autoProgressShow = 1; setting.autoProgress = false; showAutoProgress(); bossInterval = clearInterval(bossInterval); } },1000); }else{ componentAction ("current-enemy-name", "replaceText", enemy.listName[Math.floor(Math.random() * enemy.listName.length)]); componentAction ("timer-bar", "removeClass", "timer-bar-bgcolor"); } return (enemyHP.ceil()); }; var checkAction = function() { if(currentEnemyHP.lessThanOrEqualTo(0)){ componentAction ("progress-bar", "animate", 100); let rewardCoin = calcTotalRewardCoin(); let heroCoin = new Decimal(hero.coin); let totalGainCoin = new Decimal(hero.totalGainCoin); let bossCoinPercentage = new Decimal(hero.bonusBossCoinPercentage).plus(100).div(100); if(hero.floor % enemy.bossFloor == 0) rewardCoin = rewardCoin.mul(bossCoinPercentage).mul(2); hero.coin = heroCoin.plus(rewardCoin).ceil(); hero.totalGainCoin = new Decimal(hero.totalGainCoin).plus(rewardCoin).ceil(); if(setting.autoProgress){ if(hero.floor < setting.limitFloor){ hero.floor++; updateDailyTask(10); } if(hero.floor % enemy.bossFloor != 0){ updateDailyTask(5); hero.totalNormalEnemyKilled++; let randomSkipFloorChance = Math.random()*100; if(randomSkipFloorChance <= hero.bonusChanceSkipFloorPercentage && hero.floor < setting.limitFloor){ hero.floor++; updateDailyTask(10); } }else{ updateDailyTask(6); hero.totalBossEnemyKilled++; } if(hero.maxFloor < hero.floor) hero.maxFloor = hero.floor; if(!$("#skill-area-div").hasClass("d-none")){ showSkillArea(); } }else{ if(hero.floor % enemy.bossFloor == 0){ updateDailyTask(6); hero.totalBossEnemyKilled++; }else{ updateDailyTask(5); hero.totalNormalEnemyKilled++; } if(hero.maxFloor < (hero.floor + 1) && hero.floor < setting.limitFloor){ hero.maxFloor = hero.floor + 1; if(hero.floor % enemy.bossFloor == 0){ setting.autoProgress = true; showAutoProgress(); hero.floor++; updateDailyTask(10); } } } if(hero.highestFloor < hero.maxFloor) hero.highestFloor = hero.floor; currentEnemyHP = initDungeon(); unlockNewPet(); } if(hero.maxFloor == setting.unlockReqFloorPrestige && hero.totalGainOrbs == 0 && notifCanPrestige == true) { updateTab('hero'); $("#modalNotifPrestige").modal('show'); notifCanPrestige = false; } }; var updateDailyTask = function(dailyTaskId, addCount=1){ let unlockDailyTask = hero.dailyTask.task.find(item => item.id === dailyTaskId); let dailyTaskData = dailyTask.find(item => item.id === dailyTaskId); if(unlockDailyTask && unlockDailyTask.count < dailyTaskData.required){ switch(dailyTaskId){ case 11: unlockDailyTask.count = unlockDailyTask.count + (addCount/60); break; default: unlockDailyTask.count = unlockDailyTask.count + addCount; break; } if(unlockDailyTask.count >= dailyTaskData.required){ unlockDailyTask.count = dailyTaskData.required; unlockDailyTask.complete = true; updateDailyTask(0); if(!hero.token) hero.token = 0; hero.token += dailyTaskData.prize; } } }; var componentAction = function(componentId, action, actionValue){ let arrayComponentId = componentId.split(','); for(let i=0; i<arrayComponentId.length; i++){ switch (action) { case 'addClass': $("#"+arrayComponentId[i]).addClass(actionValue); break; case 'removeClass': $("#"+arrayComponentId[i]).removeClass(actionValue); break; case 'updateClass': let arrayActionValue = actionValue.split(','); $("#"+arrayComponentId[i]).removeClass(arrayActionValue[0]).addClass(arrayActionValue[1]); break; case 'replaceText': if(!isNaN(actionValue) && actionValue != '') actionValue = numberFormat(actionValue); $("#"+arrayComponentId[i]).text(actionValue); break; case 'inputText': if(!isNaN(actionValue)) actionValue = numberFormat(actionValue); $("#"+arrayComponentId[i]).val(actionValue); break; case 'clearText': $("#"+arrayComponentId[i]).empty(); break; case 'animate': let barPercentage = new Decimal(actionValue).toPrecision(5); $("#"+arrayComponentId[i]).animate({width: barPercentage+"%"},1); break; } } }; var calculateAllArtifactDamage = function(){ let artifactDamage = new Decimal(0); let artifactDpc = new Decimal(0); let artifactDps = new Decimal(0); let artifactCoin = new Decimal(0); let artifactBossCoin = new Decimal(0); let artifactOrbs = new Decimal(0); let artifactBossTimeLimit = new Decimal(0); let artifactOfflineTimeLimit = new Decimal(0); let artifactOfflineDps = new Decimal(0); let artifactOfflineCoin = new Decimal(0); let artifactIntervalDps = new Decimal(0); let artifactIntervalGrimReaper = new Decimal(0); let artifactEnemyHp = new Decimal(0); let artifactBossHp = new Decimal(0); let artifactHeroUpgradeFee = new Decimal(0); let artifactWeaponUpgradeFee = new Decimal(0); let artifactPartnerUpgradeFee = new Decimal(0); let artifactSkillUpgradeFee = new Decimal(0); let artifactChanceSkipFloor = new Decimal(0); for(let i=0; i<hero.countArtifact; i++){ let unlockArtifact = hero.unlockArtifact[i]; let artifactData = artifact.find(item => item.id === unlockArtifact.id); let totalDamage = new Decimal(unlockArtifact.level * artifactData.baseDamage); artifactDamage = artifactDamage.plus(artifactData.tier * unlockArtifact.level * 5); unlockArtifact.damage = totalDamage; switch (unlockArtifact.id){ case 0: artifactCoin = artifactCoin.plus(totalDamage); break; case 1: artifactBossCoin = artifactBossCoin.plus(totalDamage); break; case 2: case 3: artifactDpc = artifactDpc.plus(totalDamage); break; case 4: artifactDps = artifactDps.plus(totalDamage); break; case 5: artifactOfflineCoin = artifactOfflineCoin.plus(totalDamage); break; case 6: artifactOfflineDps = artifactOfflineDps.plus(totalDamage); break; case 7: artifactDamage = artifactDamage.plus(totalDamage); break; case 8: artifactOrbs = artifactOrbs.plus(totalDamage); break; case 9: artifactOfflineTimeLimit = artifactOfflineTimeLimit.plus(totalDamage); break; case 10: artifactIntervalDps = artifactIntervalDps.plus(totalDamage); break; case 11: artifactIntervalGrimReaper = artifactIntervalGrimReaper.plus(totalDamage); break; case 27: artifactBossTimeLimit = artifactBossTimeLimit.plus(totalDamage); break; case 28: artifactEnemyHp = artifactEnemyHp.plus(totalDamage); break; case 29: artifactBossHp = artifactBossHp.plus(totalDamage); break; case 30: artifactHeroUpgradeFee = artifactHeroUpgradeFee.plus(totalDamage); break; case 31: artifactWeaponUpgradeFee = artifactWeaponUpgradeFee.plus(totalDamage); break; case 32: artifactPartnerUpgradeFee = artifactPartnerUpgradeFee.plus(totalDamage); break; case 33: artifactSkillUpgradeFee = artifactSkillUpgradeFee.plus(totalDamage); break; case 34: artifactChanceSkipFloor = artifactChanceSkipFloor.plus(totalDamage); break;}} hero.artifactDamagePercentage = artifactDamage; hero.bonusDpcPercentage = artifactDpc; hero.bonusDpsPercentage = artifactDps; hero.bonusCoinPercentage = artifactCoin; hero.bonusBossCoinPercentage = artifactBossCoin; hero.bonusOrbsPercentage = artifactOrbs; hero.bonusBossTimeLimit = artifactBossTimeLimit; hero.bonusOfflineTimeLimit = artifactOfflineTimeLimit; hero.bonusOfflineDpsPercentage = artifactOfflineDps; hero.bonusOfflineCoinPercentage = artifactOfflineCoin; hero.bonusIntervalDps = artifactIntervalDps; hero.bonusIntervalGrimReaper = artifactIntervalGrimReaper; hero.bonusEnemyHpPercentage = artifactEnemyHp; hero.bonusBossHpPercentage = artifactBossHp; hero.bonusHeroUpgradeFeePercentage = artifactHeroUpgradeFee; hero.bonusWeaponUpgradeFeePercentage = artifactWeaponUpgradeFee; hero.bonusPartnerUpgradeFeePercentage = artifactPartnerUpgradeFee; hero.bonusSkillUpgradeFeePercentage = artifactSkillUpgradeFee; hero.bonusChanceSkipFloorPercentage = artifactChanceSkipFloor; }; var updateUserName = function () { if(hero.userName != "") componentAction ("view-username", "replaceText", hero.userName); }; var updateHeroCoin = function() { let heroCoin = new Decimal(hero.coin); componentAction ("hero-coin", "replaceText", heroCoin); }; var updateHeroDpc = function() { componentAction ("hero-dpc", "replaceText", calcTotalDpc()); componentAction ("current-hero-dpc", "replaceText", hero.dpc); componentAction ("next-hero-dpc", "replaceText", calcNextHeroDpc()); }; var updateHeroDps = function() { componentAction ("hero-dps", "replaceText", numberFormat(calcTotalDps())); }; var updateHeroOrbs = function() { componentAction ("hero-orbs", "replaceText", hero.orbs); }; var updateHeroLevel = function() { componentAction ("hero-level", "replaceText", hero.heroLevel); }; var updateWeaponLevel = function() { componentAction ("weapon-level", "replaceText", hero.weaponLevel); }; var updateWeaponDpc = function() { if(hero.weaponLevel > 0){ componentAction ("upgrade-weapon-text", "replaceText", "Level Up x"); if(setting.levelUpgradeMultiplier > 0) componentAction ("level-weapon-upgrade-multiplier", "replaceText", setting.levelUpgradeMultiplier); else if(setting.levelUpgradeMultiplier == 0) componentAction ("level-weapon-upgrade-multiplier", "replaceText", maxWeaponLevelBuy); } componentAction ("current-weapon-dpc", "replaceText", hero.weaponDpc); componentAction ("next-weapon-dpc", "replaceText", calcNextWeaponDpc()); }; var updatePartner = function() { for(let i=0; i<hero.countPartner; i++){ let unlockPartner = hero.unlockPartner.find(item => item.id === i); if(unlockPartner && unlockPartner.level > 0){ componentAction ("upgrade-partner-text-"+i, "replaceText", "Level Up x"); if(setting.levelUpgradeMultiplier > 0)componentAction ("level-partner-upgrade-multiplier-"+i, "replaceText", setting.levelUpgradeMultiplier); else if(setting.levelUpgradeMultiplier == 0){ let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === i); componentAction ("level-partner-upgrade-multiplier-"+i, "replaceText", localMaxPartnerLevelBuy.maxLevelBuy); } componentAction ("partner-level-"+i, "replaceText", unlockPartner.level); componentAction ("current-partner-dps-"+i, "replaceText", unlockPartner.dps); } componentAction ("next-partner-dps-"+i, "replaceText", calcNextPartnerDps(i)); } }; var updateSkill = function () { for(let i=0; i<hero.countSkill; i++){ let unlockSkill = hero.unlockSkill.find(item => item.id === i); if(unlockSkill && unlockSkill.level > 0){ if(unlockSkill.level > 0){ let totalDamage = new Decimal(unlockSkill.damage).plus(artifactSkillDamage(i)); componentAction ("upgrade-skill-text-"+i, "replaceText", "Level Up x"); let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === i); componentAction ("level-skill-upgrade-multiplier-"+i, "replaceText", localMaxSkillLevelBuy.maxLevelBuy); componentAction ("skill-level-"+i, "replaceText", unlockSkill.level); componentAction ("current-skill-damage-"+i, "replaceText", numberFormat(totalDamage)); } if(unlockSkill.level < 10) componentAction ("next-skill-damage-"+i, "replaceText", "(+"+(calcNextSkillDamage(i)-unlockSkill.damage)+")"); else componentAction ("next-skill-damage-"+i, "clearText", ""); } } }; var updateUpgradeLevelFeeHero = function() { let totalUpgradeFee = new Decimal(0); let heroCoin = new Decimal(hero.coin); let nextTotalUpgradeFee = new Decimal(0); maxHeroLevelBuy = 0; if(setting.levelUpgradeMultiplier > 0){ for(let a=0; a<setting.levelUpgradeMultiplier; a++){ let upgradeFee = new Decimal(setting.heroUpgradeCoinMultiplier).pow(hero.heroLevel + a - 1).mul(setting.baseHeroUpgradeCoin); let heroUpgradeFeePercentage = new Decimal(100).sub(hero.bonusHeroUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(heroUpgradeFeePercentage); totalUpgradeFee = totalUpgradeFee.plus(upgradeFee); } }else if(setting.levelUpgradeMultiplier == 0){ let a = 0; do{ let upgradeFee = new Decimal(setting.heroUpgradeCoinMultiplier).pow(hero.heroLevel + a - 1).mul(setting.baseHeroUpgradeCoin); let heroUpgradeFeePercentage = new Decimal(100).sub(hero.bonusHeroUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(heroUpgradeFeePercentage); nextTotalUpgradeFee = totalUpgradeFee.plus(upgradeFee); if(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)){ totalUpgradeFee = nextTotalUpgradeFee; a++; } }while(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)); maxHeroLevelBuy = a; } componentAction ("upgrade-level-fee", "replaceText", numberFormat(totalUpgradeFee.ceil())); return totalUpgradeFee.ceil(); }; var updateUpgradeLevelFeeWeapon = function() { let totalUpgradeFee = new Decimal(0); let loopNextLevel = 0; let nextTotalUpgradeFee = new Decimal(0); let heroCoin = new Decimal(hero.coin); if(hero.weaponLevel == 0) loopNextLevel = 1; else loopNextLevel = setting.levelUpgradeMultiplier; if(loopNextLevel > 0){ for(let a=0; a<loopNextLevel; a++){ let upgradeFee = new Decimal(setting.weaponUpgradeCoinMultiplier).pow(hero.weaponLevel + a).mul(setting.baseWeaponUpgradeCoin); let weaponUpgradeFeePercentage = new Decimal(100).sub(hero.bonusWeaponUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(weaponUpgradeFeePercentage); totalUpgradeFee = totalUpgradeFee.plus(upgradeFee); } }else if(setting.levelUpgradeMultiplier == 0){ let b = 0; do{ let upgradeFee = new Decimal(setting.weaponUpgradeCoinMultiplier).pow(hero.weaponLevel + b).mul(setting.baseWeaponUpgradeCoin); let weaponUpgradeFeePercentage = new Decimal(100).sub(hero.bonusWeaponUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(weaponUpgradeFeePercentage); nextTotalUpgradeFee = totalUpgradeFee.plus(upgradeFee); if(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)){ totalUpgradeFee = nextTotalUpgradeFee; b++; } }while(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)); maxWeaponLevelBuy = b; } componentAction ("upgrade-weapon-fee", "replaceText", numberFormat(totalUpgradeFee.ceil())); return totalUpgradeFee.ceil(); }; var updateUpgradeLevelFeeAllPartner = function() { for(let i=0; i<hero.countPartner; i++){ updateUpgradeLevelFeePartner(i); } }; var updateUpgradeLevelFeePartner = function(partnerId) { if(partnerId >= 0){ let totalUpgradeFee = new Decimal(0); let loopNextLevel = 0; let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); let partnerLevel = 0; let nextTotalUpgradeFee = new Decimal(0); let heroCoin = new Decimal(hero.coin); if (unlockPartner) { loopNextLevel = setting.levelUpgradeMultiplier; partnerLevel = unlockPartner.level }else{ loopNextLevel = 1; } if(loopNextLevel > 0){ for(let a=0; a<loopNextLevel; a++){ let upgradeFee = new Decimal(setting.partnerUpgradeCoinMultiplier).pow(partnerLevel + a).mul(partnerData.basePrice); let partnerUpgradeFeePercentage = new Decimal(100).sub(hero.bonusPartnerUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(partnerUpgradeFeePercentage); totalUpgradeFee = totalUpgradeFee.plus(upgradeFee); } }else if(setting.levelUpgradeMultiplier == 0){ let c=0; do{ let upgradeFee = new Decimal(setting.partnerUpgradeCoinMultiplier).pow(partnerLevel + c).mul(partnerData.basePrice); let partnerUpgradeFeePercentage = new Decimal(100).sub(hero.bonusPartnerUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(partnerUpgradeFeePercentage); nextTotalUpgradeFee = totalUpgradeFee.plus(upgradeFee); if(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)){ totalUpgradeFee = nextTotalUpgradeFee; c++; } }while(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)); let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === partnerId); localMaxPartnerLevelBuy.maxLevelBuy = c; } componentAction ("upgrade-partner-fee-"+partnerId, "replaceText", numberFormat(totalUpgradeFee.ceil())); return totalUpgradeFee.ceil(); } }; var updateUpgradeLevelFeeAllSkill = function() { for(let i=0; i<hero.countSkill; i++){ updateUpgradeLevelFeeSkill(i); } }; var updateUpgradeLevelFeeSkill = function(skillId){ if(skillId >= 0){ let totalUpgradeFee = new Decimal(0); let loopNextLevel = 0; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let skillData = skill.find(item => item.id === skillId); let skillLevel = 0; let nextTotalUpgradeFee = new Decimal(0); let heroCoin = new Decimal(hero.coin); if (unlockSkill) { loopNextLevel = setting.levelUpgradeMultiplier; skillLevel = unlockSkill.level; componentAction ("skill-use-div-"+skillId, "removeClass", "d-none"); if(!unlockSkill.isCooldown){ $("#use-skill-button-"+skillId).prop('disabled', false); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-disabled,skill-active"); } }else{ loopNextLevel = 1; } if(skillLevel==skillData.maxLevel){ $("#upgrade-skill-button-"+skillId).remove(); }else{ if(loopNextLevel > 0){ if((skillLevel+loopNextLevel) > skillData.maxLevel) loopNextLevel = skillData.maxLevel - skillLevel; for(let a=0; a<loopNextLevel; a++){ let upgradeFee = new Decimal(setting.skillUpgradeCoinMultiplier).pow(skillLevel + a).mul(skillData.basePrice); let skillUpgradeFeePercentage = new Decimal(100).sub(hero.bonusSkillUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(skillUpgradeFeePercentage); totalUpgradeFee = totalUpgradeFee.plus(upgradeFee); } }else if(loopNextLevel == 0){ let d=0; do{ let upgradeFee = new Decimal(setting.skillUpgradeCoinMultiplier).pow(skillLevel + d).mul(skillData.basePrice); let skillUpgradeFeePercentage = new Decimal(100).sub(hero.bonusSkillUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(skillUpgradeFeePercentage); nextTotalUpgradeFee = totalUpgradeFee.plus(upgradeFee); if(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin) && (skillLevel+d) < skillData.maxLevel){ totalUpgradeFee = nextTotalUpgradeFee; d++; } }while(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin) && (skillLevel+d) < skillData.maxLevel); loopNextLevel = d; } let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === skillId); localMaxSkillLevelBuy.maxLevelBuy = loopNextLevel; componentAction ("upgrade-skill-fee-"+skillId, "replaceText", numberFormat(totalUpgradeFee.ceil())); } return totalUpgradeFee.ceil(); } }; var clearBodyArea = function() { setting.heroAreaShow = 0; setting.partnerAreaShow = 0; setting.skillAreaShow = 0; setting.shopAreaShow = 0; }; var showGameVersion = function(){ componentAction ("version", "replaceText", "["+setting.gameVersion+"]"); }; var showAutoProgress = function(){ if(hero.autoProgressShow == 1) componentAction ("auto-progress-div", "removeClass", "d-none"); $("#auto-progress-switch").prop("checked", setting.autoProgress); }; var showFloorNumber = function() { switch (hero.floor){ case 1: componentAction ("floor-number-div-1", "removeClass", "tab-button-unactive"); componentAction ("floor-number-text-1", "clearText", ""); componentAction ("floor-number-div-2", "removeClass", "tab-button-unactive"); componentAction ("floor-number-text-2", "clearText", ""); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "replaceText", hero.floor+1); componentAction ("floor-number-text-5", "replaceText", hero.floor+2); break; case 2: componentAction ("floor-number-div-1", "removeClass", "tab-button-unactive"); componentAction ("floor-number-text-1", "clearText", ""); componentAction ("floor-number-div-2", "removeClass", "d-none"); componentAction ("floor-number-div-2", "addClass", "tab-button-unactive"); componentAction ("floor-number-text-2", "replaceText", (hero.floor-1)); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "replaceText", hero.floor+1); componentAction ("floor-number-text-5", "replaceText", hero.floor+2); break; case (setting.limitFloor-1): componentAction ("floor-number-div-4", "addClass", "tab-button-unactive"); componentAction ("floor-number-text-4", "replaceText", (hero.floor+1)); componentAction ("floor-number-div-5", "removeClass", "tab-button-unactive"); componentAction ("floor-number-text-5", "clearText", ""); componentAction ("floor-number-text-1", "replaceText", (hero.floor-2)); componentAction ("floor-number-text-2", "replaceText", (hero.floor-1)); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "replaceText", hero.floor+1); break; case setting.limitFloor: componentAction ("floor-number-div-4", "removeClass", "tab-button-unactive"); componentAction ("floor-number-text-4", "clearText", ""); componentAction ("floor-number-div-5", "removeClass", "tab-button-unactive"); componentAction ("floor-number-text-5", "clearText", ""); componentAction ("floor-number-text-1", "replaceText", (hero.floor-2)); componentAction ("floor-number-text-2", "replaceText", (hero.floor-1)); componentAction ("floor-number-text-3", "replaceText", hero.floor); break; default: componentAction ("floor-number-div-1", "removeClass", "d-none"); componentAction ("floor-number-div-2", "removeClass", "d-none"); componentAction ("floor-number-div-4", "removeClass", "d-none"); componentAction ("floor-number-div-5", "removeClass", "d-none"); componentAction ("floor-number-div-1", "addClass", "tab-button-unactive"); componentAction ("floor-number-div-2", "addClass", "tab-button-unactive"); componentAction ("floor-number-div-4", "addClass", "tab-button-unactive"); componentAction ("floor-number-div-5", "addClass", "tab-button-unactive"); componentAction ("floor-number-text-1", "replaceText", (hero.floor-2)); componentAction ("floor-number-text-2", "replaceText", (hero.floor-1)); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "replaceText", hero.floor+1); componentAction ("floor-number-text-5", "replaceText", hero.floor+2); break; } }; var showBuyArea = function(){ componentAction ("button-buy-multiplier-1", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("button-buy-multiplier-10", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("button-buy-multiplier-100", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("button-buy-multiplier-0", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("button-buy-multiplier-"+setting.levelUpgradeMultiplier, "updateClass", "tab-button-unactive,tab-button-active"); }; var showDungeonArea = function(){ hideAllContent(); initDisplay(); componentAction ("dungeon-div", "removeClass", "d-none"); componentAction ("dungeon", "updateClass", "cursor-button,active"); }; var showOrbsArea = function(){ let heroOrbs = new Decimal(hero.orbs); if(heroOrbs.greaterThan(0) || hero.unlockArtifact.length > 0){ componentAction ("hero-orbs-title", "replaceText", "Orbs : "); updateHeroOrbs(); } }; var showBodyArea = function(){ if(setting.heroAreaShow == 1 || hero.coin >= setting.unlockRequirementCoinForHero || hero.heroLevel > 1){ setting.heroAreaShow = 1; componentAction ("body-area-div", "removeClass", "d-none"); componentAction ("hero-user-name", "replaceText", hero.userName); updateHeroLevel(); if(setting.levelUpgradeMultiplier > 0) componentAction ("level-hero-upgrade-multiplier", "replaceText", setting.levelUpgradeMultiplier); else if(setting.levelUpgradeMultiplier == 0) componentAction ("level-hero-upgrade-multiplier", "replaceText", maxHeroLevelBuy); componentAction ("unlock-weapon-requirement", "replaceText", setting.unlockRequirementLevelForWeapon); } componentAction ("unlock-partner-requirement", "replaceText", partner[0].unlockReq); }; var showWeaponArea = function(){ if(hero.weaponAreaShow == 1 || hero.heroLevel >= setting.unlockRequirementLevelForWeapon){ componentAction ("weapon-unlock-div", "removeClass", "d-none"); componentAction ("weapon-area-div", "removeClass", "d-none"); componentAction ("weapon-unlock-div", "addClass", "d-none"); hero.weaponAreaShow = 1; } }; var showPartnerArea = function(){ let openNewPartner = 0; let countPartner = 0; let partnerData; let prevPartnerName = ''; if($("#partner-unlock-div").length) $("#partner-unlock-div").remove(); for(let i = 0; i<partner.length; i++){ let unlockReqLevel = 0; let partnerLevel = 0; let partnerDPS = 0; let nextPartnerDPS = 0; let upgradeFee = 0; let upgradeText = ''; let upgradeMultiplier = ''; if(i == 0){ unlockReqLevel = hero.heroLevel; prevPartnerName = 'Hero'; }else{ let prevPartnerId = i - 1; let unlockPartner = hero.unlockPartner.find(item => item.id === prevPartnerId); if(unlockPartner){ unlockReqLevel = unlockPartner.level; } prevPartnerName = partner[prevPartnerId].name; } if(unlockReqLevel >= partner[i].unlockReq){ countPartner++; let newObjMaxPartnerLevelBuy = { id: i, maxLevelBuy: 0 }; maxPartnerLevelBuy.push(newObjMaxPartnerLevelBuy); if( !$( "#partner-area-" + i ).length){ partnerData = partner.find(item => item.id === i); let unlockPartner = hero.unlockPartner.find(item => item.id === i); if(unlockPartner){ partnerDPS = unlockPartner.dps; partnerLevel = unlockPartner.level; nextPartnerDPS = calcNextPartnerDps(i); upgradeFee = updateUpgradeLevelFeePartner(i); upgradeText = 'Level Up x'; upgradeMultiplier = setting.levelUpgradeMultiplier; }else{ nextPartnerDPS = partnerData.baseDps; upgradeFee = partnerData.basePrice; upgradeText = 'Unlock'; } openNewPartner = 1; let appendPartnerDiv = '<div id="partner-area-' + i + '" class="row border-top rounded-card">'; appendPartnerDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-6 col-6">'; appendPartnerDiv += partnerData.name + ' Lv <span id="partner-level-' + i + '">' + partnerLevel + '</span>'; appendPartnerDiv += '</div>'; appendPartnerDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-6 col-6">'; appendPartnerDiv += 'DPS : <span id="current-partner-dps-' + i + '">' + partnerDPS + '</span> (+<span id="next-partner-dps-' + i + '">' + nextPartnerDPS + '</span>)'; appendPartnerDiv += '</div>'; appendPartnerDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendPartnerDiv += '<button id="upgrade-partner-button-' + i + '" class="upgrade-level-button" value="' + i + '"><span id="upgrade-partner-text-' + i + '">' + upgradeText + '</span><span id="level-partner-upgrade-multiplier-' + i + '">' + upgradeMultiplier + '</span> - <span id="upgrade-partner-fee-' + i + '">' + numberFormat(upgradeFee) + '</span> Coin</button>'; appendPartnerDiv += '</div>'; appendPartnerDiv += '</div>'; $("#partner-area-div").append(appendPartnerDiv).on('click','#upgrade-partner-button-'+i,function(){ upgradeLevelPartner(this); }); } }else{ let appendPartnerDiv = '<div id="partner-unlock-div" class="rounded-card middle-align unlock-info">Unlock Partner at ' + prevPartnerName + ' level ' + partner[i].unlockReq + '</div>'; $("#partner-area-div").append(appendPartnerDiv); i = partner.length; } } hero.countPartner = countPartner; if(openNewPartner == 1 && hero.totalGainOrbs == 0) updateTab("partner"); if(setting.partnerAreaShow == 1){ componentAction ("partner-area-div", "removeClass", "d-none"); setting.partnerAreaShow = 1; } }; var showSkillArea = function(){ let openNewSkill = 0; let countSkill = 0; let skillData; for(let i=0; i<skill.length; i++){ let skillLevel = 0; let skillDamage = 0; let nextSkillDamage = 0; let upgradeFee = 0; let upgradeText = ''; let upgradeMultiplier = ''; let styleDivBtnUseSkill = 'd-none'; let styleBtnUseSkill = 'skill-disabled'; let propBtnUseSkill = 'disabled'; let textBtnUseSkill = 'Use Skill - Ready To Use'; let unlockReqFloor = hero.maxFloor; if($("#skill-unlock-div").length) $("#skill-unlock-div").remove(); if(unlockReqFloor >= skill[i].unlockReqFloor){ countSkill++; let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === i); if(!localMaxSkillLevelBuy){ let newObjMaxSkillLevelBuy = { id: i, maxLevelBuy: 0 }; maxSkillLevelBuy.push(newObjMaxSkillLevelBuy); } if( !$( "#skill-area-" + i ).length){ skillData = skill.find(item => item.id === i); let unlockSkillData = hero.unlockSkill.find(item => item.id === i); if(unlockSkillData){ let damageSkill = new Decimal(unlockSkillData.damage).plus(artifactSkillDamage(i)); let durationSkill = new Decimal(unlockSkillData.duration).plus(artifactSkillDuration(i)); let cooldownSkill = new Decimal(unlockSkillData.cooldown).sub(artifactSkillCooldown(i)); propBtnUseSkill = ''; styleDivBtnUseSkill = ''; styleBtnUseSkill = 'skill-active'; if(unlockSkillData.isActive){ let pastDurationSkill = new Decimal(Math.floor((Date.now() - unlockSkillData.lastStartDatetime) / 1000)); let restDurationSkill = new Decimal(durationSkill).sub(pastDurationSkill); if(pastDurationSkill.lessThan(durationSkill)){ styleBtnUseSkill = 'skill-running'; propBtnUseSkill = ''; textBtnUseSkill = "Click to Stop - "+offlineTimeText(restDurationSkill); }else{ unlockSkillData.isCooldown = true; unlockSkillData.lastCooldownDatetime = new Decimal(1000).mul(durationSkill).plus(unlockSkillData.lastStartDatetime); unlockSkillData.isActive = false; unlockSkillData.lastStartDatetime = 0; } } if(unlockSkillData.isCooldown){ let pastCooldownSkill = new Decimal(Math.floor((Date.now() - unlockSkillData.lastCooldownDatetime) / 1000)); let restCooldownSkill = new Decimal(cooldownSkill).sub(pastCooldownSkill); if(pastCooldownSkill.lessThan(cooldownSkill)){ propBtnUseSkill = 'disabled'; styleBtnUseSkill = 'skill-disabled'; textBtnUseSkill = "Cooldown Timer - "+offlineTimeText(restCooldownSkill); startCooldownSkill(i); }else{ unlockSkillData.isCooldown = false; unlockSkillData.lastCooldownDatetime = 0; } } skillDamage = damageSkill; skillLevel = unlockSkillData.level; nextSkillDamage = calcNextSkillDamage(i)-unlockSkillData.damage; upgradeFee = updateUpgradeLevelFeeSkill(i); upgradeText = 'Level Up x'; upgradeMultiplier = setting.levelUpgradeMultiplier; }else{ nextSkillDamage = skillData.baseDamage; upgradeFee = skillData.basePrice; upgradeText = 'Unlock'; } openNewSkill = 1; let appendSkillDiv = '<div id="skill-area-' + i + '" class="row border-top rounded-card">'; appendSkillDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-6 col-6">'; appendSkillDiv += skillData.name + ' Lv <span id="skill-level-' + i + '">' + skillLevel + '</span>'; appendSkillDiv += '</div>'; appendSkillDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-6 col-6">'; appendSkillDiv += '<span id="current-skill-damage-' + i + '">' + numberFormat(skillDamage) + '</span> <span id="next-skill-damage-' + i + '">'; if(skillLevel < skillData.maxLevel) appendSkillDiv += '(+' + nextSkillDamage + ')'; appendSkillDiv += '</span> <span id ="skill-desc-' + i + '">' + skillData.description + '</span>'; appendSkillDiv += '</div>'; appendSkillDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; if(skillLevel < skillData.maxLevel)appendSkillDiv += '<button id="upgrade-skill-button-' + i + '" class="upgrade-level-button" value="' + i + '"><span id="upgrade-skill-text-' + i + '">' + upgradeText + '</span><span id="level-skill-upgrade-multiplier-' + i + '">' + upgradeMultiplier + '</span> - <span id="upgrade-skill-fee-' + i + '">' + numberFormat(upgradeFee) + '</span> Coin</button>'; appendSkillDiv += '</div>'; appendSkillDiv += '</div>'; $("#skill-area-div").append(appendSkillDiv).on('click','#upgrade-skill-button-'+i,function(){ upgradeLevelSkill(this); }); appendSkillDiv = '<div id="skill-use-div-' + i + '" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 mt-2 ' + styleDivBtnUseSkill + '">'; appendSkillDiv += '<button id="use-skill-button-' + i + '" class="use-skill-button ' + styleBtnUseSkill + '" value="' + i + '" ' + propBtnUseSkill + '><span id ="skill-timer-desc-' + i + '">' + textBtnUseSkill + '</span></button>'; appendSkillDiv += '</div>'; $("#skill-area-"+i).append(appendSkillDiv).on('click','#use-skill-button-'+i,function(){ useSkill(i); }); if(unlockSkillData && unlockSkillData.isActive)useSkill(i); } }else{ if(i+1 < skill.length){ let appendSkillDiv = '<div id="skill-unlock-div" class="rounded-card middle-align unlock-info">Unlock Next Skill at Floor ' + skill[i].unlockReqFloor + '</div>'; $("#skill-area-div").append(appendSkillDiv); i = skill.length; } } } hero.countSkill = countSkill; if(openNewSkill == 1 && hero.totalGainOrbs == 0) updateTab("skill"); if(setting.skillAreaShow == 1){ componentAction ("skill-area-div", "removeClass", "d-none"); setting.skillAreaShow = 1; } }; var showShopArea = function(){ if(setting.shopAreaShow == 1){ componentAction ("shop-area-div", "removeClass", "d-none"); setting.shopAreaShow = 1; } }; var showPrestigeArea = function(){ if(hero.maxFloor >= setting.unlockReqFloorPrestige){ if(!$("#prestige-area-div").length){ let appendPrestigeDiv = '<div id="prestige-area-div" class="row border-top rounded-card prestige-button text-center">'; appendPrestigeDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">Prestige</div>'; appendPrestigeDiv += '</div>'; $("#hero-area-div").append(appendPrestigeDiv).on('click','#prestige-area-div',function(){ startPrestige(); }); } } }; var showArtifactArea = function(){ checkDuplicateArtifact(); let totalGainOrbs = new Decimal(hero.totalGainOrbs); componentAction ("total-orbs", "replaceText", numberFormat(hero.orbs)); componentAction ("total-artifact-damage", "replaceText", numberFormat(hero.artifactDamagePercentage)); if(artifact.length > hero.countArtifact) componentAction ("unlock-artifact-fee", "replaceText", numberFormat(calcNextUnlockArtifactFee())+" Orbs"); else{ componentAction ("total-orbs-div", "removeClass", "pt-3"); componentAction ("unlock-artifact-text", "replaceText", "Maxed"); componentAction ("unlock-artifact-button", "addClass", "skill-disabled"); componentAction ("unlock-artifact-fee", "clearText", ""); $("#unlock-artifact-button").prop('disabled', true); } componentAction ("artifact-div", "removeClass", "d-none"); componentAction ("artifact", "updateClass", "cursor-button,active"); calcHeightScrollDiv("artifact"); for(let i=0; i<hero.countArtifact; i++){ let unlockArtifact = hero.unlockArtifact[i]; let unlockArtifactId = unlockArtifact.id; let artifactData = artifact.find(item => item.id === unlockArtifactId); if( !$( "#artifact-area-" + unlockArtifactId ).length){ let appendArtifactDiv = '<div id="artifact-area-' + unlockArtifactId + '" class="row border-top rounded-card">'; appendArtifactDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-8 col-8">'; appendArtifactDiv += '<span id="artifact-name-' + unlockArtifactId + '">' + artifactData.name + '</span> Lv <span id="artifact-level-' + unlockArtifactId + '">' + unlockArtifact.level + '</span>'; appendArtifactDiv += '</div>'; appendArtifactDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-4 col-4">'; appendArtifactDiv += '<span id="artifact-calc-damage-' + unlockArtifactId + '">' + artifactData.calcDamage + '</span> <span id="artifact-damage-' + unlockArtifactId + '">' + numberFormat(unlockArtifact.damage) + '</span> <span id="artifact-desc-damage-' + unlockArtifactId + '">' + artifactData.descDamage + '</span>'; appendArtifactDiv += '</div>'; appendArtifactDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendArtifactDiv += '<span id="artifact-desc-' + unlockArtifactId + '">' + artifactData.description + ' ' + artifactData.baseDamage + artifactData.descDamage + ' / level</span>'; appendArtifactDiv += '</div>'; appendArtifactDiv += '<div class="col-xl-10 col-lg-10 col-md-10 col-sm-10 col-10">'; if(unlockArtifact.level < artifactData.maxLevel || artifactData.maxLevel == 0) appendArtifactDiv += '<button id="upgrade-artifact-button-' + unlockArtifactId + '" class="upgrade-level-button" value="' + unlockArtifactId + '"><span id="upgrade-artifact-fee-' + unlockArtifactId + '">Upgrade - ' + numberFormat(calcNextUpgradeArtifactFee(unlockArtifactId)) + ' Orbs</span></button>'; else appendArtifactDiv += '<button id="upgrade-artifact-button-' + unlockArtifactId + '" class="upgrade-level-button" disabled><span id="upgrade-artifact-fee-' + unlockArtifactId + '">Maxed</span></button>'; appendArtifactDiv += '</div>'; appendArtifactDiv += '<div id="sell-artifact-div-' + unlockArtifactId + '" class="col-xl-2 col-lg-2 col-md-2 col-sm-2 col-2">'; appendArtifactDiv += '</div>'; appendArtifactDiv += '</div>'; $("#artifact-area-div").append(appendArtifactDiv).off('click','#upgrade-artifact-button-'+unlockArtifactId).on('click','#upgrade-artifact-button-'+unlockArtifactId,function(){ upgradeLevelArtifact(unlockArtifactId); }); let sellArtifactDiv = '<button id="sell-artifact-button-' + unlockArtifactId + '" class="upgrade-level-button btn-secondary" value="' + unlockArtifactId + '"><img src="assets/images/trade.svg" height="16px"></img></button>'; $("#sell-artifact-div-"+unlockArtifactId).append(sellArtifactDiv).on('click','#sell-artifact-button-'+unlockArtifactId,function(){ confirmSellArtifact(this); }); }else{ componentAction ("artifact-level-"+unlockArtifactId, "replaceText", unlockArtifact.level); componentAction ("artifact-damage-"+unlockArtifactId, "replaceText", unlockArtifact.damage); if(unlockArtifact.level < artifactData.maxLevel || artifactData.maxLevel == 0) componentAction ("upgrade-artifact-fee-"+unlockArtifactId, "replaceText", "Upgrade - "+numberFormat(calcNextUpgradeArtifactFee(unlockArtifactId))+" Orbs"); else{ componentAction ("upgrade-artifact-fee-"+unlockArtifactId, "replaceText", "Maxed"); $("#upgrade-artifact-button-"+unlockArtifactId).prop('disabled', true); } } } }; var checkDuplicateArtifact = function(){ let seen = new Set(); let cleanArtifact = hero.unlockArtifact.filter(el => { let duplicate = seen.has(el.id); seen.add(el.id); return !duplicate; }); if(hero.countArtifact != cleanArtifact.length){ hero.countArtifact = cleanArtifact.length; hero.unlockArtifact = []; hero.unlockArtifact = cleanArtifact; } }; var showStatisticArea = function(){ let highestPartnerLevelString = ''; componentAction ("statistic-div", "removeClass", "d-none"); componentAction ("statistic", "updateClass", "cursor-button,active"); calcHeightScrollDiv("statistic"); componentAction ("stat-first-datetime", "replaceText", dateFormat(hero.firstPlayDateTime)); componentAction ("stat-online-duration", "replaceText", offlineTimeText(hero.totalOnlineDuration)); componentAction ("stat-offline-duration", "replaceText", offlineTimeText(hero.totalOfflineDuration)); componentAction ("stat-percentage-bonus-coin", "replaceText", numberFormat(hero.percentageBonusCoin)); componentAction ("stat-online-gain-coin", "replaceText", numberFormat(hero.totalGainCoin)); componentAction ("stat-offline-gain-coin", "replaceText", numberFormat(hero.totalOfflineCoin)); componentAction ("stat-spent-coin", "replaceText", numberFormat(hero.totalSpentCoin)); componentAction ("stat-total-click", "replaceText", numberFormat(hero.totalClick)); componentAction ("stat-percentage-bonus-dpc", "replaceText", numberFormat(hero.percentageBonusDpc)); componentAction ("stat-highest-dpc", "replaceText", numberFormat(hero.highestDpc)); componentAction ("stat-percentage-bonus-dps", "replaceText", numberFormat(hero.percentageBonusDps)); componentAction ("stat-highest-dps", "replaceText", numberFormat(hero.highestDps)); componentAction ("stat-highest-floor", "replaceText", numberFormat(hero.highestFloor)); componentAction ("stat-total-prestige", "replaceText", numberFormat(hero.totalCountPrestige)); componentAction ("stat-percentage-bonus-orbs", "replaceText", numberFormat(hero.percentageBonusOrbs)); componentAction ("stat-total-gain-orbs", "replaceText", numberFormat(hero.totalGainOrbs)); componentAction ("stat-total-spent-orbs", "replaceText", numberFormat(hero.totalSpentOrbs)); componentAction ("stat-total-artifact-unlock", "replaceText", numberFormat(hero.totalArtifactUnlock)); componentAction ("stat-highest-hero-level", "replaceText", numberFormat(hero.highestHeroLevel)); componentAction ("stat-highest-weapon-level", "replaceText", numberFormat(hero.highestWeaponLevel)); for(let i=0;i<hero.highestUnlockPartner.length;i++){ let partnerId = hero.highestUnlockPartner[i].id; let partnerLevel = hero.highestUnlockPartner[i].level; let partnerData = partner.find(item => item.id === partnerId); highestPartnerLevelString += partnerData.name+" - Level "+partnerLevel+"\n"; } componentAction ("stat-highest-partner-level", "replaceText", highestPartnerLevelString); }; var showDailyTaskArea = function(){ componentAction ("daily-task-div", "removeClass", "d-none"); componentAction ("daily-task", "updateClass", "cursor-button,active"); calcHeightScrollDiv("daily-task"); for(let i=0; i<hero.dailyTask.task.length; i++){ let unlockDailyTask = hero.dailyTask.task[i]; let unlockDailyTaskId = unlockDailyTask.id; let dailyTaskData = dailyTask.find(item => item.id === unlockDailyTaskId); if( !$( "#daily-task-area-" + unlockDailyTaskId ).length){ let appendDailyTaskDiv = '<div id="daily-task-area-' + unlockDailyTaskId + '" class="row border-top rounded-card">'; appendDailyTaskDiv += '<div class="col-xl-3 col-lg-3 col-md-3 col-sm-10 col-10">'; appendDailyTaskDiv += '<span id="daily-task-name-' + unlockDailyTaskId + '" class="strong">' + dailyTaskData.name + '</span>'; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '<div class="col-xl-1 col-lg-1 col-md-1 col-sm-2 col-2 right-align">'; if(unlockDailyTask.complete) appendDailyTaskDiv += '<span id="daily-task-complete-' + unlockDailyTaskId + '"><img src="assets/images/complete.svg" height="20px"></img></span>'; else appendDailyTaskDiv += '<span id="daily-task-complete-' + unlockDailyTaskId + '" class="d-none"><img src="assets/images/complete.svg" height="20px"></img></span>'; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendDailyTaskDiv += '<span id="artifact-desc-' + unlockDailyTaskId + '">' + dailyTaskData.description + ' ' + dailyTaskData.required + ' ' + dailyTaskData.unit+'</span>'; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 daily-task no-padding">'; appendDailyTaskDiv += '<div class="daily-task-text">'; appendDailyTaskDiv += '<span id="current-count-' + unlockDailyTaskId + '">' + unlockDailyTask.count + '</span> / '+ dailyTaskData.required; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '<div id="daily-task-bar-' + unlockDailyTaskId + '" class="daily-task-bar">&nbsp;</div>'; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '</div>'; $("#daily-task-area-div").append(appendDailyTaskDiv); }else{ componentAction ("current-count-"+unlockDailyTaskId, "replaceText", unlockDailyTask.count); if(unlockDailyTask.complete) componentAction ("daily-task-complete-"+unlockDailyTaskId, "removeClass", "d-none"); } let newDailyTaskBar = unlockDailyTask.count / dailyTaskData.required * 100; componentAction ("daily-task-bar-"+unlockDailyTaskId, "animate", newDailyTaskBar); } if(!hero.token)hero.token = 0; componentAction ("hero-token", "replaceText", hero.token); }; var insertDailyTask = function(){ let isInsertNewDailyTask = false; let date = new Date(); let currentDailyTaskDate = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()); if(!hero.dailyTask || hero.dailyTask.length == 0) isInsertNewDailyTask = true; else{ if(hero.dailyTask.date > 0){ let msPerDay = 1000 * 60 * 60 * 24; let dateDiff = Math.floor((currentDailyTaskDate - hero.dailyTask.date) / msPerDay); if(dateDiff > 0)isInsertNewDailyTask = true; } } if(isInsertNewDailyTask){ let heroDailyTask = []; let availableDailyTask = []; for(let i=1;i<dailyTask.length;i++) availableDailyTask.push(dailyTask[i].id); for(let i=0;i<setting.dailyTaskCount;i++){ let unlockDailyTaskId = availableDailyTask[Math.floor(Math.random() * availableDailyTask.length)]; let unlockIndex = availableDailyTask.indexOf(unlockDailyTaskId); if (unlockIndex !== -1){ availableDailyTask.splice(unlockIndex, 1); let newObjectDailyTask = { id: unlockDailyTaskId, count: 0, complete : false, }; heroDailyTask.push(newObjectDailyTask); } } let newObjectDailyTask = { id: 0, count: 0, complete : false, }; heroDailyTask.push(newObjectDailyTask); hero.dailyTask = { date: currentDailyTaskDate, task: heroDailyTask, }; updateDailyTask(1); } }; var unlockNewPet = function(petId=-1){ if(petId == -1){ for(let i=0;i<pet.length;i++){ let unlockPet = hero.unlockPet.find(item => item.id === i); if(hero.highestFloor >= pet[i].unlockReqFloor && !unlockPet){ petId = i; i = pet.length; } } } if(petId >= 0){ let unlockPet = hero.unlockPet.find(item => item.id === petId); let petData = pet.find(item => item.id === petId); let canUnlockNewPet = false; switch(petId){ case 1: if(hero.highestWeaponLevel > 0 && hero.highestFloor >= petData.unlockReqFloor) canUnlockNewPet = true; break; case 2: if(hero.highestFloor >= petData.unlockReqFloor) canUnlockNewPet = true; break; default: if(petId >= 3){ let partnerId = petId - 3; let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); if(unlockPartner && hero.highestFloor >= petData.unlockReqFloor) canUnlockNewPet = true; }else canUnlockNewPet = true; break; } if(canUnlockNewPet && !unlockPet){ if(hero.countPet == 0) $("#modalNotifPet").modal('show'); hero.countPet++; let newObjPet = { id: petId, level: 1, currExp: 0, currBonus: petData.multiplierBonus, adventureZone: -1, adventureSlot: -1, statusAdventure: '', collectReward: '' }; hero.unlockPet.push(newObjPet); $("#pet-area-div").empty(); if(!$("#pet-div").hasClass("d-none"))showPetArea(); } if(hero.countPet == 1) unlockNewAdventureArea(); } }; var unlockNewAdventureArea = function(zoneId=-1){ if(zoneId == -1){ for(let i=hero.countZone;i<zone.length;i++){ let zoneData = zone.find(item => item.id === i); if(i == 0){ zoneId = i; }else{ let prevZoneId = i - 1; let prevZone = hero.unlockZone.find(item => item.id === prevZoneId); if(prevZone.level >= zoneData.unlockReqLevel) zoneId = i; } i = zone.length; } } if(zoneId >= 0){ let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let zoneData = zone.find(item => item.id === zoneId); if(!unlockZone) insertNewUnlockZone(zoneId,zoneData); } }; var showPetTab = function(tabName){ componentAction ("pet-div", "removeClass", "d-none"); componentAction ("pet", "updateClass", "cursor-button,active"); switch(tabName){ case 'pet': componentAction ("pet-tab-button", "updateClass", "tab-button-unactive,tab-button-active"); componentAction ("area-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("pet-area-div", "removeClass", "d-none"); componentAction ("adventure-area-div", "addClass", "d-none"); break; case 'area': componentAction ("pet-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("area-tab-button", "updateClass", "tab-button-unactive,tab-button-active"); componentAction ("pet-area-div", "addClass", "d-none"); componentAction ("adventure-area-div", "removeClass", "d-none"); break; } }; var showPetArea = function(selectedZoneId=-1,selectedSlotId=-1){ let unlockReqText = ''; let isReachReqFloor = true; let nextUnlockPet = 0; showPetTab('pet'); calcHeightScrollDiv("pet"); if( $( "#selected-area").length) $( "#selected-area").remove(); if(selectedZoneId >= 0 && selectedSlotId >= 0){ let zoneData = zone.find(item => item.id === selectedZoneId); let unlockZone = hero.unlockZone.find(item => item.id === selectedZoneId); let totalUpgradeReqCount = unlockZone.level * zoneData.baseUpgradeReq; if( $("#pet-area-div").length) $("#pet-area-div").empty(); let appendAdventureDiv = '<div id="selected-area" class="row border-top rounded-card tab-active">'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += zoneData.name + ' Lv ' + unlockZone.level +' (' + zoneData.adventureTime + ' Hour)'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">' + zoneData.description + '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 pet-exp no-padding">'; appendAdventureDiv += '<div class="pet-exp-text">'; appendAdventureDiv += 'Exp : ' + unlockZone.adventureCount + ' / '+ totalUpgradeReqCount+''; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div id="selected-adventure-exp-bar" class="pet-exp-bar">&nbsp;</div>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Adventure Slot : ' + setSequenceName(selectedSlotId) + ' Pet Slot'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Bonus Coin : ' + numberFormat(unlockZone.bonusCoin) + ' Coin'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Exp Gain : ' + numberFormat(unlockZone.bonusExp) + ' Exp'; appendAdventureDiv += '</div>'; $("#pet-area-div").append(appendAdventureDiv); let newAdventureExpBar = unlockZone.adventureCount / totalUpgradeReqCount * 100; componentAction ("selected-adventure-exp-bar", "animate", newAdventureExpBar); } for(let i = 0; i<pet.length; i++){ let petData = pet.find(item => item.id === i); let unlockPet = hero.unlockPet.find(item => item.id === i); let totalUpgradeReqExp = 0; let petDescription = ''; let newPetExpBar = 0; let classButtonAdventure = ''; let disableButtonAdventure = ''; let hyphenName = ''; let slotName = ''; let slotId = selectedSlotId; let zoneId = selectedZoneId; if(unlockPet){ totalUpgradeReqExp = unlockPet.level * petData.upgradeReqExp; petDescription = petData.description + ' ' + unlockPet.currBonus + ' ' + petData.unit; newPetExpBar = unlockPet.currExp / totalUpgradeReqExp * 100; } if($( "#pet-area-" + i ).length) nextUnlockPet++; if( !$( "#pet-area-" + i ).length){ if(unlockPet){ if($("#pet-unlock-div-"+i).length) $("#pet-unlock-div-"+i).remove(); let appendPetDiv = '<div id="pet-area-' + i + '" class="row border-top rounded-card">'; appendPetDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendPetDiv += petData.name + ' Lv <span id="pet-level-' + i + '">' + unlockPet.level + '</span>'; appendPetDiv += '</div>'; appendPetDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendPetDiv += '<span id="pet-desc-' + i + '">' + petDescription + ' </span> (+<span id="next-pet-damage-' + i + '">' + petData.multiplierBonus + '</span>)'; appendPetDiv += '</div>'; appendPetDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 pet-exp no-padding">'; appendPetDiv += '<div class="pet-exp-text">'; appendPetDiv += 'Exp : <span id="current-pet-exp-' + i + '">' + unlockPet.currExp + '</span> / <span id="max-pet-exp-' + i + '">'+ totalUpgradeReqExp+'</span>'; appendPetDiv += '</div>'; appendPetDiv += '<div id="pet-exp-bar-' + i + '" class="pet-exp-bar">&nbsp;</div>'; appendPetDiv += '</div>'; appendPetDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 no-padding mt-2">'; if(unlockPet.adventureSlot >= 0 && unlockPet.adventureZone >= 0){ if(unlockPet.statusAdventure == 'running' || (unlockPet.statusAdventure == 'complete' && unlockPet.collectReward == '')){ let cooldownTimer = calcCooldownAdventureTime(unlockPet.adventureZone, unlockPet.adventureSlot); disableButtonAdventure = 'disabled'; classButtonAdventure = 'skill-running'; hyphenName = '-'; slotName = offlineTimeText(cooldownTimer); }else{ zoneId = unlockPet.adventureZone; slotId = unlockPet.adventureSlot; classButtonAdventure = 'collect-reward'; hyphenName = '-'; slotName = 'Collect Reward'; } }else{ if(zoneId >= 0 && slotId >= 0){ classButtonAdventure = 'skill-active'; slotName = 'Slot '+(slotId+1); }else{ classButtonAdventure = ''; hyphenName = ''; slotName = ''; } } appendPetDiv += '<button id="button-pet-adventure-' + i +'" class="upgrade-level-button '+classButtonAdventure+'" value="' + zoneId + '='+ slotId + '=' + i +'" ' + disableButtonAdventure + '>Adventure <span id="pet-adventure-name-' + i +'">' + petData.name + '</span> <span id="hyphen-' + i +'">'+hyphenName+'</span> <span id="slot-adventure-name-' + i +'">'+slotName+'</span></button>'; appendPetDiv += '</div>'; appendPetDiv += '</div>'; $("#pet-area-div").append(appendPetDiv).off('click','#button-pet-adventure-'+i).on('click','#button-pet-adventure-'+i,function(){ chooseAdventureArea(this); }); }else{ unlockReqText = 'Unlock this pet at floor '+petData.unlockReqFloor; switch(i){ case 1: if(hero.highestFloor < petData.unlockReqFloor){ unlockReqText += ' and have unlock a weapon once'; nextUnlockPet++; }else{ unlockReqText = 'Unlock this pet if you have unlock a weapon once'; } break; default: if(i >= 3){ let partnerId = i - 3; let partnerData = partner.find(item => item.id === partnerId); if(hero.highestFloor < petData.unlockReqFloor){ unlockReqText += ' and you have unlock partner ' + partnerData.name + ' once'; nextUnlockPet++; }else{ unlockReqText = 'Unlock this pet if you have unlock partner ' + partnerData.name + ' once'; } }else{ if(hero.highestFloor < petData.unlockReqFloor)nextUnlockPet++; } break; } if(nextUnlockPet > 1)isReachReqFloor = false; if(isReachReqFloor){ if(nextUnlockPet <= 1){ if( !$( "#pet-unlock-div-" + i ).length){ let appendPetDiv = '<div id="pet-unlock-div-'+i+'" class="rounded-card unlock-info middle-align">' + unlockReqText + '</div>'; appendPetDiv += '<div id="pet-area-' + i + '" class="row border-top rounded-card d-none"></div>'; $("#pet-area-div").append(appendPetDiv); }else componentAction ("pet-unlock-div-"+i, "replaceText", unlockReqText); if(nextUnlockPet == 1)i = pet.length; } } } }else{ if(unlockPet){ componentAction ("pet-level-"+i, "replaceText", unlockPet.level); componentAction ("current-pet-exp-"+i, "replaceText", unlockPet.currExp); componentAction ("max-pet-exp-"+i, "replaceText", totalUpgradeReqExp); componentAction ("pet-desc-"+i, "replaceText", petDescription); componentAction ("pet-adventure-name-"+i, "replaceText", petData.name); if(unlockPet.adventureSlot >= 0 && unlockPet.adventureZone >= 0){ if(unlockPet.statusAdventure == 'running' || (unlockPet.statusAdventure == 'complete' && unlockPet.collectReward == '')){ let cooldownTimer = calcCooldownAdventureTime(unlockPet.adventureZone, unlockPet.adventureSlot); disableButtonAdventure = 'disabled'; componentAction ("button-pet-adventure-"+i, "updateClass", "skill-active,skill-running"); hyphenName = '-'; slotName = offlineTimeText(cooldownTimer); }else{ zoneId = unlockPet.adventureZone; slotId = unlockPet.adventureSlot; componentAction ("button-pet-adventure-"+i, "inputText", (zoneId + '='+ slotId + '=' + i)); componentAction ("button-pet-adventure-"+i, "updateClass", "skill-active,collect-reward"); componentAction ("button-pet-adventure-"+i, "updateClass", "skill-running,collect-reward"); hyphenName = '-'; slotName = 'Collect Reward'; } }else{ componentAction ("button-pet-adventure-"+i, "inputText", (zoneId + '='+ slotId + '=' + i)); if(zoneId >= 0 && slotId >= 0){ componentAction ("button-pet-adventure-"+i, "updateClass", "skill-running,skill-active"); slotName = 'Slot '+(slotId+1); }else{ componentAction ("button-pet-adventure-"+i, "updateClass", "skill-active,"); classButtonAdventure = ''; hyphenName = ''; slotName = ''; } } componentAction ("hyphen-"+i, "replaceText", hyphenName); componentAction ("slot-adventure-name-"+i, "replaceText", slotName); } } componentAction ("pet-exp-bar-"+i, "animate", newPetExpBar); } if(setting.petAreaShow == 1){ componentAction ("pet-area-div", "removeClass", "d-none"); setting.petAreaShow = 1; } }; var showAdventureArea = function(selectedPetId=-1){ let nextUnlockZone = 0; let selectedPetName = 'Pet'; let slotName = ''; let classButtonAdventure = ''; showPetTab('area'); calcHeightScrollDiv("pet"); if($("#zone-unlock-div").length) $("#zone-unlock-div").remove(); if( $( "#selected-pet").length) $( "#selected-pet").remove(); if(selectedPetId >= 0){ let petData = pet.find(item => item.id === selectedPetId); let unlockPet = hero.unlockPet.find(item => item.id === selectedPetId); if( $("#adventure-area-div").length) $("#adventure-area-div").empty(); let totalUpgradeReqExp = unlockPet.level * petData.upgradeReqExp; let appendSelectedPet = '<div id="selected-pet" class="row border-top rounded-card tab-active">'; appendSelectedPet += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendSelectedPet += petData.name + ' Lv ' + unlockPet.level; appendSelectedPet += '</div>'; appendSelectedPet += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendSelectedPet += petData.description + ' ' + unlockPet.currBonus + ' ' + petData.unit + ' (+' + petData.multiplierBonus + ')'; appendSelectedPet += '</div>'; appendSelectedPet += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 pet-exp no-padding">'; appendSelectedPet += '<div class="pet-exp-text">'; appendSelectedPet += 'Exp : ' + unlockPet.currExp + ' / '+ totalUpgradeReqExp; appendSelectedPet += '</div>'; appendSelectedPet += '<div id="selected-pet-exp-bar" class="pet-exp-bar">&nbsp;</div>'; appendSelectedPet += '</div>'; appendSelectedPet += '</div>'; $("#adventure-area-div").append(appendSelectedPet); let newPetExpBar = unlockPet.currExp / totalUpgradeReqExp * 100; componentAction ("selected-pet-exp-bar", "animate", newPetExpBar); } for(let i=0;i<hero.countZone;i++){ let zoneData = zone.find(item => item.id === i); let unlockZone = hero.unlockZone.find(item => item.id === i); let totalUpgradeReqCount = unlockZone.level * zoneData.baseUpgradeReq; let petId = selectedPetId; let petName = selectedPetName; if(petId >= 0){ let petData = pet.find(item => item.id === petId); selectedPetName = petData.name; classButtonAdventure = 'skill-active'; }else{ selectedPetName = 'Pet'; classButtonAdventure = ''; petId = -1; } if(!$("#adventure-area-"+i).length){ if(unlockZone){ if($("#zone-unlock-div-"+i).length) $("#zone-unlock-div-"+i).remove(); let appendAdventureDiv = '<div id="adventure-area-' + i + '" class="row border-top rounded-card">'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += zoneData.name + ' Lv <span id="adventure-level-' + i + '">' + unlockZone.level +'</span> (' + zoneData.adventureTime + ' Hour)'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += '<span id="adventure-desc-' + i + '">' + zoneData.description + ' </span>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 pet-exp no-padding">'; appendAdventureDiv += '<div class="pet-exp-text">'; appendAdventureDiv += 'Exp : <span id="current-adventure-count-' + i + '">' + unlockZone.adventureCount + '</span> / <span id="max-adventure-count-' + i + '">'+ totalUpgradeReqCount+'</span>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div id="adventure-exp-bar-' + i + '" class="pet-exp-bar">&nbsp;</div>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Adventure Slot : <span id="adventure-slot-' + i + '">' + unlockZone.currSlot + '</span> Pet Slot'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Bonus Coin : <span id="adventure-coin-' + i + '">' + numberFormat(unlockZone.bonusCoin) + '</span> Coin'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Exp Gain : <span id="adventure-exp-' + i + '">' + numberFormat(unlockZone.bonusExp) + '</span> Exp'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div id="adventure-slot-' + i + '" class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 no-padding mt-2">'; for(let a=0;a<unlockZone.currSlot;a++){ let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === a); petId = selectedPetId; petName = selectedPetName; slotName = "Slot "+(a+1); if(unlockZoneSlot){ if(unlockZoneSlot.statusAdventure == 'running') classButtonAdventure = 'skill-running'; else if(unlockZoneSlot.statusAdventure == 'complete'){ classButtonAdventure = 'collect-reward'; petName = 'Complete'; slotName = 'Collect Reward'; petId = unlockZoneSlot.petId; let petData = pet.find(item => item.id === petId); petName = petData.name; } }else{ if(petId >= 0) classButtonAdventure = 'skill-active'; else classButtonAdventure = ''; } appendAdventureDiv += '<button id="button-adventure-slot-' + i + '-'+ a +'" class="upgrade-level-button adventure-slot-class '+classButtonAdventure+'" value="' + i + '='+ a + '=' + petId +'">Adventure <span id="adventure-pet-name-' + i + '-'+ a +'">' + petName + '</span> - <span id="adventure-slot-name-' + i + '-'+ a +'">' + slotName + '</span></button>'; } appendAdventureDiv += '</div>'; appendAdventureDiv += '</div>'; $("#adventure-area-div").append(appendAdventureDiv).off('click','.adventure-slot-class').on('click','.adventure-slot-class',function(){ insertAdventurePet(this); }); for(let a=0;a<unlockZone.currSlot;a++){ let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === a); if(unlockZoneSlot){ let statusAdventure = unlockZoneSlot.statusAdventure; let collectReward = unlockZoneSlot.collectReward; if(statusAdventure == 'running' || (statusAdventure == 'complete' && collectReward == ''))startCooldownAdventureTimer(unlockZoneSlot.petId, i, a); } } } }else{ let totalUpgradeReqCount = unlockZone.level * zoneData.baseUpgradeReq; for(let a=0;a<unlockZone.currSlot;a++){ petId = selectedPetId; petName = selectedPetName; let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === a); if(!unlockZoneSlot){ if(petId >= 0)componentAction ("button-adventure-slot-"+i+"-"+a, "addClass", 'skill-active'); else componentAction ("button-adventure-slot-"+i+"-"+a, "removeClass", 'skill-active'); }else{ if(unlockZoneSlot.statusAdventure == 'running') componentAction ("button-adventure-slot-"+i+"-"+a, "updateClass", 'skill-active,skill-running'); else if(unlockZoneSlot.statusAdventure == 'complete'){ componentAction ("button-adventure-slot-"+i+"-"+a, "updateClass", 'skill-running,complete-reward'); petId = unlockZoneSlot.petId; let petData = pet.find(item => item.id === petId); petName = petData.name; } } componentAction ("adventure-pet-name-"+i+"-"+a, "replaceText", petName); componentAction ("button-adventure-slot-"+i+"-"+a, "inputText", (i+'='+a+'='+petId)); } componentAction ("current-adventure-count-"+i, "replaceText", unlockZone.adventureCount); componentAction ("max-adventure-count-"+i, "replaceText", totalUpgradeReqCount); componentAction ("adventure-coin-"+i, "replaceText", unlockZone.bonusCoin); componentAction ("adventure-exp-"+i, "replaceText", unlockZone.bonusExp); componentAction ("adventure-slot-"+i, "replaceText", unlockZone.currSlot); componentAction ("adventure-level-"+i, "replaceText", unlockZone.level); } let newAdventureExpBar = unlockZone.adventureCount / totalUpgradeReqCount * 100; componentAction ("adventure-exp-bar-"+i, "animate", newAdventureExpBar); } if(hero.countZone < zone.length){ let prevZone = zone[hero.countZone-1]; let nextZone = zone[hero.countZone]; let appendZoneDiv = '<div id="zone-unlock-div" class="rounded-card middle-align unlock-info">Unlock Area at ' + prevZone.name + ' level ' + nextZone.unlockReqLevel + '</div>'; $("#adventure-area-div").append(appendZoneDiv); } }; var showTutorialArea = function(){ hideAllContent(); componentAction ("tutorial-div", "removeClass", "d-none"); componentAction ("tutorial", "updateClass", "cursor-button,active"); calcHeightScrollDiv("tutorial"); switchTutorPage(1); }; var calcHeightScrollDiv = function(headerName){ let heightScreen = $(window).height(); let topBar = $("#sticky-topbar").height() + 10; let footBar = $("#sticky-footbar").height() + 30; let contentHeader = $("#"+headerName+"-header").height() + 16; if($("#"+headerName+"-header2").length) contentHeader += $("#"+headerName+"-header2").height() + 16; let scrollHeight = heightScreen - topBar - footBar - contentHeader - 15; $('.pre-scrollable').css({"max-height":scrollHeight}); }; var startDpsInterval = function(){ if(!dpsInterval){ if(hero.dps > 0){ let newDpsInterval = new Decimal(1000).sub(hero.bonusIntervalDps); dpsInterval = setInterval(function() { let totalDps = new Decimal(calcTotalDps()); let maxHpEnemy = new Decimal(enemy.maxHp); currentEnemyHP = currentEnemyHP.sub(totalDps); let newHPBarWidth = new Decimal(currentEnemyHP).div(maxHpEnemy).mul(100); componentAction ("current-enemy-hp", "replaceText", numberFormat(currentEnemyHP)); componentAction ("progress-bar", "animate", newHPBarWidth); checkAction(); },newDpsInterval); }else dpsInterval = clearInterval(dpsInterval); } }; var addCountSkillUsed = function(skillId){ let statisticSkill = hero.totalSkillUsed.find(item => item.id === skillId); if(statisticSkill) statisticSkill.count++; else{ let newObjSkillUsed = { id: skillId, count: 1 }; hero.totalSkillUsed.push(newObjSkillUsed); } }; var startAutoClickerInterval = function (skillId){ let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let totalSkillDamage = new Decimal(unlockSkill.damage).plus(artifactSkillDamage(skillId)); let intervalSkill = new Decimal(1000).div(totalSkillDamage).floor(); if(autoClickerInterval || autoClickerDuration){ autoClickerInterval = clearInterval(autoClickerInterval); autoClickerDuration = clearInterval(autoClickerDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ totalDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); hitDPC(); autoClickerDuration = setInterval (function (){ componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); if(totalDurationSkill.lessThan(0)){ autoClickerDuration = clearInterval(autoClickerDuration); autoClickerInterval = clearInterval(autoClickerInterval); startCooldownSkill(skillId); } },1000); autoClickerInterval = setInterval(function() { hitDPC(); },intervalSkill); } }; var startPowerShotInterval = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); if(powerShotDuration){ powerShotDuration = clearInterval(powerShotDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ totalDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); powerShotDuration = setInterval (function (){ componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); if(totalDurationSkill.lessThan(0)){ powerShotDuration = clearInterval(powerShotDuration); startCooldownSkill(skillId); initDisplay(); } },1000); initDisplay(); } }; var startSpecialForceInterval = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); if(specialForceDuration){ specialForceDuration = clearInterval(specialForceDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ totalDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); specialForceDuration = setInterval (function (){ componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); if(totalDurationSkill.lessThan(0)){ specialForceDuration = clearInterval(specialForceDuration); startCooldownSkill(skillId); initDisplay(); } },1000); initDisplay(); } }; var startLuckyCoinInterval = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let totalCooldownSkill = unlockSkill.cooldown; let skillTimer = 0; if(luckyCoinDuration){ luckyCoinDuration = clearInterval(luckyCoinDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ totalDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); luckyCoinDuration = setInterval (function (){ componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); if(totalDurationSkill.lessThan(0)){ luckyCoinDuration = clearInterval(luckyCoinDuration); startCooldownSkill(skillId); initDisplay(); } },1000); } }; var startGrimReaperInterval = function (skillId){ let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let totalCooldownSkill = unlockSkill.cooldown; let newGrimReaperInterval = new Decimal(2000).sub(hero.bonusIntervalGrimReaper); if(grimReaperInterval || grimReaperDuration){ grimReaperInterval = clearInterval(grimReaperInterval); grimReaperDuration = clearInterval(grimReaperDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ totalDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); runGrimReaper(skillId); grimReaperDuration = setInterval (function (){ componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(totalDurationSkill)); totalDurationSkill = totalDurationSkill.sub(1); if(totalDurationSkill.lessThan(0)){ grimReaperDuration = clearInterval(grimReaperDuration); grimReaperInterval = clearInterval(grimReaperInterval); startCooldownSkill(skillId); } },1000); grimReaperInterval = setInterval(function() { runGrimReaper(skillId); },newGrimReaperInterval); } }; var startCooldownSkill = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalCooldownSkill = new Decimal(unlockSkill.cooldown).sub(artifactSkillCooldown(skillId)); let cooldownTimer = 0; unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; if(unlockSkill.lastCooldownDatetime == 0){ unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; cooldownTimer = new Decimal(totalCooldownSkill); }else{ cooldownTimer = new Decimal(totalCooldownSkill).sub(Math.floor((Date.now()-unlockSkill.lastCooldownDatetime) / 1000)); } $("#use-skill-button-"+skillId).prop('disabled', true); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Cooldown Timer - "+offlineTimeText(cooldownTimer)); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-running,skill-disabled"); cooldownTimer = cooldownTimer.sub(1); let skillCooldown = setInterval(function() { componentAction ("skill-timer-desc-"+skillId, "replaceText", "Cooldown Timer - "+offlineTimeText(cooldownTimer)); cooldownTimer = cooldownTimer.sub(1); if(cooldownTimer.lessThan(0)){ let removeIndex = skillCooldownInterval.map(function(item) { return item.id; }).indexOf(skillId); skillCooldownInterval.splice(removeIndex, 1); skillCooldown = clearInterval(skillCooldown); unlockSkill.lastCooldownDatetime = 0; unlockSkill.isCooldown = false; $("#use-skill-button-"+skillId).prop('disabled', false); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-disabled,skill-active"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Use Skill - Ready To Use"); } },1000); let newObjInterval = { id: skillId, lastUse: Date.now(), cooldown: unlockSkill.cooldown, interval: skillCooldown }; skillCooldownInterval.push(newObjInterval); }; var artifactSkillDamage = function(skillId){ let bonusArtifactSkillDamage; switch(skillId){ case 0: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 12); break; case 1: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 15); break; case 2: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 18); break; case 3: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 21); break; case 4: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 24); break; } if(bonusArtifactSkillDamage) return new Decimal(bonusArtifactSkillDamage.damage); else return new Decimal(0); }; var artifactSkillDuration = function(skillId){ let bonusArtifactSkillDuration; switch(skillId){ case 0: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 13); break; case 1: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 16); break; case 2: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 19); break; case 3: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 22); break; case 4: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 25); break; } if(bonusArtifactSkillDuration) return new Decimal(bonusArtifactSkillDuration.damage); else return new Decimal(0); }; var artifactSkillCooldown = function(skillId){ let bonusArtifactSkillCooldown; switch(skillId){ case 0: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 14); break; case 1: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 17); break; case 2: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 20); break; case 3: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 23); break; case 4: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 26); break; } if(bonusArtifactSkillCooldown) return new Decimal(bonusArtifactSkillCooldown.damage); else return new Decimal(0); }; var startPrestige = function(){ if(hero.maxFloor >= setting.unlockReqFloorPrestige){ let totalOrbs = new Decimal(calcTotalOrbs()); let textOrbs = "Orb"; if(totalOrbs > 1) textOrbs = "Orbs"; componentAction ("prestige-text-confirm", "replaceText", numberFormat(totalOrbs)+" "+textOrbs); $("#modalPrestigeConfirm").modal('show'); } }; var runPrestige = function(){ if(hero.maxFloor >= setting.unlockReqFloorPrestige){ let totalOrbs = new Decimal(calcTotalOrbs()); let textOrbs = "Orb"; let totalGainOrbs = new Decimal(hero.totalGainOrbs); hero.orbs = new Decimal(hero.orbs).plus(totalOrbs); hero.lastPrestigeDatetime = Date.now(); hero.lastPrestigeOrbs = totalOrbs; hero.lastPrestigeShow = false; totalGainOrbs = totalGainOrbs.plus(totalOrbs); hero.totalGainOrbs = totalGainOrbs; updateDailyTask(2); hero.totalCountPrestige++; resetGame(true); saveGame(); location.reload(); } }; var upgradeLevelHero = function (){ maxHeroLevelBuy = 0; let upgradeFee = updateUpgradeLevelFeeHero(); let heroCoin = new Decimal(hero.coin); if(heroCoin.greaterThanOrEqualTo(upgradeFee) && upgradeFee.greaterThan(0)){ let heroDPC = new Decimal(hero.dpc); let totalSpentCoin = new Decimal(hero.totalSpentCoin); heroCoin = heroCoin.sub(upgradeFee); hero.coin = heroCoin; totalSpentCoin = totalSpentCoin.plus(upgradeFee); hero.totalSpentCoin = totalSpentCoin; heroDPC = heroDPC.plus(calcNextHeroDpc()); hero.dpc = heroDPC; if(setting.levelUpgradeMultiplier > 0){ hero.heroLevel += setting.levelUpgradeMultiplier; updateDailyTask(7,setting.levelUpgradeMultiplier); }else if(setting.levelUpgradeMultiplier == 0){ hero.heroLevel += maxHeroLevelBuy; updateDailyTask(7,maxHeroLevelBuy); } if(hero.highestHeroLevel < hero.heroLevel) hero.highestHeroLevel = hero.heroLevel; initDisplay(); } }; var upgradeLevelWeapon = function (){ maxWeaponLevelBuy = 0; let upgradeFee = updateUpgradeLevelFeeWeapon(); let heroCoin = new Decimal(hero.coin); let unlockPet = hero.unlockPet.find(item => item.id === 1); if(heroCoin.greaterThanOrEqualTo(upgradeFee)){ let weaponDpc = new Decimal(hero.weaponDpc); let totalSpentCoin = new Decimal(hero.totalSpentCoin); heroCoin = heroCoin.sub(upgradeFee); hero.coin = heroCoin; totalSpentCoin = totalSpentCoin.plus(upgradeFee); hero.totalSpentCoin = totalSpentCoin; weaponDpc = weaponDpc.plus(calcNextWeaponDpc()); hero.weaponDpc = weaponDpc; if(hero.weaponLevel == 0){ hero.weaponLevel += 1; updateDailyTask(8); }else{ if(setting.levelUpgradeMultiplier > 0){ hero.weaponLevel += setting.levelUpgradeMultiplier; updateDailyTask(8, setting.levelUpgradeMultiplier); }else if(setting.levelUpgradeMultiplier == 0){ hero.weaponLevel += maxWeaponLevelBuy; updateDailyTask(8, maxWeaponLevelBuy); } } if(hero.highestWeaponLevel < hero.weaponLevel) hero.highestWeaponLevel = hero.weaponLevel; if(!unlockPet) unlockNewPet(1); initDisplay(); } }; var upgradeLevelPartner = function(e){ if(e){ let partnerId = parseInt(e.value,10); let petId = partnerId + 3; let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === partnerId); let unlockPet = hero.unlockPet.find(item => item.id === petId); if(localMaxPartnerLevelBuy) localMaxPartnerLevelBuy.maxLevelBuy = 0; let upgradeFee = updateUpgradeLevelFeePartner(partnerId); let heroCoin = new Decimal(hero.coin); if(heroCoin.greaterThanOrEqualTo(upgradeFee)){ let partnerDps = new Decimal(hero.dps); let nextDps = new Decimal(calcNextPartnerDps(partnerId)); let totalSpentCoin = new Decimal(hero.totalSpentCoin); heroCoin = heroCoin.sub(upgradeFee); hero.coin = heroCoin; totalSpentCoin = totalSpentCoin.plus(upgradeFee); hero.totalSpentCoin = totalSpentCoin; partnerDps = partnerDps.plus(nextDps); hero.dps = partnerDps; let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); if(unlockPartner){ let unlockPartnerDps = new Decimal(unlockPartner.dps); if(setting.levelUpgradeMultiplier > 0){ unlockPartner.level += setting.levelUpgradeMultiplier; updateDailyTask(9, setting.levelUpgradeMultiplier); }else if(setting.levelUpgradeMultiplier == 0){ let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === partnerId); unlockPartner.level += localMaxPartnerLevelBuy.maxLevelBuy; updateDailyTask(9, localMaxPartnerLevelBuy.maxLevelBuy); } let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); if(highestUnlockPartner){ if(highestUnlockPartner.level < unlockPartner.level) highestUnlockPartner.level = unlockPartner.level; }else{ let newObjHighestPartner = { id: partnerId, level: unlockPartner.level }; hero.highestUnlockPartner.push(newObjHighestPartner); } unlockPartnerDps = unlockPartnerDps.plus(nextDps); unlockPartner.dps = unlockPartnerDps; }else{ let newObjPartner = { id: partnerId, level: 1, dps: nextDps }; hero.unlockPartner.push(newObjPartner); updateDailyTask(9); } if(!unlockPet) unlockNewPet(petId); initDisplay(); } } }; var upgradeLevelSkill = function (e) { if(e){ let skillId = parseInt(e.value,10); let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === skillId); if(localMaxSkillLevelBuy) localMaxSkillLevelBuy.maxLevelBuy = 0; let currentSkillLevel = 0; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); if(unlockSkill)currentSkillLevel = unlockSkill.level; if(currentSkillLevel < 10){ let upgradeFee = updateUpgradeLevelFeeSkill(skillId); let heroCoin = new Decimal(hero.coin); let skillDamage = 0; if(heroCoin.greaterThanOrEqualTo(upgradeFee)){ let nextDamage = calcNextSkillDamage(skillId); let skillData = skill.find(item => item.id === skillId); let totalSpentCoin = new Decimal(hero.totalSpentCoin); heroCoin = heroCoin.sub(upgradeFee); hero.coin = heroCoin; totalSpentCoin = totalSpentCoin.plus(upgradeFee); hero.totalSpentCoin = totalSpentCoin; if(unlockSkill){ if(setting.levelUpgradeMultiplier == 1) unlockSkill.level += setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier >= 0){ let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === skillId); unlockSkill.level += localMaxSkillLevelBuy.maxLevelBuy; } let unlockSkillDamage = new Decimal(unlockSkill.damage); unlockSkill.damage = nextDamage; }else{ let newObjSkill = { id: skillId, level: 1, damage: nextDamage, duration: skillData.baseDuration, cooldown: skillData.baseCooldown, isActive: false, lastStartDatetime: 0, isCooldown: false, lastCooldownDatetime: 0 }; hero.unlockSkill.push(newObjSkill); } initDisplay(); } } } }; var upgradeLevelArtifact = function(e){ let artifactId = parseInt(e,10); if(artifactId >= 0){ let upgradeFee = new Decimal(calcNextUpgradeArtifactFee(artifactId)); let heroOrbs = new Decimal(hero.orbs); let weaponDpc = new Decimal(hero.weaponDpc); if(heroOrbs.greaterThanOrEqualTo(upgradeFee)){ let unlockArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); let artifactDamage = new Decimal(hero.artifactDamagePercentage); if(unlockArtifact){ if(unlockArtifact.level < artifactData.maxLevel || artifactData.maxLevel == 0){ let totalSpentOrbs = new Decimal(hero.totalSpentOrbs); heroOrbs = heroOrbs.sub(upgradeFee); hero.orbs = heroOrbs; totalSpentOrbs = totalSpentOrbs.plus(upgradeFee); hero.totalSpentOrbs = totalSpentOrbs; updateDailyTask(4); unlockArtifact.level++; unlockArtifact.damage = new Decimal(unlockArtifact.level).mul(artifactData.baseDamage); hero.artifactDamagePercentage = artifactDamage.plus(artifactData.tier*5); calculateAllArtifactDamage(); saveGame(); initDisplay(); showArtifactArea(); } } } } }; var confirmSellArtifact = function(e){ if(e){ let artifactId = parseInt(e.value,10); let unlockArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); let totalOrbsGain = new Decimal(calcSellArtifact(artifactId)); let notifText = "lv "+unlockArtifact.level+" "+artifactData.name+" for "+totalOrbsGain; if(totalOrbsGain > 1) notifText += " Orbs"; else notifText += " Orb"; componentAction ("sell-artifact-notification", "replaceText", notifText); $('#sell-artifact-ok-button').val(artifactId); $("#modalSellArtifactConfirm").modal('show'); } }; var calcSellArtifact = function(artifactId){ let unlockFee = calcCurrentUnlockArtifactFee(artifactId); let upgradeFee = calcCurrentUpgradeArtifactFee(artifactId); let totalFee = new Decimal(unlockFee).plus(upgradeFee); totalFee = totalFee.div(2).floor(); return totalFee; }; var sellArtifact = function(artifactId){ let totalFee = new Decimal(calcSellArtifact(artifactId)); var index = hero.unlockArtifact.findIndex(function(e){ return e.id === artifactId; }); if (index !== -1){ hero.unlockArtifact.splice(index, 1); $("#artifact-area-div").off('click','#upgrade-artifact-button-'+artifactId); $("#artifact-area-"+artifactId).remove(); hero.countArtifact--; hero.orbs = new Decimal(hero.orbs).plus(totalFee); calculateAllArtifactDamage(); insertSellArtifact(artifactId); } showArtifactArea(); saveGame(); }; var chooseAdventureArea = function(e){ let arrayString = e.value.split("="); let zoneId = parseInt(arrayString[0],10); let zoneSlot = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); if(zoneId >= 0 && zoneSlot >= 0){ let unlockPet = hero.unlockPet.find(item => item.id === petId); if(unlockPet.statusAdventure == '' && unlockPet.collectReward == '') insertAdventurePet(e); else confirmCollectReward(e.value); }else showAdventureArea(petId); }; var insertAdventurePet = function(e){ let arrayString = e.value.split("="); let zoneId = parseInt(arrayString[0],10); let zoneSlot = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); if(petId >= 0){ if(zoneId >= 0 && zoneSlot >= 0){ let zoneData = zone.find(item => item.id === zoneId); let petData = pet.find(item => item.id === petId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === zoneSlot); if(!unlockZoneSlot){ $("#modalStartAdventureConfirm").modal('show'); componentAction ("confirm-adventure-ok-button", "inputText", e.value); componentAction ("selected-pet-name", "replaceText", petData.name); componentAction ("selected-adventure-area", "replaceText", zoneData.name); }else{ if(unlockZoneSlot.statusAdventure == 'complete' && unlockZoneSlot.collectReward == 'later') confirmCollectReward(e.value); } } }else{ showPetArea(zoneId,zoneSlot); } }; var startAdventurePet = function(arrayString){ arrayString = arrayString.split("="); let zoneId = parseInt(arrayString[0],10); let slotId = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); let petData = pet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); let unlockPet = hero.unlockPet.find(item => item.id === petId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slot === slotId); if(!unlockZoneSlot){ let startAdventureTime = Date.now(); let endAdventureTime = startAdventureTime + (zoneData.adventureTime * 3600 * 1000); let newObjAdventureSlot = { slotId: slotId, petId: petId, startAdventure: startAdventureTime, endAdventure: endAdventureTime, statusAdventure: 'running', collectReward: 'no' }; unlockZone.adventureSlot.push(newObjAdventureSlot); if(unlockPet){ unlockPet.adventureZone = zoneId; unlockPet.adventureSlot = slotId; if(!unlockPet.statusAdventure) unlockPet.statusAdventure = 'running'; if(!unlockPet.collectReward) unlockPet.collectReward = ''; } } if(!($("#pet-div").hasClass("d-none"))){ if(!$("#pet-area-div").hasClass("d-none")) showPetArea(); if(!$("#adventure-area-div").hasClass("d-none")) showAdventureArea(); } startCooldownAdventureTimer(petId, zoneId, slotId); }; var calcCooldownAdventureTime = function(zoneId, slotId){ let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === slotId); let currentTime = Date.now(); let cooldownTimer = Math.ceil((unlockZoneSlot.endAdventure - currentTime) / 1000); return cooldownTimer; }; var checkCooldownAdventureTimer = function(afterOffline=false){ if(!($("#modalOfflineForm").data('bs.modal') || {})._isShown ){ if(hero.countZone > 0 && hero.countPet > 0){ for(let i=0;i<hero.unlockPet.length;i++){ let statusAdventure = hero.unlockPet[i].statusAdventure; let collectReward = hero.unlockPet[i].collectReward; if(statusAdventure == 'running' || (statusAdventure == 'complete' && collectReward == '')){ let petId = hero.unlockPet[i].id; let zoneId = hero.unlockPet[i].adventureZone; let slotId = hero.unlockPet[i].adventureSlot; if(i == (hero.unlockPet.length - 1)) afterOffline = false; startCooldownAdventureTimer(petId, zoneId, slotId, afterOffline); } } } } }; var startCooldownAdventureTimer = function(petId, zoneId, slotId, afterOffline=false){ let petData = pet.find(item => item.id === petId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let cooldownTimer = calcCooldownAdventureTime(zoneId, slotId); if(cooldownTimer >= 0){ $("#button-pet-adventure-"+petId).prop('disabled', true); componentAction ("button-pet-adventure-"+petId, "updateClass", "skill-active,skill-running"); componentAction ("pet-adventure-name-"+petId, "replaceText", petData.name); componentAction ("hyphen-"+petId, "replaceText", "-"); componentAction ("slot-adventure-name-"+petId, "replaceText", offlineTimeText(cooldownTimer)); $("#button-adventure-slot-"+zoneId+"-"+slotId).prop('disabled', true); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "skill-active,skill-running"); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", petData.name); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", offlineTimeText(cooldownTimer)); cooldownTimer--; let adventureInterval = setInterval(function() { componentAction ("button-pet-adventure-"+petId, "updateClass", "skill-active,skill-running"); componentAction ("pet-adventure-name-"+petId, "replaceText", petData.name); componentAction ("hyphen-"+petId, "replaceText", "-"); componentAction ("slot-adventure-name-"+petId, "replaceText", offlineTimeText(cooldownTimer)); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "skill-active,skill-running"); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", petData.name); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", offlineTimeText(cooldownTimer)); cooldownTimer--; if(cooldownTimer<0)stopCooldownAdventureTimer(petId, zoneId, slotId, afterOffline); },1000); let newObjInterval = { id: zoneId+'='+slotId+'='+petId, interval: adventureInterval }; adventureTimerInterval.push(newObjInterval); }else stopCooldownAdventureTimer(petId, zoneId, slotId, afterOffline); saveGame(); }; var stopCooldownAdventureTimer = function(petId, zoneId, slotId, afterOffline=false){ let petData = pet.find(item => item.id === petId); let unlockPet = hero.unlockPet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === slotId); let removeIndex = -1; if(unlockZoneSlot)unlockZoneSlot.statusAdventure = 'complete'; if(unlockPet)unlockPet.statusAdventure = 'complete'; let searchId = zoneId+'='+slotId+'='+petId; let searchAdventureInterval = adventureTimerInterval.find(item => item.id === searchId); if(searchAdventureInterval) searchAdventureInterval.interval = clearInterval(searchAdventureInterval.interval); removeIndex = adventureTimerInterval.map(function(item) { return item.id; }).indexOf(searchId); adventureTimerInterval.splice(removeIndex, 1); $("#button-pet-adventure-"+petId).prop('disabled', false); componentAction ("button-pet-adventure-"+petId, "updateClass", "skill-running,skill-active"); componentAction ("pet-adventure-name-"+petId, "replaceText", petData.name); componentAction ("hyphen-"+petId, "clearText", ""); componentAction ("slot-adventure-name-"+petId, "clearText", ""); $("#button-adventure-slot-"+zoneId+"-"+slotId).prop('disabled', false); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "skill-running,skill-active"); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", "Pet"); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", "Slot "+(slotId+1)); checkAdventureStatus(afterOffline); saveGame(); }; var checkAdventureStatus = function(afterOffline=false){ let countCompleteAdventure = 0; let arrayAdventureValue = []; for(let i=0;i<hero.unlockPet.length;i++){ let statusAdventure = hero.unlockPet[i].statusAdventure; let collectReward = hero.unlockPet[i].collectReward; if (statusAdventure == 'complete' && collectReward == ''){ let petId = hero.unlockPet[i].id; let zoneId = hero.unlockPet[i].adventureZone; let slotId = hero.unlockPet[i].adventureSlot; arrayAdventureValue.push(zoneId+"="+slotId+"="+petId); countCompleteAdventure++; } } if(countCompleteAdventure > 0 && !afterOffline){ if(countCompleteAdventure == 1){ let adventureValue = arrayAdventureValue[0]; let arrayString = adventureValue.split("="); let zoneId = parseInt(arrayString[0],10); let slotId = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); let zoneData = zone.find(item => item.id === zoneId); let petData = pet.find(item => item.id === petId); if(!($("#modalListRewardAdventureConfirm").data('bs.modal') || {})._isShown ) $("#modalRewardAdventureConfirm").modal("show"); componentAction ("confirm-reward-adventure-ok-button", "inputText", adventureValue); componentAction ("stop-adventure-pet-name", "replaceText", petData.name); componentAction ("stop-adventure-area-name", "replaceText", zoneData.name); }else{ let adventureString = ""; for(let i=0;i<countCompleteAdventure;i++){ let adventureValue = arrayAdventureValue[i]; let arrayString = adventureValue.split("="); let zoneId = parseInt(arrayString[0],10); let petId = parseInt(arrayString[2],10); let zoneData = zone.find(item => item.id === zoneId); let petData = pet.find(item => item.id === petId); adventureString += (i+1)+". Pet "+petData.name+" at "+zoneData.name+"\n"; } if(($("#modalRewardAdventureConfirm").data('bs.modal') || {})._isShown ) $("#modalRewardAdventureConfirm").modal("toggle"); $("#modalListRewardAdventureConfirm").modal("show"); componentAction ("listAdventureName", "replaceText", adventureString); } } }; var confirmCollectReward = function(e){ let arrayString = e.split("="); let zoneId = parseInt(arrayString[0],10); let zoneSlot = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); let petData = pet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); $("#modalCollectRewardAdventureConfirm").modal("show"); componentAction ("collect-reward-pet-name", "replaceText", petData.name); componentAction ("collect-reward-area-name", "replaceText", zoneData.name); componentAction ("collect-reward-adventure-ok-button", "inputText", e); }; var confirmCollectRewardAdventurePet = function(arrayString,isCollectLater=false){ if(arrayString == 'complete'){ let petId = -1; let zoneId = -1; let slotId = -1; for(let i=0;i<hero.unlockPet.length;i++){ petId = -1; zoneId = -1; slotId = -1; let statusAdventure = hero.unlockPet[i].statusAdventure; let collectReward = hero.unlockPet[i].collectReward; if (statusAdventure == 'complete' && collectReward == ''){ petId = hero.unlockPet[i].id; zoneId = hero.unlockPet[i].adventureZone; slotId = hero.unlockPet[i].adventureSlot; } if(zoneId >= 0 && slotId >= 0 && petId >= 0) collectRewardAdventurePet(zoneId,slotId,petId,isCollectLater); } }else{ arrayString = arrayString.split("="); let zoneId = parseInt(arrayString[0],10); let slotId = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); collectRewardAdventurePet(zoneId,slotId,petId,isCollectLater); } initDisplay(); }; var collectRewardAdventurePet = function(zoneId,slotId,petId,isCollectLater=false){ let addSlotStatus = false; let petData = pet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === slotId); let unlockPet = hero.unlockPet.find(item => item.id === petId); if(isCollectLater){ if(unlockPet) unlockPet.collectReward = 'later'; if(unlockZoneSlot) unlockZoneSlot.collectReward = 'later'; componentAction ("button-pet-adventure-"+petId, "updateClass", "skill-active,collect-reward"); componentAction ("pet-adventure-name-"+petId, "replaceText", "Complete"); componentAction ("hyphen-"+petId, "replaceText", "-"); componentAction ("slot-adventure-name-"+petId, "replaceText", "Collect Reward"); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "skill-active,collect-reward"); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", "Complete"); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", "Collect Reward"); }else{ componentAction ("button-pet-adventure-"+petId, "updateClass", "skill-running,skill-active"); componentAction ("button-pet-adventure-"+petId, "updateClass", "collect-reward,skill-active"); componentAction ("pet-adventure-name-"+petId, "replaceText", petData.name); componentAction ("hyphen-"+petId, "clearText", ""); componentAction ("slot-adventure-name-"+petId, "clearText", ""); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "skill-running,skill-active"); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "collect-reward,skill-active"); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", "Pet"); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", "Slot "+(slotId+1)); if(unlockPet){ unlockPet.adventureZone = -1; unlockPet.adventureSlot = -1; unlockPet.statusAdventure = ''; unlockPet.collectReward = ''; } let removeIndex = unlockZone.adventureSlot.map(function(item) { return item.slotId; }).indexOf(slotId); if (removeIndex !== -1)unlockZone.adventureSlot.splice(removeIndex, 1); unlockZone.adventureCount++; hero.coin = new Decimal(hero.coin).plus(unlockZone.bonusCoin); unlockPet.currExp = new Decimal(unlockPet.currExp).plus(unlockZone.bonusExp); let adventureReqLevelUp = unlockZone.level * zoneData.baseUpgradeReq; let petReqLevelUp = unlockPet.level * petData.upgradeReqExp; if(unlockZone.adventureCount >= adventureReqLevelUp){ unlockZone.level++; if(unlockZone.level % setting.bonusZoneSlot == 0 || unlockZone.level / 5 == 1){ unlockZone.currSlot += 1; addSlotStatus = true; } unlockZone.adventureCount -= adventureReqLevelUp; unlockZone.bonusCoin = new Decimal(unlockZone.level - 1).mul(zoneData.baseCoin / 2).plus(zoneData.baseCoin).floor(); unlockZone.bonusExp = new Decimal(unlockZone.level - 1).mul(zoneData.baseExp / 2).plus(zoneData.baseExp).floor(); let nextZoneId = zoneId+1; let nextZoneData = zone.find(item => item.id === nextZoneId); if(unlockZone.level == nextZoneData.unlockReqLevel){ let nextUnlockZone = hero.unlockZone.find(item => item.id === nextZoneId); if(!nextUnlockZone) insertNewUnlockZone(nextZoneId,nextZoneData); } } if(unlockPet.currExp >= petReqLevelUp){ unlockPet.level++; unlockPet.currExp -= petReqLevelUp; unlockPet.currBonus += petData.multiplierBonus; } if(!($("#pet-div").hasClass("d-none"))){ if(addSlotStatus) $("#adventure-area-div").empty(); } } if(!($("#pet-div").hasClass("d-none"))){ if(!$("#pet-area-div").hasClass("d-none")) showPetArea(); if(!$("#adventure-area-div").hasClass("d-none")) showAdventureArea(); } saveGame(); }; var insertNewUnlockZone = function(zoneId,zoneData){ hero.countZone++; let newObjZone = { id: zoneId, level: 1, bonusExp: zoneData.baseExp, bonusCoin: zoneData.baseCoin, currSlot: zoneData.baseSlot, adventureCount: 0, adventureSlot: [] }; hero.unlockZone.push(newObjZone); }; var calcTotalDpc = function () { let unlockSkill = hero.unlockSkill.find(item => item.id === 1); let baseDpc = new Decimal(hero.dpc).plus(hero.weaponDpc); let subTotalPercentage = new Decimal(100).plus(hero.bonusDpcPercentage).plus(hero.artifactDamagePercentage); let totalPercentage = new Decimal(100).plus(hero.bonusShopDpcPercentage).mul(subTotalPercentage).div(10000); let totalDpc = new Decimal(baseDpc).mul(totalPercentage); let percentageBonusDpc = new Decimal(hero.percentageBonusDpc); if(percentageBonusDpc.lessThan(totalPercentage)) hero.percentageBonusDpc = totalPercentage*100; if(unlockSkill){ if(unlockSkill.isActive){ let totalDurationSkill = Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000); if(totalDurationSkill < unlockSkill.duration){ totalDpc = totalDpc.mul(100+unlockSkill.damage).div(100).round(); }else{ unlockSkill.isCooldown = true; unlockSkill.lastCooldownDatetime = unlockSkill.lastStartDatetime + (unlockSkill.duration * 1000); unlockSkill.isActive = false; unlockSkill.lastStartDatetime = 0; } } } if(totalDpc.round() > hero.highestDpc) hero.highestDpc = totalDpc.round(); return totalDpc.round(); }; var calcTotalDps = function () { let skillId = 2; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let baseDps = new Decimal(hero.dps); let subTotalPercentage = new Decimal(100).plus(hero.bonusDpsPercentage).plus(hero.artifactDamagePercentage); let totalPercentage = new Decimal(100).plus(hero.bonusShopDpsPercentage).mul(subTotalPercentage).div(10000); let totalDps = new Decimal(baseDps).mul(totalPercentage); let percentageBonusDps = new Decimal(hero.percentageBonusDps); if(percentageBonusDps.lessThan(totalPercentage)) hero.percentageBonusDps = totalPercentage*100; if(unlockSkill){ if(unlockSkill.isActive){ let totalDurationSkill = new Decimal(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); let totalDuration = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); if(totalDurationSkill.lessThan(totalDuration)){ let totalDamagePercentage = new Decimal(100).plus(unlockSkill.damage).plus(artifactSkillDamage(skillId)).div(100); totalDps = totalDps.mul(totalDamagePercentage).round(); }else{ unlockSkill.isCooldown = true; unlockSkill.lastCooldownDatetime = unlockSkill.lastStartDatetime + (totalDuration * 1000); unlockSkill.isActive = false; unlockSkill.lastStartDatetime = 0; } } } if(totalDps.round() > hero.highestDps) hero.highestDps = totalDps.round(); return totalDps.round(); }; var calcTotalRewardCoin = function (isOnline=true) { let subTotalPercentage; let rewardCoin = new Decimal(hero.floor).div(1.2).mul(enemy.baseCoin); let unlockSkill = hero.unlockSkill.find(item => item.id === 3); if(isOnline) subTotalPercentage = new Decimal(100).plus(hero.bonusCoinPercentage).plus(hero.artifactDamagePercentage); else subTotalPercentage = new Decimal(100).plus(hero.bonusOfflineCoinPercentage).plus(hero.artifactDamagePercentage); let totalPercentage = new Decimal(100).plus(hero.bonusShopCoinPercentage).mul(subTotalPercentage).div(10000); let totalRewardCoin = new Decimal(rewardCoin).mul(totalPercentage); let percentageBonusCoin = new Decimal(hero.percentageBonusCoin); if(percentageBonusCoin.lessThan(totalPercentage)) hero.percentageBonusCoin = totalPercentage*100; if(unlockSkill){ if(unlockSkill.isActive){ let totalDurationSkill = Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000); if(totalDurationSkill < unlockSkill.duration){ totalRewardCoin = totalRewardCoin.mul(100+unlockSkill.damage).div(100).round(); }else{ unlockSkill.isCooldown = true; unlockSkill.lastCooldownDatetime = unlockSkill.lastStartDatetime + (unlockSkill.duration * 1000); unlockSkill.isActive = false; unlockSkill.lastStartDatetime = 0; } } } return totalRewardCoin.ceil(); }; var calcTotalOrbs = function (){ let baseOrbs = new Decimal(((hero.maxFloor - setting.unlockReqFloorPrestige)/setting.prestigeFloorBonus)+(setting.baseGainOrbsCalculation)).pow(setting.orbsMultiplier); let partnerOrbs = new Decimal(calcTotalPartnerLevel()).plus(hero.heroLevel).plus(hero.weaponLevel).div(setting.prestigePartnerLevelBonus); let subTotalPercentage = new Decimal(100).plus(hero.bonusOrbsPercentage); let totalPercentage = new Decimal(100).plus(hero.bonusShopOrbsPercentage).mul(subTotalPercentage).div(10000); let totalOrbs = baseOrbs.plus(partnerOrbs).mul(totalPercentage); let percentageBonusOrbs = new Decimal(hero.percentageBonusOrbs); if(percentageBonusOrbs.lessThan(totalPercentage)) hero.percentageBonusOrbs = totalPercentage*100; return totalOrbs.floor(); }; var calcTotalPartnerLevel = function (){ let totalLevel = 0; for(let i=0;i<hero.unlockPartner.length;i++){ totalLevel += hero.unlockPartner[i].level; } return totalLevel; }; var calcCurrentUnlockArtifactFee = function(){ let unlockFee = new Decimal(hero.countArtifact).mul(Math.pow(setting.unlockArtifactMultiplier,hero.countArtifact)).floor(); return unlockFee; }; var calcNextUnlockArtifactFee = function(){ let unlockFee = new Decimal(hero.countArtifact+1).mul(Math.pow(setting.unlockArtifactMultiplier,(hero.countArtifact+1))).floor(); return unlockFee; }; var calcCurrentUpgradeArtifactFee = function(artifactId){ let upgradeArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); let upgradeFee = new Decimal(0); let lastUpgradeFee = new Decimal(0); if(upgradeArtifact){ for(let a=1; a<upgradeArtifact.level; a++){ lastUpgradeFee = new Decimal(setting.upgradeArtifactBaseTier + (artifactData.tier*setting.upgradeArtifactTierMultiplier)).mul(Math.pow((setting.upgradeArtifactMultiplier*artifactData.upgradeMultiplier),(a+1))).ceil(); upgradeFee = upgradeFee.plus(lastUpgradeFee); } } return upgradeFee; }; var calcNextUpgradeArtifactFee = function(artifactId){ let upgradeArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); let upgradeFee = 0; if(upgradeArtifact){ upgradeFee = new Decimal(setting.upgradeArtifactBaseTier + (artifactData.tier*setting.upgradeArtifactTierMultiplier)).mul(Math.pow((setting.upgradeArtifactMultiplier*artifactData.upgradeMultiplier),(upgradeArtifact.level+1))).ceil(); } return upgradeFee; }; var calcOfflineTime = function () { let onDateTime = Date.now(); let offlineTime = new Decimal(onDateTime).sub(hero.lastActiveDatetime); offlineTime = offlineTime.div(1000).floor(); if(offlineTime.greaterThanOrEqualTo(0)){ let offlineDpsPercentage = new Decimal(hero.bonusOfflineDpsPercentage).plus(100).div(100); let offlineCoinPercentage = new Decimal(hero.bonusOfflineCoinPercentage).plus(100).div(100); let heroDps = new Decimal(hero.dps).mul(offlineDpsPercentage); let totalOfflineTimeLimit = new Decimal(setting.baseOfflineTimeLimit).plus(hero.bonusOfflineTimeLimit).mul(60); let offlineTimeReward = offlineTime; if(offlineTime.greaterThan(totalOfflineTimeLimit)) offlineTimeReward = totalOfflineTimeLimit; if(heroDps.greaterThan(0) && offlineTimeReward.greaterThanOrEqualTo(3)){ if(hero.floor % enemy.bossFloor == 0) hero.floor--; let enemyHP = initEnemy(); let rewardCoin = new Decimal(calcTotalRewardCoin(false)).mul(offlineCoinPercentage).ceil(); let killingTime = new Decimal(enemyHP).div(heroDps).ceil(); let killingCount = new Decimal(offlineTimeReward).div(killingTime).floor(); hero.totalOfflineDuration = new Decimal(hero.totalOfflineDuration).plus(offlineTimeReward); let totalRewardCoin = new Decimal(rewardCoin).mul(killingCount); hero.coin = new Decimal(hero.coin).plus(totalRewardCoin); hero.totalOfflineCoin = new Decimal(hero.totalOfflineCoin).plus(totalRewardCoin); let enemyText = (killingCount > 1? " Enemies": " Enemy"); let totalRewardCoinText = (totalRewardCoin.greaterThan(1)? " Coins": " Coin"); let offlineText = "Welcome Back "+hero.userName+"\n"; offlineText += "You are offline for "+offlineTimeText(offlineTime)+"\n"; if(offlineTimeReward.lessThan(offlineTime)) offlineText += "Max offline reward "+offlineTimeText(offlineTimeReward)+"\n"; offlineText += "You are killing "+killingCount+enemyText+"\n"; offlineText += "And you got "+numberFormat(totalRewardCoin)+totalRewardCoinText+"\n"; componentAction ("offline-text", "replaceText", offlineText); $("#modalOfflineForm").modal('show'); } return false; }else return true; }; var offlineTimeText = function (offlineSecond) { if(offlineSecond >= 0){ let offlineYear = Math.floor(offlineSecond / 31104000); let offlineMonth = Math.floor((offlineSecond - (offlineYear*31104000)) / 2592000); let offlineDay = Math.floor((offlineSecond - (offlineYear*31104000) - (offlineMonth*2592000)) / 86400); let offlineHour = Math.floor((offlineSecond - (offlineYear*31104000) - (offlineMonth*2592000) - (offlineDay*86400)) / 3600); let offlineMin = Math.floor((offlineSecond - (offlineYear*31104000) - (offlineMonth*2592000) - (offlineDay*86400) - (offlineHour*3600)) / 60); let offlineSec = Math.floor(offlineSecond - (offlineYear*31104000) - (offlineMonth*2592000) - (offlineDay*86400) - (offlineHour*3600) - (offlineMin * 60)); let timerText = ""; if(offlineSecond >= 31104000) timerText += offlineYear+" Year "; if(offlineSecond >= 2592000) timerText += offlineMonth+" Month "; if(offlineSecond >= 86400 && offlineYear == 0) timerText += offlineDay+" Day "; if(offlineSecond >= 3600 && offlineMonth == 0) timerText += offlineHour+" Hour "; if(offlineSecond >= 60 && offlineDay == 0) timerText += offlineMin+" Min "; if(offlineHour == 0)timerText += offlineSec+" Sec"; return timerText; } }; var calcNextHeroDpc = function (level=0){ let totalNextHeroDpc = new Decimal(0); let levelMultiplier = 0; if(level > 0) levelMultiplier = level; else{ if(setting.levelUpgradeMultiplier > 0) levelMultiplier = setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier == 0) levelMultiplier = maxHeroLevelBuy; } for(let a=0; a<levelMultiplier; a++){ let nextHeroDpc = new Decimal(hero.heroLevel + a + 1).div(setting.heroDpcMultiplier).ceil(); totalNextHeroDpc = totalNextHeroDpc.plus(nextHeroDpc); if((hero.heroLevel + a + 1) / 10 == 1 || (hero.heroLevel + a + 1) % 25 == 0){ totalNextHeroDpc = totalNextHeroDpc.plus(hero.heroLevel + a + 1); } } return totalNextHeroDpc.ceil(); }; var calcNextWeaponDpc = function (level=0){ let totalNextWeaponDpc = new Decimal(0); let loopNextLevel = 0; if(level > 0) loopNextLevel = level; else{ if(hero.weaponLevel == 0) loopNextLevel = 1; else{ if(setting.levelUpgradeMultiplier > 0)loopNextLevel = setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier == 0)loopNextLevel = maxWeaponLevelBuy; } } for(let a=0; a<loopNextLevel; a++){ let nextWeaponDpc = new Decimal(hero.weaponLevel + a + 1).div(setting.weaponDpcMultiplier).ceil().mul(setting.baseWeaponDpc); totalNextWeaponDpc = totalNextWeaponDpc.plus(nextWeaponDpc); if((hero.weaponLevel + a + 1) / 10 == 1 || (hero.weaponLevel + a + 1) % 25 == 0){ totalNextWeaponDpc = totalNextWeaponDpc.plus((hero.weaponLevel + a + 1)*1.5); } } return totalNextWeaponDpc.ceil(); }; var calcNextPartnerDps = function (partnerId,level=0){ let totalNextPartnerDps = new Decimal(0); let loopNextLevel = 0; let currentPartnerLevel = 0; let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); if(unlockPartner){ if(level > 0) loopNextLevel = level; else{ if(setting.levelUpgradeMultiplier > 0)loopNextLevel = setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier == 0){ let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === partnerId); loopNextLevel = localMaxPartnerLevelBuy.maxLevelBuy; } } currentPartnerLevel = unlockPartner.level; }else loopNextLevel = 1; for(let a=0; a<loopNextLevel; a++){ let nextPartnerDps = new Decimal(currentPartnerLevel + a + 1).div(setting.partnerDpsMultiplier).ceil().mul(partnerData.baseDps); totalNextPartnerDps = totalNextPartnerDps.plus(nextPartnerDps); if((currentPartnerLevel + a + 1) / 10 == 1 || (currentPartnerLevel + a + 1) % 25 == 0){ totalNextPartnerDps = totalNextPartnerDps.plus((currentPartnerLevel + a + 1)*1.5); } } return totalNextPartnerDps.ceil(); }; var calcNextSkillDamage = function (skillId){ let nextSkillDamage = new Decimal(0); let loopNextLevel = 0; let currentSkillLevel = 0; let nextSkillLevel = 0; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let skillData = skill.find(item => item.id === skillId); if(unlockSkill){ if(setting.levelUpgradeMultiplier == 1)loopNextLevel = setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier >= 0){ let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === skillId); loopNextLevel = localMaxSkillLevelBuy.maxLevelBuy; } currentSkillLevel = unlockSkill.level; }else loopNextLevel = 1; nextSkillLevel = currentSkillLevel + loopNextLevel; if(nextSkillLevel >= 10) nextSkillDamage = (10 * skillData.damageMultiplier) + skillData.baseDamage; else nextSkillDamage = ((nextSkillLevel-1) * skillData.damageMultiplier) + skillData.baseDamage; return nextSkillDamage; }; var setSequenceName = function(a){ let textName = ''; switch(a){ case 0: case 20: textName = "1<sup>st</sup>"; break; case 1: case 21: textName = "2<sup>nd</sup>"; break; case 2: case 22: textName = "3<sup>rd</sup>"; break; default: textName = (a+1)+"<sup>th</sup>"; break; } return textName; }; var updateTab = function(menuName){ let tabName = ''; componentAction ("hero-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("partner-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("skill-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("shop-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("hero-area-div", "addClass", "d-none"); componentAction ("partner-area-div", "addClass", "d-none"); componentAction ("skill-area-div", "addClass", "d-none"); componentAction ("shop-area-div", "addClass", "d-none"); switch (menuName) { case 'hero': tabName = "hero-tab-button"; break; case 'partner': tabName = "partner-tab-button"; break; case 'skill': tabName = "skill-tab-button"; break; case 'shop': tabName = "shop-tab-button"; break; }; componentAction (tabName, "updateClass", "tab-button-unactive,tab-button-active"); componentAction (menuName+"-area-div", "removeClass", "d-none"); }; var clickDPC = function() { let start = Date.now(); let diffMiliSec = start - lastDateTimeClick; if(diffMiliSec > 85){ lastDateTimeClick = start; hero.totalClick = new Decimal(hero.totalClick).plus(1); if(hero.fastestClickInterval > diffMiliSec) hero.fastestClickInterval = diffMiliSec; hitDPC(); }; }; var hitDPC = function (){ let maxHpEnemy = new Decimal(enemy.maxHp); if(setting.cheat == 1) currentEnemyHP = new Decimal(0); else{let totalDPC = new Decimal(calcTotalDpc());currentEnemyHP = currentEnemyHP.sub(totalDPC);}let newHPBarWidth = new Decimal(currentEnemyHP).div(maxHpEnemy).mul(100); componentAction ("current-enemy-hp", "replaceText", numberFormat(currentEnemyHP)); componentAction ("progress-bar", "animate", newHPBarWidth); checkAction(); }; var runGrimReaper = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let maxHpEnemy = new Decimal(enemy.maxHp); let skillDamage = unlockSkill.damage; let randomPercentage = Math.random()*100; if(hero.floor % enemy.bossFloor == 0){ skillDamage -= 10; } if(randomPercentage <= skillDamage){ currentEnemyHP = new Decimal(0); }else{ let totalDamage = new Decimal(calcTotalDpc()).plus(calcTotalDps()).mul(2).floor(); currentEnemyHP = currentEnemyHP.sub(totalDamage); } let newHPBarWidth = new Decimal(currentEnemyHP).div(maxHpEnemy).mul(100); componentAction ("current-enemy-hp", "replaceText", numberFormat(currentEnemyHP)); componentAction ("progress-bar", "animate", newHPBarWidth); checkAction(); }; var useSkill = function (skillId){ let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); if(!unlockSkill.isCooldown){ switch(skillId){ case 0: startAutoClickerInterval(skillId); break; case 1: startPowerShotInterval(skillId); break; case 2: startSpecialForceInterval(skillId); break; case 3: startLuckyCoinInterval(skillId); break; case 4: startGrimReaperInterval(skillId); break; }; saveGame(); } }; var insertAvailableArtifact = function(){ if(availableArtifact.length > 0) availableArtifact = []; for(let i=0;i < artifact.length; i++){ let artifactId = artifact[i].id; let unlockArtifact = hero.unlockArtifact.find(item => item.id === artifactId); if(!unlockArtifact){ let artifactChance = 5 - artifact[i].tier; for(let j=0; j<artifactChance; j++){ availableArtifact.push(artifactId); } } } }; var insertAvailableArtifactForDebug = function(artifactArray){ let artifactArrayId = artifactArray.split(","); if(availableArtifact.length > 0) availableArtifact = []; for(let i=0; i<artifactArrayId.length; i++){ let artifactId = parseInt(artifactArrayId[i],10); let unlockArtifact = hero.unlockArtifact.find(item => item.id === artifactId); if(!unlockArtifact){ let artifactChance = 5 - artifact[i].tier; for(let j=0; j<artifactChance; j++){ availableArtifact.push(artifactId); } } } }; var insertSellArtifact = function(artifactId){ let artifactData = artifact.find(item => item.id === artifactId); let loopInsert = 5 - artifactData.tier; for(let i=0;i<loopInsert;i++){ availableArtifact.push(artifactId); } }; var showRandomArtifact = function(isReroll=false){ let rerollFee = new Decimal(calcNextUnlockArtifactFee()).div(2).ceil(); let tempAvailableArtifact = availableArtifact; let randomArtifactId = []; let countRandomArtifact = 0; if(isReroll){ hero.randomArtifactId = []; hero.orbs = new Decimal(hero.orbs).sub(rerollFee); } componentAction ("reroll-artifact-fee", "replaceText", numberFormat(rerollFee)+" Orbs"); componentAction ("unlock-artifact-confirm", "replaceText", numberFormat(calcNextUnlockArtifactFee())+" Orbs"); componentAction ("modal-orbs", "replaceText", numberFormat(hero.orbs)); $("#list-artifact-div").empty(); if(hero.randomArtifactId.length == 0){ randomArtifactId = []; while(randomArtifactId.length < setting.countArtifactForChoose){ let unlockArtifactId = tempAvailableArtifact[Math.floor(Math.random() * tempAvailableArtifact.length)]; let searchIndex = randomArtifactId.indexOf(unlockArtifactId); if (searchIndex === -1){ randomArtifactId.push(unlockArtifactId); countRandomArtifact++; } } hero.randomArtifactId = randomArtifactId; saveGame(); }else randomArtifactId = hero.randomArtifactId; for(let i=0;i<randomArtifactId.length;i++){ let artifactData = artifact.find(item => item.id === randomArtifactId[i]); let appendListArtifactDiv = '<div class="row border-top rounded-card m-1 p-1">'; appendListArtifactDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">' + artifactData.name +'</div>'; appendListArtifactDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">' + artifactData.description + ' ' + artifactData.baseDamage + artifactData.descDamage + ' / level</div>'; appendListArtifactDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'; appendListArtifactDiv += '<button id="random-artifact-button-' + artifactData.id + '" class="upgrade-level-button" value="' + artifactData.id + '">Unlock - ' + artifactData.name + '</button>'; appendListArtifactDiv += '</div>'; appendListArtifactDiv += '</div>'; $("#list-artifact-div").append(appendListArtifactDiv).off('click','#random-artifact-button-'+artifactData.id).on('click','#random-artifact-button-'+artifactData.id,function(){ confirmUnlockNewArtifact(artifactData.id); }); showArtifactArea(); } }; var confirmUnlockNewArtifact = function(artifactId){ let artifactData = artifact.find(item => item.id === artifactId); componentAction ("selected-unlock-artifact", "replaceText", artifactData.name); componentAction ("selected-unlock-fee", "replaceText", numberFormat(calcNextUnlockArtifactFee())); $("#modalRandomArtifactConfirm").modal('toggle'); $("#modalUnlockArtifactConfirm").modal("show"); componentAction ("unlock-artifact-ok-button", "inputText", artifactId); }; var unlockNewArtifact = function(artifactId=-1){ let unlockArtifactId = parseInt(artifactId,10); let unlockFee = new Decimal(calcNextUnlockArtifactFee()); let heroOrbs = new Decimal(hero.orbs); let artifactDamage = new Decimal(hero.artifactDamagePercentage); if(heroOrbs.greaterThanOrEqualTo(unlockFee)){ if(availableArtifact.length > 0){ let artifactData = artifact.find(item => item.id === unlockArtifactId); let unlockArtifact = hero.unlockArtifact.find(item => item.id === unlockArtifactId); if(!unlockArtifact){ let newObjArtifact = { id: unlockArtifactId, level: 1, grade: 0, damage: artifactData.baseDamage }; hero.unlockArtifact.push(newObjArtifact); hero.countArtifact++; hero.artifactDamagePercentage = artifactDamage.plus(artifactData.tier*5); removeArtifactId(unlockArtifactId); hero.orbs = heroOrbs.sub(unlockFee); hero.randomArtifactId = []; calculateAllArtifactDamage(); saveGame(); initDisplay(); showArtifactArea(); }else{ removeArtifactId(unlockArtifactId); unlockNewArtifact(); } } } }; var removeArtifactId = function(unlockArtifactId){ let unlockIndex = availableArtifact.indexOf(unlockArtifactId); if (unlockIndex !== -1)availableArtifact.splice(unlockIndex, 1); }; var hideAllContent = function(){ componentAction ("profile-div", "addClass", "d-none"); componentAction ("statistic-div", "addClass", "d-none"); componentAction ("daily-task-div", "addClass", "d-none"); componentAction ("dungeon-div", "addClass", "d-none"); componentAction ("artifact-div", "addClass", "d-none"); componentAction ("pet-div", "addClass", "d-none"); componentAction ("tutorial-div", "addClass", "d-none"); componentAction ("profile", "updateClass", "active,cursor-button"); componentAction ("statistic", "updateClass", "active,cursor-button"); componentAction ("daily-task", "updateClass", "active,cursor-button"); componentAction ("dungeon", "updateClass", "active,cursor-button"); componentAction ("artifact", "updateClass", "active,cursor-button"); componentAction ("pet", "updateClass", "active,cursor-button"); componentAction ("tutorial", "updateClass", "active,cursor-button"); }; var switchTutorPage = function(tutorNumber){ componentAction ("tutor-content-div-"+tutorNumber, "removeClass", "d-none"); if(activeTutorNumber != tutorNumber) componentAction ("tutor-content-div-"+activeTutorNumber, "addClass", "d-none"); componentAction ("tutor-div-"+activeTutorNumber, "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("tutor-div-"+tutorNumber, "updateClass", "tab-button-unactive,tab-button-active"); activeTutorNumber = tutorNumber; }; var numberFormat = function(x) { let value = new Decimal(x); if(value.greaterThan(9999)) return value.toPrecision(3).toString(); else return roundFormat(value,2); }; var roundFormat = function(value, decimals) { return Number(Math.round(value+'e'+decimals)+'e-'+decimals).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }; var alphaNumericSpaceFormat = function(value){ var reg_exp = /^[A-Za-z0-9 ]+$/; var is_valid = reg_exp.test(String.fromCharCode(value)); return is_valid; }; var dateFormat = function(milliseconds){ let dateObject = new Date(milliseconds); let humanDateFormat = dateObject.toLocaleString(); return humanDateFormat; }; var hideAllMenu = function(){ if ($("#info-status-div").hasClass("show-menu")) componentAction ("info-status-div", "updateClass", "show-menu,hide-menu"); componentAction ("profile", "addClass", "d-none"); componentAction ("statistic", "addClass", "d-none"); componentAction ("daily-task", "addClass", "d-none"); if ($("#gameplay-status-div").hasClass("show-menu")) componentAction ("gameplay-status-div", "updateClass", "show-menu,hide-menu"); componentAction ("dungeon", "addClass", "d-none"); componentAction ("artifact", "addClass", "d-none"); componentAction ("pet", "addClass", "d-none"); if ($("#other-status-div").hasClass("show-menu")) componentAction ("other-status-div", "updateClass", "show-menu,hide-menu"); componentAction ("tutorial", "addClass", "d-none"); componentAction ("save-game", "addClass", "d-none"); componentAction ("clear-game", "addClass", "d-none"); componentAction ("contact-dev", "addClass", "d-none"); }; var showMenu = function(menuName){ switch(menuName){ case 'info': componentAction ("info-status-div", "updateClass", "hide-menu,show-menu"); componentAction ("profile", "removeClass", "d-none"); componentAction ("statistic", "removeClass", "d-none"); componentAction ("daily-task", "removeClass", "d-none"); break; case 'gameplay': componentAction ("gameplay-status-div", "updateClass", "hide-menu,show-menu"); componentAction ("dungeon", "removeClass", "d-none"); componentAction ("artifact", "removeClass", "d-none"); componentAction ("pet", "removeClass", "d-none"); break; case 'other': componentAction ("other-status-div", "updateClass", "hide-menu,show-menu"); componentAction ("tutorial", "removeClass", "d-none"); componentAction ("save-game", "removeClass", "d-none"); componentAction ("clear-game", "removeClass", "d-none"); componentAction ("contact-dev", "removeClass", "d-none"); break; } }; initGame(); $("#dpc-button").on('click', function(e) { clickDPC(); }); $("#auto-progress-switch").on('click', function() { setting.autoProgress = $("#auto-progress-switch").prop("checked"); }); $("#play-button").on('click', function() { let userID = $("#user-id").val(); let userName = $("#user-name").val(); if(userName != ""){ hero.userId = userID; hero.userName = userName; hero.firstPlayDateTime = Date.now(), hero.firstGameVersion = setting.gameVersion, initGame(); $("#modalLoginForm").modal('toggle'); } }); $("#new-player-button").on('click', function() { $("#modalNewPlayer").modal('toggle'); showTutorialArea(); }); $("#dev-log-ok-button").on('click', function() { $("#modalDevLog").modal('toggle'); if(hero.totalGainOrbs == 0) showTutorialArea(); }); $("#continue-button").on('click', function() { $("#modalOfflineForm").modal('toggle'); checkCooldownAdventureTimer(true); saveGame(); }); $("#continue-prestige-ok-button").on('click', function() { $("#modalPrestigeForm").modal('toggle'); hideAllContent(); showArtifactArea(); }); $("#continue-prestige-no-button").on('click', function() { $("#modalPrestigeForm").modal('toggle'); }); $("#upgrade-level-button").on('click', function() { upgradeLevelHero(); }); $("#hero-tab-button").on('click', function() { updateTab("hero"); }); $("#partner-tab-button").on('click', function() { updateTab("partner"); }); $("#skill-tab-button").on('click', function(e) { updateTab("skill"); }); $("#shop-tab-button").on('click', function() { updateTab("shop"); }); $("#pet-tab-button").on('click', function() { showPetArea(); }); $("#area-tab-button").on('click', function() { showAdventureArea(); }); $("[id^=floor-number-div-]").on("click", function() { let floorNumber = parseInt($(this).text(),10); if(floorNumber <= hero.maxFloor && floorNumber <= setting.limitFloor){ hero.floor = floorNumber; componentAction ("progress-bar", "animate", 100); currentEnemyHP = initDungeon(); } }); $("#upgrade-weapon-button").on('click', function() { upgradeLevelWeapon(); }); $("#prestige-ok-button").on('click', function() { runPrestige(); }); $("#prestige-no-button").on('click', function() { $("#modalPrestigeConfirm").modal('toggle'); }); $("#clear-ok-button").on('click', function() { $("#modalClearConfirm").modal('toggle'); $("#modalAnotherClearConfirm").modal('show'); }); $("#clear-no-button").on('click', function() { $("#modalClearConfirm").modal('toggle'); }); $("#another-clear-ok-button").on('click', function() { localStorage.removeItem("hero"); location.reload(); }); $("#another-clear-no-button").on('click', function() { $("#modalAnotherClearConfirm").modal('toggle'); }); $("#sell-artifact-ok-button").on('click', function() { let artifactId = parseInt($('#sell-artifact-ok-button').val(),10); sellArtifact(artifactId); $("#modalSellArtifactConfirm").modal('toggle'); }); $("#sell-artifact-no-button").on('click', function() { $("#modalSellArtifactConfirm").modal('toggle'); }); $("#notif-prestige-ok-button").on('click', function() { $("#modalNotifPrestige").modal('toggle'); startPrestige(); }); $("#notif-prestige-no-button").on('click', function() { $("#modalNotifPrestige").modal('toggle'); }); $("#notif-pet-ok-button").on('click', function() { $("#modalNotifPet").modal('toggle'); hideAllContent(); showPetArea(); }); $("#notif-pet-no-button").on('click', function() { $("#modalNotifPet").modal('toggle'); }); $("#user-name").keypress(function (e) { var value = e.keyCode || e.which; return alphaNumericSpaceFormat(value); }); $("#profile").on('click', function() { hideAllContent(); componentAction ("profile-div", "removeClass", "d-none"); componentAction ("profile", "updateClass", "cursor-button,active"); componentAction ("profile-user-id", "inputText", hero.userId); componentAction ("profile-user-name", "inputText", hero.userName); }); $("#profile-user-name").keypress(function (e) { var value = e.keyCode || e.which; return alphaNumericSpaceFormat(value); }); $("#update-profile-button").on('click', function() { let userName = $("#profile-user-name").val(); if(userName != ""){ hero.userName = userName; componentAction ("view-username", "replaceText", hero.userName); saveGame(); $("#modalSaveForm").modal('show'); componentAction("save-text", "replaceText", "Update Profile Success"); let intervalModalSaveFOrm = setTimeout (function() { $("#modalSaveForm").modal('toggle'); },2000); } }); $("#statistic").on('click', function() { hideAllContent(); showStatisticArea(); }); $("#daily-task").on('click', function() { hideAllContent(); showDailyTaskArea(); }); $("#dungeon").on('click', function() { showDungeonArea(); }); $("[id^=button-buy-multiplier-]").on("click", function() { setting.levelUpgradeMultiplier = parseInt(this.value,10); initDisplay(); }); $("#artifact").on('click', function() { hideAllContent(); showArtifactArea(); }); $("#pet").on('click', function() { hideAllContent(); componentAction ("pet-div", "removeClass", "d-none"); componentAction ("pet", "updateClass", "cursor-button,active"); showPetArea(); }); $("#tutorial").on('click', function() { showTutorialArea(); }); $("[id^=tutor-div-]").on("click", function() { let tutorNumber = parseInt($(this).text(),10); switchTutorPage(tutorNumber); }); $("[id^=tutor-button-prev-]").on("click", function() { let tutorNumber = activeTutorNumber - 1; if(tutorNumber < 1) tutorNumber = 1; switchTutorPage(tutorNumber); }); $("[id^=tutor-button-next-]").on("click", function() { let tutorNumber = activeTutorNumber + 1; if(tutorNumber > setting.maxTutorPage) tutorNumber = setting.maxTutorPage; switchTutorPage(tutorNumber); }); $("[id^=tutor-div-]").on("click", function() { let tutorNumber = parseInt($(this).text(),10); switchTutorPage(tutorNumber); }); $("#tutor-button-finish").on("click",function (){ showDungeonArea(); }); $("#unlock-artifact-button").on('click', function() { let unlockFee = new Decimal(calcNextUnlockArtifactFee()); let heroOrbs = new Decimal(hero.orbs); if(heroOrbs.greaterThanOrEqualTo(unlockFee)){ $("#modalRandomArtifactConfirm").modal('show'); showRandomArtifact(); }else $("#modalUnlockArtifactFailed").modal('show'); }); $("#random-artifact-ok-button").on('click', function() { let rerollFee = new Decimal(calcNextUnlockArtifactFee()).div(2).ceil(); $("#modalRandomArtifactConfirm").modal('toggle'); $("#modalRerollArtifactConfirm").modal('show'); componentAction ("confirm-reroll-artifact-fee", "replaceText", rerollFee); }); $("#random-artifact-no-button").on('click', function() { $("#modalRandomArtifactConfirm").modal('toggle'); }); $("#reroll-artifact-ok-button").on('click', function() { $("#modalRerollArtifactConfirm").modal('toggle'); $("#modalRandomArtifactConfirm").modal('show'); showRandomArtifact(true); showArtifactArea(); }); $("#reroll-artifact-no-button").on('click', function() { $("#modalRerollArtifactConfirm").modal('toggle'); $("#modalRandomArtifactConfirm").modal('show'); }); $("#unlock-artifact-ok-button").on('click', function() { $("#modalUnlockArtifactConfirm").modal("toggle"); unlockNewArtifact($('#unlock-artifact-ok-button').val()); }); $("#unlock-artifact-no-button").on('click', function() { $("#modalUnlockArtifactConfirm").modal("toggle"); $("#modalRandomArtifactConfirm").modal('show'); }); $("#continue-failed-unlock-artifact-button").on('click', function() { $("#modalUnlockArtifactFailed").modal('toggle'); }); $("#confirm-adventure-ok-button").on('click', function() { $("#modalStartAdventureConfirm").modal('toggle'); startAdventurePet($('#confirm-adventure-ok-button').val()); }); $("#confirm-adventure-no-button").on('click', function() { $("#modalStartAdventureConfirm").modal('toggle'); }); $("#collect-reward-adventure-ok-button").on('click', function() { $("#modalCollectRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet($('#collect-reward-adventure-ok-button').val()); }); $("#collect-reward-adventure-no-button").on('click', function() { $("#modalCollectRewardAdventureConfirm").modal('toggle'); }); $("#confirm-reward-adventure-ok-button").on('click', function() { $("#modalRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet($('#confirm-reward-adventure-ok-button').val()); }); $("#confirm-reward-adventure-no-button").on('click', function() { $("#modalRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet($('#confirm-reward-adventure-ok-button').val(),true); }); $("#confirm-list-reward-adventure-ok-button").on('click', function() { $("#modalListRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet('complete'); }); $("#confirm-list-reward-adventure-no-button").on('click', function() { $("#modalListRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet('complete',true); }); $("#save-game").on('click', function() { saveGame(); componentAction ("save-text", "replaceText", "Save Data Success"); $("#modalSaveForm").modal('show'); let intervalModalSaveFOrm = setTimeout (function() { $("#modalSaveForm").modal('toggle'); },2000); }); $("#clear-game").on('click', function() { $("#modalClearConfirm").modal('show'); }); $("#contact-dev").on('click', function() { let bodyEmail = 'Endless Dungeon v'+setting.gameVersion+'\r\n'; bodyEmail += 'UserID : '+hero.userId+'\r\n'; bodyEmail += 'UserName : '+hero.userName+'\r\n'; bodyEmail += JSON.stringify(hero); /*bodyEmail = encodeURIComponent(bodyEmail); let file = new Blob([bodyEmail], {type: "text/plain;charset=utf-8"}); if (window.navigator.msSaveOrOpenBlob){ window.navigator.msSaveOrOpenBlob(file, 'kuroidledungeon.txt'); }else { var a = document.createElement('a'), url = URL.createObjectURL(file); a.href = url; a.download = 'kuroidledungeon.txt'; document.body.appendChild(a); a.click(); setTimeout(function() { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 0); }*/ window.open('mailto:kuropone.solodev@gmail.com?subject=Endless Dungeon Contact Dev&body='+bodyEmail); }); $("#info-div").on('click', function() { if ($("#info-status-div").hasClass("hide-menu")){ hideAllMenu(); showMenu('info'); } }); $("#gameplay-div").on('click', function() { if ($("#gameplay-status-div").hasClass("hide-menu")){ hideAllMenu(); showMenu('gameplay'); } }); $("#other-div").on('click', function() { if ($("#other-status-div").hasClass("hide-menu")){ hideAllMenu(); showMenu('other'); } }); })(jQuery);
