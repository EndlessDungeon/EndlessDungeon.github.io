(function($) { "use strict"; var dpsTimeout; var lastDpsHit; var restBossTimer; var bossTimeout; var lastBossTimer; var localSaveTimeout; var cloudSaveTimeout; var autoClickerDuration; var autoClickerInterval; var autoClickerTimeout; var lastAutoClickerHit; var powerShotDuration; var specialForceDuration; var luckyCoinDuration; var grimReaperDuration; var grimReaperTimeout; var lastGrimReaperHit; var billionaireTimeout; var lastBillionaireHit; var stealCoinInterval; var stealCoinTimer = new Decimal(0); var dpcToCoinInterval; var dpcToCoinTimer = new Decimal(0); var dpsToCoinInterval; var dpsToCoinTimer = new Decimal(0); var tempShopInterval; var skillCooldownInterval = []; var adventureTimerInterval = []; var currentEnemyHP = new Decimal(0); var lastDateTimeClick = Date.now(); var availableArtifact = []; var availableGods = []; var activeTutorNumber = 1; var notifCanPrestige = true; var maxHeroLevelBuy = 0; var maxWeaponLevelBuy = 0; var maxPartnerLevelBuy = []; var maxSkillLevelBuy = []; var countHitHighestDpc = 0; var countHitHighestDps = 0; var countHitCurrentSlash = 0; var countHitCurrentDpc = 0; var countHitCurrentDps = 0; var lastActiveMenu = ''; var activeScreen = true; var lastActiveScreen = true; const constNoteCancelAdventure = "* Click button again to cancel adventure"; var initGame = function() { let backDateStatus = true; showGameVersion(); backDateStatus = loadGame(); if(!backDateStatus){ if(hero.userName != ""){ updateData(); updateAdventureStatus(); insertAchievement(); calculateAllAchievement(); insertDailyTask(); currentEnemyHP = initDungeon(); showDungeonArea(); initDisplay(); checkCooldownAdventureTimer(); insertAvailableArtifact(); calculateAllArtifactDamage(); calculateAllActiveGods(); calculateAllPartnerAbility(); insertAvailableGods(); saveGame(); startDpsInterval(); checkCssSetting(); }else $("#user-name").focus(); }else $("#modalBackDateConfirm").modal('toggle'); }; var loadGame = function () { let backDateStatus = true; if(localStorage.getItem("hero")){ hero = JSON.parse(localStorage.getItem("hero")); backDateStatus = calcOfflineTime(); }else{ firstTimeVisit(); backDateStatus = false; } return backDateStatus; }; var saveGame = function () { if(hero.userID != "" && hero.userName != ""){ localSaveGame(); if(localSaveTimeout) localSaveTimeout = clearTimeout(localSaveTimeout); let newLocalSaveTimer = setting.localSaveTimer*1000; localSaveTimeout = setTimeout(function loopLocalSaveTimer(){ localSaveGame(); localSaveTimeout = setTimeout(loopLocalSaveTimer,newLocalSaveTimer); },newLocalSaveTimer); } }; var exportData = function (isDonwload=false){ let exportSaveData = ''; exportSaveData = CryptoJS.AES.encrypt(JSON.stringify(hero), setting.keyGame).toString(); if(isDonwload){ let fileName = "KID-"+hero.userId+"-"+hero.userName; let file = new Blob([exportSaveData], {type: "text/plain;charset=utf-8"}); if (window.navigator.msSaveOrOpenBlob){ window.navigator.msSaveOrOpenBlob(file, fileName+'.txt'); }else { var a = document.createElement('a'), url = URL.createObjectURL(file); a.href = url; a.download = fileName+'.txt'; document.body.appendChild(a); a.click(); setTimeout(function() { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 0); } }else componentAction ("export-data", "replaceText", exportSaveData); }; var importData = function (){ let importData = $("#import-data").val().trim(); let bytes = CryptoJS.AES.decrypt(importData, setting.keyGame); let decryptSaveData; try { decryptSaveData = JSON.parse(bytes.toString(CryptoJS.enc.Utf8)); hero = decryptSaveData; saveGame(); $("#modalNotification").modal("show"); componentAction ("notification-text", "replaceText", "Import Data Success"); componentAction ("import-data", "clearArea", ""); $('#notification-ok-button').val(true); }catch (e) { $("#modalNotification").modal("show"); componentAction ("notification-text", "replaceText", "Wrong Import Data"); $('#notification-ok-button').val(false); } }; var localSaveGame = function () { let onlineDuration = 0; if(hero.gameVersion.localeCompare('0.5-alpha') < 0){ if(!($("#modalOfflineForm").data('bs.modal') || {})._isShown && !($("#modalRewardAdventureConfirm").data('bs.modal') || {})._isShown && !($("#modalListRewardAdventureConfirm").data('bs.modal') || {})._isShown){ $("#modalDevLog").modal("show"); calcHeightScrollDiv("modal"); componentAction("gameVersion", "replaceText", setting.gameVersion); } } hero.gameVersion = setting.gameVersion; if(hero.lastActiveDatetime > 0) onlineDuration = (Date.now() - hero.lastActiveDatetime) / 1000; updateDailyTask(11, onlineDuration); hero.totalOnlineDuration = new Decimal(hero.totalOnlineDuration).plus(onlineDuration); hero.lastActiveDatetime = Date.now(); localStorage.setItem("hero", JSON.stringify(hero)); }; var cloudSaveGame = function () { }; var checkCssSetting = function(){ if(hero.settingShowIcon) { $('.image-size').css({"display":""}); $('.image-size-2').css({"display":""}); }else{ $('.image-size').css({"display":"none"}); $('.image-size-2').css({"display":"none"}); } switch(hero.settingBackground){ case "light": $('body').css({"color":"#000000", "background-color":"#FFFFFF"}); $('.card').css({"color":"#000000", "background-color":"#FFFFFF"}); $('.card-header').css({"color":"#000000", "background-color":"#f8f9fc"}); $('.gods').css({"filter":""}); $('.goddess').css({"filter":""}); $('.active-bg-color').css({"color":"#000000"}); $('.progress-bar-div').css({"color":"#000000"}); $('.tab-active .progress-bar-div').css({"color":"#000000", "background-color":"#000000"}); $('.tab-button-active').css({"border":"1px solid #CCCCCC","background-color":"#00ffff"}); $('.tab-button-unactive').css({"border":"1px solid #CCCCCC","background-color":"#FFFFFF"}); $('.upgrade-level-button,.shop-button-class,.dpc-button').css({"color":"#000000", "background-color":"#FFFFFF"}); $('.modal-content').css({"background-color":"#FFFFFF"}); $('#content-wrapper').css({"background-color":"#f8f9fc"}); $('#icon-menu').css({"filter":""}); componentAction("sticky-topbar,sticky-footbar", "updateClass", "bg-dark,bg-white"); break; case "dark": $('body').css({"color":"#FFFFFF", "background-color":"#000000"}); $('.card').css({"color":"#FFFFFF", "background-color":"#000000"}); $('.card-header').css({"color":"#FFFFFF", "background-color":"#333333"}); $('.gods').css({"filter":"invert(100%) sepia(0%) saturate(7476%) hue-rotate(110deg) brightness(98%) contrast(108%)"}); $('.goddess').css({"filter":"invert(100%) sepia(0%) saturate(7476%) hue-rotate(110deg) brightness(98%) contrast(108%)"}); $('.active-bg-color').css({"color":"#FFFFFF"}); $('.progress-bar-div').css({"color":"#FFFFFF"}); $('.tab-active').css({"color":"#000000"}); $('.tab-active .progress-bar-div').css({"color":"#FFFFFF", "background-color":"#000000"}); $('.tab-button-active').css({"border":"1px solid #FFFFFF","background-color":"#00ffff"}); $('.tab-button-unactive').css({"border":"1px solid #FFFFFF","background-color":"#555555"}); $('.upgrade-level-button,.shop-button-class,.dpc-button').css({"color":"#FFFFFF", "background-color":"#555555"}); $('.modal-content').css({"background-color":"#000000"}); $('#content-wrapper').css({"background-color":"#000000"}); $('#icon-menu').css({"filter":"invert(100%) sepia(0%) saturate(7476%) hue-rotate(110deg) brightness(98%) contrast(108%)"}); componentAction("sticky-topbar,sticky-footbar", "updateClass", "bg-white,bg-dark"); break; }; }; var resetGame = function (isPrestige=false){ let lastCoin = new Decimal(hero.coin); hero.heroLevel = 1; hero.weaponLevel = 0; hero.dps = 0; hero.dpc = 1; hero.weaponDpc = 0; hero.floor = 1; hero.maxFloor = 1; hero.coin = 0; hero.countSkill = 0; hero.unlockSkill = []; hero.weaponAreaShow = 0; if(isPrestige){ let totalDps = new Decimal(0); let lastUnlockPartner = hero.unlockPartner; hero.coin = runCarriedCoin(lastCoin); hero.countPartner = 0; hero.unlockPartner = []; for(let i=0;i<hero.unlockPet.length;i++){ let unlockPet = hero.unlockPet[i]; unlockPet.currBonus = unlockPet.currBonus * 1; switch(unlockPet.id){ case 0: let heroDpc = calcNextHeroDpc(unlockPet.currBonus); hero.heroLevel = unlockPet.currBonus; hero.dpc = heroDpc; break; case 1: let weaponDpc = calcNextWeaponDpc(unlockPet.currBonus); hero.weaponLevel = unlockPet.currBonus; hero.weaponDpc = weaponDpc; break; case 2: hero.floor = unlockPet.currBonus + 1; hero.maxFloor = hero.floor; break; default: let partnerId = unlockPet.id - 3; let selectedLastUnlockPartner = lastUnlockPartner.find(item => item.id === partnerId); let newObjPartner = { id: partnerId, level: 0, dps: 0, status: selectedLastUnlockPartner.status, abilityId: -1, abilityCounter: 0, }; hero.unlockPartner.push(newObjPartner); let nextDps = new Decimal(calcNextPartnerDps(partnerId,unlockPet.currBonus)); let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); unlockPartner.dps = 0; unlockPartner.bonusDps = nextDps; totalDps = totalDps.plus(nextDps); hero.dps = totalDps; hero.countPartner++; break; } } let restingPartner = hero.highestUnlockPartner.filter(item => item.status === 'Resting'); for(let i=0;i<restingPartner.length;i++){ restingPartner.status = 'Battling'; } startDpsInterval(true); } }; var updateData = function (){ if(hero.highestPartnerUnlock){ delete hero.highestPartnerUnlock; hero.highestUnlockPartner = []; } if(!hero.type) hero.type = "free"; if(!hero.activeGodsSlot) hero.activeGodsSlot = 0; if(!hero.activeTrainingSlot) hero.activeTrainingSlot = 0; if(hero.activeGodsSlot == 0 && hero.highestFloor >= setting.unlockReqFloorGods) hero.activeGodsSlot = 1; if(hero.activeTrainingSlot == 0 && hero.highestFloor >= setting.unlockReqFloorBarracks) hero.activeTrainingSlot = 1; if(!hero.activeAbilityPartner) hero.activeAbilityPartner = 1; if(hero.highestPartnerLevel) delete hero.highestPartnerLevel; if(hero.totalPartnerLevel) delete hero.totalPartnerLevel; if(hero.highestUnlockPet) delete hero.highestUnlockPet; if(hero.barracks) delete(hero.barracks); if(hero.totalArtifactUnlock == 0) hero.totalArtifactUnlock = hero.countArtifact; if(!hero.countZone) hero.countZone = 0; if(!hero.unlockZone) hero.unlockZone = []; if(!hero.countGods) hero.countGods = 0; if(!hero.unlockGods) hero.unlockGods = []; if(!hero.unlockFragment) hero.unlockFragment = []; if(!hero.dailyTask) hero.dailyTask = []; if(!hero.achievement) hero.achievement = []; if(!hero.randomArtifactId) hero.randomArtifactId = []; if(!hero.highestUnlockPartner) hero.highestUnlockPartner = []; if(!hero.totalSkillUsed) hero.totalSkillUsed = []; if(!hero.soul) hero.soul = 0; if(!hero.percentageBonusDpc) hero.percentageBonusDpc = 0; if(!hero.percentageBonusDps) hero.percentageBonusDps = 0; if(!hero.percentageBonusAbility) hero.percentageBonusAbility = 0; if(!hero.percentageBonusCoin) hero.percentageBonusCoin = 0; if(!hero.percentageBonusOrbs) hero.percentageBonusOrbs = 0; if(!hero.tempBonusShopDpcTime) hero.tempBonusShopDpcTime = 0; if(!hero.tempBonusShopDpsTime) hero.tempBonusShopDpsTime = 0; if(!hero.tempBonusShopCoinTime) hero.tempBonusShopCoinTime = 0; if(!hero.tempBonusShopOrbsTime) hero.tempBonusShopOrbsTime = 0; if(!hero.bonusAdventureExpPercentage) hero.bonusAdventureExpPercentage = 0; if(!hero.bonusAdventureCoinPercentage) hero.bonusAdventureCoinPercentage = 0; if(!hero.bonusAdventureTimePercentage) hero.bonusAdventureTimePercentage = 0; if(!hero.bonusDoubleAdventurePercentage) hero.bonusDoubleAdventurePercentage = 0; if(!hero.bonusArtifactRerollFeePercentage) hero.bonusArtifactRerollFeePercentage = 0; if(!hero.bonusArtifactUnlockFeePercentage) hero.bonusArtifactUnlockFeePercentage = 0; if(!hero.bonusArtifactUpgradeFeePercentage) hero.bonusArtifactUpgradeFeePercentage = 0; if(!hero.bonusChanceStealCoinPercentage) hero.bonusChanceStealCoinPercentage = 0; if(!hero.bonusChanceDpcToCoinPercentage) hero.bonusChanceDpcToCoinPercentage = 0; if(!hero.bonusChanceDpsToCoinPercentage) hero.bonusChanceDpsToCoinPercentage = 0; if(!hero.bonusChanceExtraCoinPercentage) hero.bonusChanceExtraCoinPercentage = 0; if(!hero.bonusChanceAddOrbsPrestigePercentage) hero.bonusChanceAddOrbsPrestigePercentage = 0; if(!hero.bonusChanceAddOrbsFloorPercentage) hero.bonusChanceAddOrbsFloorPercentage = 0; if(!hero.bonusChanceCarriedCoinPercentage) hero.bonusChanceCarriedCoinPercentage = 0; if(!hero.bonusChanceUpgradeDiscountPercentage) hero.bonusChanceUpgradeDiscountPercentage = 0; if(!hero.bonusGodsDpsPercentage) hero.bonusGodsDpsPercentage = 0; if(!hero.bonusGodsDpcPercentage) hero.bonusGodsDpcPercentage = 0; if(!hero.bonusChanceHitHighestDpcPercentage) hero.bonusChanceHitHighestDpcPercentage = 0; if(!hero.bonusChanceHitHighestDpsPercentage) hero.bonusChanceHitHighestDpsPercentage = 0; if(!hero.bonusChanceHitCurrentSlashPercentage) hero.bonusChanceHitCurrentSlashPercentage = 0; if(!hero.bonusChanceHitCurrentDpcPercentage) hero.bonusChanceHitCurrentDpcPercentage = 0; if(!hero.bonusChanceHitCurrentDpsPercentage) hero.bonusChanceHitCurrentDpsPercentage = 0; if(!hero.bonusMeleeDpsPercentage) hero.bonusMeleeDpsPercentage = 0; if(!hero.bonusStealthDpsPercentage) hero.bonusStealthDpsPercentage = 0; if(!hero.bonusSwordDpsPercentage) hero.bonusSwordDpsPercentage = 0; if(!hero.bonusRangedDpsPercentage) hero.bonusRangedDpsPercentage = 0; if(!hero.bonusMagicDpsPercentage) hero.bonusMagicDpsPercentage = 0; if(!hero.bonusFirearmDpsPercentage) hero.bonusFirearmDpsPercentage = 0; if(!hero.bonusRuneDpsPercentage) hero.bonusRuneDpsPercentage = 0; if(!hero.bonusAllDamagePercentage) hero.bonusAllDamagePercentage = 0; if(!hero.bonusAllCoinPercentage) hero.bonusAllCoinPercentage = 0; if(!hero.bonusAbilityPercentage) hero.bonusAbilityPercentage = 0; if(!hero.bonusMeleeAbilityPercentage) hero.bonusMeleeAbilityPercentage = 0; if(!hero.bonusStealthAbilityPercentage) hero.bonusStealthAbilityPercentage = 0; if(!hero.bonusSwordAbilityPercentage) hero.bonusSwordAbilityPercentage = 0; if(!hero.bonusRangedAbilityPercentage) hero.bonusRangedAbilityPercentage = 0; if(!hero.bonusMagicAbilityPercentage) hero.bonusMagicAbilityPercentage = 0; if(!hero.bonusFirearmAbilityPercentage) hero.bonusFirearmAbilityPercentage = 0; if(!hero.bonusRuneAbilityPercentage) hero.bonusRuneAbilityPercentage = 0; if(!hero.settingOrderPartner) hero.settingOrderPartner = "asc"; if(!hero.settingShowIcon && hero.settingShowIcon != false) hero.settingShowIcon = true; if(!hero.settingAutoAbilityTraining && hero.settingAutoAbilityTraining != false) hero.settingAutoAbilityTraining = true; if(!hero.settingBackground) hero.settingBackground = "light"; if(!hero.settingFormatNumber) hero.settingFormatNumber = "number"; if(!hero.settingOfflineProgress && hero.settingOfflineProgress != false) hero.settingOfflineProgress = true; updateDataAfterUpdate(); }; var updateDataAfterUpdate = function(){ hero.soul = hero.totalBossEnemyKilled + hero.totalNormalEnemyKilled; let dragonPet = hero.unlockPet.find(item => item.id === 2); if(dragonPet){ let petData = pet.find(item => item.id === 2); dragonPet.currBonus = dragonPet.level * petData.multiplierBonus; } if(hero.gameVersion.localeCompare('0.4-alpha') < 0){ let unlockSkill = hero.unlockSkill.find(item => item.id === 4); let fifthUnlockSkill = hero.unlockSkill.find(item => item.id === 5); if(!fifthUnlockSkill && unlockSkill){ let moveObjSkill = { id: 5, level: unlockSkill.level, damage: unlockSkill.damage, duration: unlockSkill.duration, cooldown: unlockSkill.cooldown, isActive: unlockSkill.isActive, lastStartDatetime: unlockSkill.lastStartDatetime, isCooldown: unlockSkill.isCooldown, lastCooldownDatetime: unlockSkill.lastCooldownDatetime }; hero.unlockSkill.push(moveObjSkill); let removeIndex = hero.unlockSkill.map(function(item) { return item.id; }).indexOf(4); if (removeIndex !== -1)hero.unlockSkill.splice(removeIndex, 1); } } if(hero.gameVersion.localeCompare('0.5-alpha') < 0){ if(!hero.trainingZone){ hero.trainingZone = { level: 1, reqMaterial: [], buildingTime: 0, maxSlot: 1, trainingSlot: [], }; } for(let i=0;i<hero.unlockPartner.length;i++){ let unlockPartner = hero.unlockPartner[i]; unlockPartner.status = "Battling"; unlockPartner.abilityCounter = 0; unlockPartner.abilityId = -1; } for(let i=0;i<hero.highestUnlockPartner.length;i++){ let highestUnlockPartner = hero.highestUnlockPartner[i]; let partnerId = highestUnlockPartner.id; let partnerData = partner.find(item => item.id === partnerId); highestUnlockPartner.status = "Battling"; highestUnlockPartner.ability = []; if(hero.highestFloor >= setting.unlockReqFloorBarracks){ if(hero.activeTrainingSlot == 0 || !hero.activeTrainingSlot) hero.activeTrainingSlot = 1; insertPartnerAbility(partnerId, partnerData.type); } } for(let i=0;i<hero.unlockPet.length;i++){ let petData = pet.find(item => item.id === hero.unlockPet[i].id); hero.unlockPet[i].currBonus = hero.unlockPet[i].level * petData.multiplierBonus; } } }; var firstTimeVisit = function () { let currentDatetime = new Date(); let date = currentDatetime.getDate(); let month = currentDatetime.getMonth() + 1; let year = currentDatetime.getFullYear().toString().substr(-2); let hour = currentDatetime.getHours(); let min = currentDatetime.getMinutes(); let sec = currentDatetime.getSeconds(); let firstID = parseInt(year,10).toString(36)+month.toString(36)+date.toString(36)+hour.toString(36)+min.toString(36)+sec.toString(36); let userID = firstID.toUpperCase()+randomString(10-firstID.length); componentAction("user-id", "inputText", userID); $("#modalLoginForm").modal('show'); }; var randomString = function (len) { let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let charactersLength = characters.length; let result = ""; for ( var i = 0; i < len; i++ ) { result += characters.charAt(Math.floor(Math.random() * charactersLength)); } return result; }; var initDungeon = function() { let enemyHP = new Decimal(initEnemy()); enemy.maxHp = enemyHP; componentAction ("current-enemy-hp,max-enemy-hp", "replaceText", numberFormat(enemyHP)); countHitHighestDpc = 0; countHitHighestDps = 0; countHitCurrentSlash = 0; countHitCurrentDpc = 0; countHitCurrentDps = 0; initDisplay(); return enemyHP; }; var initDisplay = function(){ updateUpgradeLevelFeeHero(); updateUpgradeLevelFeeWeapon(); updateUpgradeLevelFeeAllPartner(); showBuyArea(); showBodyArea(); showWeaponArea(); showPartnerArea(); showShopArea(); showSkillArea(); showAutoProgress(); showOrbsArea(); showFloorNumber(); showPrestigeArea(); if(!$("#gods-div").hasClass("d-none") && !$("#temple-area-div").hasClass("d-none")) showTempleArea(); updateUpgradeLevelFeeAllSkill(); updateUserName(); updateHeroDpc(); updateHeroCoin(); updateHeroDps(); updateWeaponDpc(); updateHeroLevel(); updatePartner(); updateSkill(); updateWeaponLevel(); saveGame(); checkCssSetting(); }; var runBossTimer = function(showAnimation=false, newBossInterval){ let maxBossTimer = new Decimal(setting.baseBossTimeLimit).plus(hero.bonusBossTimeLimit).mul(1000); if(showAnimation){ let widthTimerBar = new Decimal(restBossTimer).div(maxBossTimer).mul(100); componentAction ("timer-bar", "animate", widthTimerBar); } }; var loopBossTimer = function(){ let newBossInterval = 1000; let interval = Date.now() - lastBossTimer; while(interval >= newBossInterval){ runBossTimer(false, newBossInterval); interval -= newBossInterval; lastBossTimer += newBossInterval; restBossTimer -= newBossInterval; } lastBossTimer += newBossInterval; runBossTimer(true, newBossInterval); restBossTimer -= newBossInterval; if(restBossTimer > 0) bossTimeout = setTimeout(loopBossTimer, (newBossInterval - interval)); else { componentAction ("timer-bar", "removeClass", "timer-bar-bgcolor"); hero.floor--; currentEnemyHP = initDungeon(); componentAction ("progress-bar", "animate", 100); hero.autoProgressShow = 1; setting.autoProgress = false; showAutoProgress(); bossTimeout = clearTimeout(bossTimeout); } }; var initEnemy = function(){ let baseEnemyHP = new Decimal(setting.enemyHPMultiplier).pow(hero.floor-1).mul(enemy.baseHp); let enemyHpPercentage = new Decimal(100).sub(hero.bonusEnemyHpPercentage).div(100); let enemyHP = baseEnemyHP.mul(enemyHpPercentage); if(bossTimeout)bossTimeout = clearTimeout(bossTimeout); if(hero.floor % enemy.bossFloor == 0){ let bossHpPercentage = new Decimal(100).sub(hero.bonusBossHpPercentage).div(100); componentAction ("current-enemy-name", "replaceText", enemy.listBoss[Math.floor(Math.random() * enemy.listBoss.length)]); componentAction ("timer-bar", "animate", 100); enemyHP = enemyHP.mul(2.5); enemyHP = enemyHP.mul(bossHpPercentage); componentAction ("timer-bar", "addClass", "timer-bar-bgcolor"); restBossTimer = ((setting.baseBossTimeLimit * 1) + (hero.bonusBossTimeLimit * 1)) * 1000; lastBossTimer = Date.now(); loopBossTimer(); }else{ componentAction ("current-enemy-name", "replaceText", enemy.listName[Math.floor(Math.random() * enemy.listName.length)]); componentAction ("timer-bar", "removeClass", "timer-bar-bgcolor"); } return (enemyHP.ceil()); }; var insertPartnerAbility = function(partnerId, partnerDataType, abilityTypeId=0){ let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let abilityTypeData = abilityType.find(item => item.id === abilityTypeId); let partnerAbilityData = partnerAbility.find(item => item.partnerType === partnerDataType && item.abilityTypeId === abilityTypeId); let highestUnlockPartnerAbility = highestUnlockPartner.ability.find(item => item.abilityId === partnerAbilityData.id); if(partnerAbilityData && abilityTypeData && !highestUnlockPartnerAbility){ let newPartnerAbility = { abilityId: partnerAbilityData.id, abilityLevel: 1, maxLevel: 100, trainingTime: 0, trainingStatus: false, tempAbilityPoint: 0, abilityPoint: 0, exp: 0, maxExp: 10, interval: abilityTypeData.interval, tempAccuracy: 0, accuracy: abilityTypeData.accuracy, tempDamage: 0, damage: abilityTypeData.damage, isActive: false, newAbility: true, }; highestUnlockPartner.ability.push(newPartnerAbility); } }; var collectSoul = function(heroFloor){ hero.soul++; }; var checkAction = function(showAnimation=false) { if(currentEnemyHP.lessThanOrEqualTo(0)){ if(showAnimation) componentAction ("progress-bar", "animate", 100); let rewardCoin = new Decimal(calcTotalRewardCoin()); let extraCoin = new Decimal(runExtraCoin(rewardCoin)); hero.coin = new Decimal(hero.coin).plus(rewardCoin).plus(extraCoin).ceil(); hero.totalGainCoin = new Decimal(hero.totalGainCoin).plus(rewardCoin).plus(extraCoin).ceil(); if(setting.autoProgress){ if(hero.floor < setting.limitFloor){ hero.floor++; updateDailyTask(10); } if(hero.floor % enemy.bossFloor != 0){ updateDailyTask(5); hero.totalNormalEnemyKilled++; let randomSkipFloorChance = Math.random()*100; if(randomSkipFloorChance <= hero.bonusChanceSkipFloorPercentage && hero.floor < setting.limitFloor){ hero.floor++; updateDailyTask(10); } }else{ updateDailyTask(6); hero.totalBossEnemyKilled++; } collectSoul(hero.floor); if(hero.maxFloor < hero.floor){ hero.maxFloor = hero.floor; runStealOrbs(); } if(!$("#skill-area-div").hasClass("d-none")){ showSkillArea(); } }else{ if(hero.floor % enemy.bossFloor == 0){ updateDailyTask(6); hero.totalBossEnemyKilled++; }else{ updateDailyTask(5); hero.totalNormalEnemyKilled++; } collectSoul(hero.floor); if(hero.maxFloor < (hero.floor + 1) && hero.floor < setting.limitFloor){ hero.maxFloor = hero.floor + 1; if(hero.floor % enemy.bossFloor == 0){ setting.autoProgress = true; showAutoProgress(); hero.floor++; updateDailyTask(10); } } } if(hero.highestFloor < hero.maxFloor) hero.highestFloor = hero.floor; currentEnemyHP = initDungeon(); unlockNewPet(); unlockNewFeatures(); } if(hero.maxFloor == setting.unlockReqFloorPrestige && hero.totalGainOrbs == 0 && notifCanPrestige == true) { updateTab('hero'); $("#modalNotifPrestige").modal('show'); notifCanPrestige = false; } initDisplay(); }; var updateDailyTask = function(dailyTaskId, addCount=1){ let unlockDailyTask = hero.dailyTask.task.find(item => item.id === dailyTaskId); let dailyTaskData = dailyTask.find(item => item.id === dailyTaskId); if(unlockDailyTask && unlockDailyTask.count < dailyTaskData.required){ switch(dailyTaskId){ case 11: unlockDailyTask.count = unlockDailyTask.count + (addCount/60); break; default: unlockDailyTask.count = unlockDailyTask.count + addCount; break; } if(unlockDailyTask.count >= dailyTaskData.required){ unlockDailyTask.count = dailyTaskData.required; unlockDailyTask.complete = true; updateDailyTask(0); if(!hero.token) hero.token = 0; hero.token += dailyTaskData.prize; } } if(!$("#daily-task-div").hasClass("d-none")) showDailyTaskArea(); }; var runBackgroundCalculation = function(startRunning=false, callback){ if(startRunning){ if(document.hidden){ dpsTimeout = clearTimeout(dpsTimeout); if($("#background-process-div").hasClass("d-none")){ hideAllContent(); $("#background-process-div").removeClass("d-none"); } lastActiveScreen = activeScreen; activeScreen = false; } callback(); }else{ lastActiveScreen = activeScreen; activeScreen = true; if(!$("#background-process-div").hasClass("d-none")){ $("#background-process-div").addClass("d-none"); showLastContent(); } callback(); } }; var componentAction = function(componentId, action, actionValue, forceRun=false){ if(activeScreen || forceRun){ let arrayComponentId = componentId.split(','); for(let i=0; i<arrayComponentId.length; i++){ switch (action) { case 'addClass': $("#"+arrayComponentId[i]).addClass(actionValue); break; case 'removeClass': $("#"+arrayComponentId[i]).removeClass(actionValue); break; case 'updateClass': let arrayActionValue = actionValue.split(','); $("#"+arrayComponentId[i]).removeClass(arrayActionValue[0]).addClass(arrayActionValue[1]); break; case 'replaceText': if(!isNaN(actionValue) && actionValue != '') actionValue = numberFormat(actionValue); $("#"+arrayComponentId[i]).text(actionValue); break; case 'inputText': $("#"+arrayComponentId[i]).val(actionValue); break; case 'clearText': $("#"+arrayComponentId[i]).empty(); break; case 'clearArea': $("#"+arrayComponentId[i]).val(''); break; case 'animate': let barPercentage = new Decimal(actionValue).toPrecision(5); $("#"+arrayComponentId[i]).animate({width: barPercentage+"%"},1); break; } } } }; var calculateAllAchievement = function(){ for(let i=0;i<hero.achievement.length;i++){ let unlockAchievement = hero.achievement.find(item => item.id === i); switch(unlockAchievement.id){ case 0: unlockAchievement.balance = new Decimal(hero.highestDpc); break; case 1: unlockAchievement.balance = new Decimal(hero.highestDps); break; case 2: unlockAchievement.balance = new Decimal(hero.totalGainCoin).plus(hero.totalOfflineCoin); break; case 3: unlockAchievement.balance = new Decimal(hero.totalGainOrbs); break; case 4: unlockAchievement.balance = new Decimal(hero.totalCountPrestige); break; case 5: unlockAchievement.balance = new Decimal(hero.totalNormalEnemyKilled); break; case 6: unlockAchievement.balance = new Decimal(hero.totalBossEnemyKilled); break; case 7: let totalUsedSkill = new Decimal(0); for(let i=0;i<hero.totalSkillUsed.length;i++){ totalUsedSkill = totalUsedSkill.plus(new Decimal(hero.totalSkillUsed[i].count)); } unlockAchievement.balance = new Decimal(totalUsedSkill); break; case 8: unlockAchievement.balance = new Decimal(hero.countArtifact); break; case 9: let totalUpgradeLevel = new Decimal(0); for(let i=0;i<hero.unlockArtifact.length;i++){ totalUpgradeLevel = new Decimal(hero.unlockArtifact[i].level).plus(totalUpgradeLevel); } unlockAchievement.balance = new Decimal(totalUpgradeLevel); break; } } }; var calculateAllArtifactDamage = function(){ let artifactDamage = new Decimal(0); let artifactDpc = new Decimal(0); let artifactDps = new Decimal(0); let artifactCoin = new Decimal(0); let artifactBossCoin = new Decimal(0); let artifactOrbs = new Decimal(0); let artifactBossTimeLimit = new Decimal(0); let artifactOfflineTimeLimit = new Decimal(0); let artifactOfflineDps = new Decimal(0); let artifactOfflineCoin = new Decimal(0); let artifactIntervalDps = new Decimal(0); let artifactIntervalGrimReaper = new Decimal(0); let artifactEnemyHp = new Decimal(0); let artifactBossHp = new Decimal(0); let artifactHeroUpgradeFee = new Decimal(0); let artifactWeaponUpgradeFee = new Decimal(0); let artifactPartnerUpgradeFee = new Decimal(0); let artifactSkillUpgradeFee = new Decimal(0); let artifactChanceSkipFloor = new Decimal(0); let artifactAdventureExp = new Decimal(0); let artifactAdventureCoin = new Decimal(0); let artifactAdventureTime = new Decimal(0); let artifactDoubleAdventure = new Decimal(0); let artifactRerollFeePercentage = new Decimal(0); let artifactUnlockFeePercentage = new Decimal(0); let artifactUpgradeFeePercentage = new Decimal(0); let artifactMeleeDps = new Decimal(0); let artifactStealthDps = new Decimal(0); let artifactSwordDps = new Decimal(0); let artifactRangedDps = new Decimal(0); let artifactMagicDps = new Decimal(0); let artifactFirearmDps = new Decimal(0); let artifactRuneDps = new Decimal(0); let artifactAllDamage = new Decimal(0); let artifactAllCoin = new Decimal(0); let artifactAbilityPercentage = new Decimal(0); let artifactMeleeAbilityPercentage = new Decimal(0); let artifactStealthAbilityPercentage = new Decimal(0); let artifactSwordAbilityPercentage = new Decimal(0); let artifactRangedAbilityPercentage = new Decimal(0); let artifactMagicAbilityPercentage = new Decimal(0); let artifactFirearmAbilityPercentage = new Decimal(0); let artifactRuneAbilityPercentage = new Decimal(0); for(let i=0; i<hero.countArtifact; i++){ let unlockArtifact = hero.unlockArtifact[i]; let artifactData = artifact.find(item => item.id === unlockArtifact.id); let totalDamage = new Decimal(unlockArtifact.level * artifactData.baseDamage); artifactDamage = artifactDamage.plus(artifactData.tier * unlockArtifact.level * 5); unlockArtifact.damage = totalDamage; switch (unlockArtifact.id){ case 0: artifactCoin = artifactCoin.plus(totalDamage); break; case 1: artifactBossCoin = artifactBossCoin.plus(totalDamage); break; case 2: case 3: artifactDpc = artifactDpc.plus(totalDamage); break; case 4: artifactDps = artifactDps.plus(totalDamage); break; case 5: artifactOfflineCoin = artifactOfflineCoin.plus(totalDamage); break; case 6: artifactOfflineDps = artifactOfflineDps.plus(totalDamage); break; case 7: artifactDamage = artifactDamage.plus(totalDamage); break; case 8: artifactOrbs = artifactOrbs.plus(totalDamage); break; case 9: artifactOfflineTimeLimit = artifactOfflineTimeLimit.plus(totalDamage); break; case 10: artifactIntervalDps = artifactIntervalDps.plus(totalDamage); hero.bonusIntervalDps = artifactIntervalDps; startDpsInterval(true); break; case 11: artifactIntervalGrimReaper = artifactIntervalGrimReaper.plus(totalDamage); break; case 27: artifactBossTimeLimit = artifactBossTimeLimit.plus(totalDamage); break; case 28: artifactEnemyHp = artifactEnemyHp.plus(totalDamage); break; case 29: artifactBossHp = artifactBossHp.plus(totalDamage); break; case 30: artifactHeroUpgradeFee = artifactHeroUpgradeFee.plus(totalDamage); break; case 31: artifactWeaponUpgradeFee = artifactWeaponUpgradeFee.plus(totalDamage); break; case 32: artifactPartnerUpgradeFee = artifactPartnerUpgradeFee.plus(totalDamage); break; case 33: artifactSkillUpgradeFee = artifactSkillUpgradeFee.plus(totalDamage); break; case 34: artifactChanceSkipFloor = artifactChanceSkipFloor.plus(totalDamage); break; case 38: artifactAdventureExp = artifactAdventureExp.plus(totalDamage); break; case 39: artifactAdventureCoin = artifactAdventureCoin.plus(totalDamage); break; case 40: artifactAdventureTime = artifactAdventureTime.plus(totalDamage); break; case 41: artifactDoubleAdventure = artifactDoubleAdventure.plus(totalDamage); break; case 42: artifactRerollFeePercentage = artifactRerollFeePercentage.plus(totalDamage); break; case 43: artifactUnlockFeePercentage = artifactUnlockFeePercentage.plus(totalDamage); break; case 44: artifactUpgradeFeePercentage = artifactUpgradeFeePercentage.plus(totalDamage); break; case 45: artifactMeleeDps = artifactMeleeDps.plus(totalDamage); break; case 46: artifactStealthDps = artifactStealthDps.plus(totalDamage); break; case 47: artifactSwordDps = artifactSwordDps.plus(totalDamage); break; case 48: artifactRangedDps = artifactRangedDps.plus(totalDamage); break; case 49: artifactMagicDps = artifactMagicDps.plus(totalDamage); break; case 50: artifactFirearmDps = artifactFirearmDps.plus(totalDamage); break; case 51: artifactRuneDps = artifactRuneDps.plus(totalDamage); break; case 52: artifactAllDamage = artifactAllDamage.plus(totalDamage); break; case 53: artifactAllCoin = artifactAllCoin.plus(totalDamage); break; case 54: artifactAbilityPercentage = artifactAbilityPercentage.plus(totalDamage); break; case 55: artifactMeleeAbilityPercentage = artifactMeleeAbilityPercentage.plus(totalDamage); break; case 56: artifactStealthAbilityPercentage = artifactStealthAbilityPercentage.plus(totalDamage); break; case 57: artifactSwordAbilityPercentage = artifactSwordAbilityPercentage.plus(totalDamage); break; case 58: artifactRangedAbilityPercentage = artifactRangedAbilityPercentage.plus(totalDamage); break; case 59: artifactMagicAbilityPercentage = artifactMagicAbilityPercentage.plus(totalDamage); break; case 60: artifactFirearmAbilityPercentage = artifactFirearmAbilityPercentage.plus(totalDamage); break; case 61: artifactRuneAbilityPercentage = artifactRuneAbilityPercentage.plus(totalDamage); break; } } hero.artifactDamagePercentage = artifactDamage; hero.bonusDpcPercentage = artifactDpc; hero.bonusDpsPercentage = artifactDps; hero.bonusCoinPercentage = artifactCoin; hero.bonusBossCoinPercentage = artifactBossCoin; hero.bonusOrbsPercentage = artifactOrbs; hero.bonusBossTimeLimit = artifactBossTimeLimit; hero.bonusOfflineTimeLimit = artifactOfflineTimeLimit; hero.bonusOfflineDpsPercentage = artifactOfflineDps; hero.bonusOfflineCoinPercentage = artifactOfflineCoin; hero.bonusIntervalGrimReaper = artifactIntervalGrimReaper; hero.bonusEnemyHpPercentage = artifactEnemyHp; hero.bonusBossHpPercentage = artifactBossHp; hero.bonusHeroUpgradeFeePercentage = artifactHeroUpgradeFee; hero.bonusWeaponUpgradeFeePercentage = artifactWeaponUpgradeFee; hero.bonusPartnerUpgradeFeePercentage = artifactPartnerUpgradeFee; hero.bonusSkillUpgradeFeePercentage = artifactSkillUpgradeFee; hero.bonusChanceSkipFloorPercentage = artifactChanceSkipFloor; hero.bonusAdventureExpPercentage = artifactAdventureExp; hero.bonusAdventureCoinPercentage = artifactAdventureCoin; hero.bonusAdventureTimePercentage = artifactAdventureTime; hero.bonusDoubleAdventurePercentage = artifactDoubleAdventure; hero.bonusArtifactRerollFeePercentage = artifactRerollFeePercentage; hero.bonusArtifactUnlockFeePercentage = artifactUnlockFeePercentage; hero.bonusArtifactUpgradeFeePercentage = artifactUpgradeFeePercentage; hero.bonusMeleeDpsPercentage = artifactMeleeDps; hero.bonusStealthDpsPercentage = artifactStealthDps; hero.bonusSwordDpsPercentage = artifactSwordDps; hero.bonusRangedDpsPercentage = artifactRangedDps; hero.bonusMagicDpsPercentage = artifactMagicDps; hero.bonusFirearmDpsPercentage = artifactFirearmDps; hero.bonusRuneDpsPercentage = artifactRuneDps; hero.bonusAllDamagePercentage = artifactAllDamage; hero.bonusAllCoinPercentage = artifactAllCoin; hero.bonusAbilityPercentage = artifactAbilityPercentage; hero.bonusMeleeAbilityPercentage = artifactMeleeAbilityPercentage; hero.bonusStealthAbilityPercentage = artifactStealthAbilityPercentage; hero.bonusSwordAbilityPercentage = artifactSwordAbilityPercentage; hero.bonusRangedAbilityPercentage = artifactRangedAbilityPercentage; hero.bonusMagicAbilityPercentage = artifactMagicAbilityPercentage; hero.bonusFirearmAbilityPercentage = artifactFirearmAbilityPercentage; hero.bonusRuneAbilityPercentage = artifactRuneAbilityPercentage; calcTotalDpc(); calcTotalDps(); calcTotalRewardCoin(); calcTotalOrbs(); }; var calculateAllActiveGods = function(){ let chanceStealCoinPercentage = 0; let chanceConvertDpcToCoinPercentage = 0; let chanceConvertDpsToCoinPercentage = 0; let chanceExtraCoinPercentage = 0; let chanceAddOrbsPrestigePercentage = 0; let chanceAddOrbsFloorPercentage = 0; let chanceCarriedCoinPercentage = 0; let chanceUpgradeDiscountPercentage = 0; let bonusGodsDpcPercentage = 0; let bonusGodsDpsPercentage = 0; let chanceHitHighestDpcPercentage = 0; let chanceHitHighestDpsPercentage = 0; let chanceHitCurrentSlashPercentage = 0; let chanceHitCurrentDpcPercentage = 0; let chanceHitCurrentDpsPercentage = 0; let tempStealCoinTimer = new Decimal(0); let tempDpcToCoinTimer = new Decimal(0); let tempDpsToCoinTimer = new Decimal(0); let runDpsInterval = false; for(let i=0;i<hero.unlockGods.length;i++){ let unlockGods = hero.unlockGods[i]; let godsData = gods.find(item => item.id === unlockGods.id); if(unlockGods.isActive){ switch(unlockGods.id){ case 0: chanceStealCoinPercentage = unlockGods.damage; if(chanceStealCoinPercentage > 0) tempStealCoinTimer = new Decimal(1000).mul(godsData.buffTimer); else tempStealCoinTimer = new Decimal(0); break; case 1: chanceConvertDpcToCoinPercentage = unlockGods.damage; if(chanceConvertDpcToCoinPercentage > 0)tempDpcToCoinTimer = new Decimal(1000).mul(godsData.buffTimer); else tempDpcToCoinTimer = new Decimal(0); break; case 2: chanceConvertDpsToCoinPercentage = unlockGods.damage; if(chanceConvertDpsToCoinPercentage > 0)tempDpsToCoinTimer = new Decimal(1000).mul(godsData.buffTimer); else tempDpsToCoinTimer = new Decimal(0); break; case 3: chanceExtraCoinPercentage = unlockGods.damage; break; case 4: chanceAddOrbsPrestigePercentage = unlockGods.damage; break; case 5: chanceAddOrbsFloorPercentage = unlockGods.damage; break; case 6: chanceCarriedCoinPercentage = unlockGods.damage; break; case 7: chanceUpgradeDiscountPercentage = unlockGods.damage; break; case 8: bonusGodsDpcPercentage = unlockGods.damage; break; case 9: bonusGodsDpsPercentage = unlockGods.damage; break; case 10: chanceHitHighestDpcPercentage = unlockGods.damage; break; case 11: chanceHitHighestDpsPercentage = unlockGods.damage; break; case 12: chanceHitCurrentSlashPercentage = unlockGods.damage; break; case 13: chanceHitCurrentDpcPercentage = unlockGods.damage; break; case 14: chanceHitCurrentDpsPercentage = unlockGods.damage; break; }; } } hero.bonusChanceStealCoinPercentage = chanceStealCoinPercentage; hero.bonusChanceDpcToCoinPercentage = chanceConvertDpcToCoinPercentage; hero.bonusChanceDpsToCoinPercentage = chanceConvertDpsToCoinPercentage; hero.bonusChanceExtraCoinPercentage = chanceExtraCoinPercentage; hero.bonusChanceAddOrbsPrestigePercentage = chanceAddOrbsPrestigePercentage; hero.bonusChanceAddOrbsFloorPercentage = chanceAddOrbsFloorPercentage; hero.bonusChanceCarriedCoinPercentage = chanceCarriedCoinPercentage; hero.bonusChanceUpgradeDiscountPercentage = chanceUpgradeDiscountPercentage; hero.bonusGodsDpcPercentage = bonusGodsDpcPercentage; hero.bonusGodsDpsPercentage = bonusGodsDpsPercentage; hero.bonusChanceHitHighestDpcPercentage = chanceHitHighestDpcPercentage; hero.bonusChanceHitHighestDpsPercentage = chanceHitHighestDpsPercentage; hero.bonusChanceHitCurrentSlashPercentage = chanceHitCurrentSlashPercentage; hero.bonusChanceHitCurrentDpcPercentage = chanceHitCurrentDpcPercentage; hero.bonusChanceHitCurrentDpsPercentage = chanceHitCurrentDpsPercentage; if(stealCoinTimer.equals(tempStealCoinTimer) == false){ runDpsInterval = true; stealCoinTimer = tempStealCoinTimer; } if(dpcToCoinTimer.equals(tempDpcToCoinTimer) == false){ runDpsInterval = true; dpcToCoinTimer = tempDpcToCoinTimer; } if(dpsToCoinTimer.equals(tempDpsToCoinTimer) == false){ runDpsInterval = true; dpsToCoinTimer = tempDpsToCoinTimer; } if(runDpsInterval)startDpsInterval(true); if(hero.bonusGodsDpcPercentage > 0){ calcTotalDpc(); updateHeroDpc(); } if(hero.bonusGodsDpsPercentage > 0){ calcTotalDps(); updateHeroDps(); } }; var calculateAllPartnerAbility = function(){ for(let i=0;i<hero.highestUnlockPartner.length;i++){ let highestUnlockPartner = hero.highestUnlockPartner[i]; let partnerId = highestUnlockPartner.id; let activeAbility = -1; for(let a=0;a<highestUnlockPartner.ability.length;a++){ let unlockAbilityPartner = highestUnlockPartner.ability[a]; unlockAbilityPartner.tempAbilityPoint = unlockAbilityPartner.abilityPoint; unlockAbilityPartner.tempAccuracy = unlockAbilityPartner.accuracy; unlockAbilityPartner.tempDamage = unlockAbilityPartner.damage; if(unlockAbilityPartner.isActive) activeAbility = unlockAbilityPartner.abilityId; } let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); if(unlockPartner){ unlockPartner.abilityId = activeAbility; unlockPartner.abilityCounter = 0; } } }; var updateUserName = function () { if(hero.userName != "") componentAction ("view-username", "replaceText", hero.userName); }; var updateHeroCoin = function() { let heroCoin = new Decimal(hero.coin); componentAction ("hero-coin", "replaceText", numberFormat(heroCoin)); }; var updateHeroDpc = function() { componentAction ("hero-dpc", "replaceText", calcTotalDpc()); componentAction ("current-hero-dpc", "replaceText", hero.dpc); componentAction ("next-hero-dpc", "replaceText", calcNextHeroDpc()); }; var updateHeroDps = function() { componentAction ("hero-dps", "replaceText", numberFormat(calcTotalDps())); }; var updateHeroOrbs = function() { componentAction ("hero-orbs", "replaceText", hero.orbs); }; var updateHeroLevel = function() { componentAction ("hero-level", "replaceText", hero.heroLevel); }; var updateWeaponLevel = function() { componentAction ("weapon-level", "replaceText", hero.weaponLevel); }; var updateWeaponDpc = function() { if(hero.weaponLevel > 0){ componentAction ("upgrade-weapon-text", "replaceText", "Level Up x"); if(setting.levelUpgradeMultiplier > 0) componentAction ("level-weapon-upgrade-multiplier", "replaceText", setting.levelUpgradeMultiplier); else if(setting.levelUpgradeMultiplier == 0) componentAction ("level-weapon-upgrade-multiplier", "replaceText", maxWeaponLevelBuy); } componentAction ("current-weapon-dpc", "replaceText", hero.weaponDpc); componentAction ("next-weapon-dpc", "replaceText", calcNextWeaponDpc()); }; var updatePartner = function() { for(let i=0; i<hero.countPartner; i++){ let unlockPartner = hero.unlockPartner.find(item => item.id === i); if(unlockPartner){ if(unlockPartner.status == "Battling") componentAction("partner-area-"+i,"removeClass","d-none"); else componentAction("partner-area-"+i,"addClass","d-none"); if(unlockPartner.level > 0){ componentAction ("upgrade-partner-text-"+i, "replaceText", "Level Up x"); if(setting.levelUpgradeMultiplier > 0)componentAction ("level-partner-upgrade-multiplier-"+i, "replaceText", setting.levelUpgradeMultiplier); else if(setting.levelUpgradeMultiplier == 0){ let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === i); if(localMaxPartnerLevelBuy) componentAction ("level-partner-upgrade-multiplier-"+i, "replaceText", localMaxPartnerLevelBuy.maxLevelBuy); } componentAction ("partner-level-"+i, "replaceText", unlockPartner.level); componentAction ("current-partner-dps-"+i, "replaceText", calcTotalPartnerDps(i,"current")); } } componentAction ("next-partner-dps-"+i, "replaceText", calcTotalPartnerDps(i,"next")); } }; var updateSkill = function () { for(let i=0; i<hero.countSkill; i++){ let unlockSkill = hero.unlockSkill.find(item => item.id === i); if(unlockSkill && unlockSkill.level > 0){ if(unlockSkill.level > 0){ let totalDamage = new Decimal(unlockSkill.damage).plus(artifactSkillDamage(i)); componentAction ("upgrade-skill-text-"+i, "replaceText", "Level Up x"); $("#skill-image-"+i).attr("src", "assets/images/levelup.svg"); let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === i); componentAction ("level-skill-upgrade-multiplier-"+i, "replaceText", localMaxSkillLevelBuy.maxLevelBuy); componentAction ("skill-level-"+i, "replaceText", unlockSkill.level); componentAction ("current-skill-damage-"+i, "replaceText", numberFormat(totalDamage)); } if(unlockSkill.level < 10) componentAction ("next-skill-damage-"+i, "replaceText", "(+"+(calcNextSkillDamage(i)-unlockSkill.damage)+")"); else componentAction ("next-skill-damage-"+i, "clearText", ""); } } }; var formulaUpgradeHeroFee = function(heroLevel){ let upgradeFee = new Decimal(setting.heroUpgradeCoinMultiplier).pow(heroLevel).mul(setting.baseHeroUpgradeCoin); let heroUpgradeFeePercentage = new Decimal(100).sub(hero.bonusHeroUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(heroUpgradeFeePercentage); return upgradeFee; }; var updateUpgradeLevelFeeHero = function() { let totalUpgradeFee = new Decimal(0); let heroCoin = new Decimal(hero.coin); let nextTotalUpgradeFee = new Decimal(0); maxHeroLevelBuy = 0; if(setting.levelUpgradeMultiplier > 0){ for(let a=0; a<setting.levelUpgradeMultiplier; a++) totalUpgradeFee = totalUpgradeFee.plus(formulaUpgradeHeroFee(hero.heroLevel + a - 1)); }else if(setting.levelUpgradeMultiplier == 0){ let a = 0; do{ nextTotalUpgradeFee = totalUpgradeFee.plus(formulaUpgradeHeroFee(hero.heroLevel + a - 1)); if(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)){ totalUpgradeFee = nextTotalUpgradeFee; a++; } }while(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)); maxHeroLevelBuy = a; } componentAction ("upgrade-level-fee", "replaceText", numberFormat(totalUpgradeFee.ceil())); return totalUpgradeFee.ceil(); }; var updateUpgradeLevelFeeWeapon = function() { let totalUpgradeFee = new Decimal(0); let loopNextLevel = 0; let nextTotalUpgradeFee = new Decimal(0); let heroCoin = new Decimal(hero.coin); if(hero.weaponLevel == 0) loopNextLevel = 1; else loopNextLevel = setting.levelUpgradeMultiplier; if(loopNextLevel > 0){ for(let a=0; a<loopNextLevel; a++){ let upgradeFee = new Decimal(setting.weaponUpgradeCoinMultiplier).pow(hero.weaponLevel + a).mul(setting.baseWeaponUpgradeCoin); let weaponUpgradeFeePercentage = new Decimal(100).sub(hero.bonusWeaponUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(weaponUpgradeFeePercentage); totalUpgradeFee = totalUpgradeFee.plus(upgradeFee); } }else if(setting.levelUpgradeMultiplier == 0){ let b = 0; do{ let upgradeFee = new Decimal(setting.weaponUpgradeCoinMultiplier).pow(hero.weaponLevel + b).mul(setting.baseWeaponUpgradeCoin); let weaponUpgradeFeePercentage = new Decimal(100).sub(hero.bonusWeaponUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(weaponUpgradeFeePercentage); nextTotalUpgradeFee = totalUpgradeFee.plus(upgradeFee); if(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)){ totalUpgradeFee = nextTotalUpgradeFee; b++; } }while(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)); maxWeaponLevelBuy = b; } componentAction ("upgrade-weapon-fee", "replaceText", numberFormat(totalUpgradeFee.ceil())); return totalUpgradeFee.ceil(); }; var updateUpgradeLevelFeeAllPartner = function() { for(let i=0; i<hero.countPartner; i++){ updateUpgradeLevelFeePartner(i); } }; var formulaUpgradePartnerFee = function(partnerLevel, basePrice){ let upgradeFee = new Decimal(setting.partnerUpgradeCoinMultiplier).pow(partnerLevel).mul(basePrice); let partnerUpgradeFeePercentage = new Decimal(100).sub(hero.bonusPartnerUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(partnerUpgradeFeePercentage); return upgradeFee; }; var updateUpgradeLevelFeePartner = function(partnerId) { if(partnerId >= 0){ let totalUpgradeFee = new Decimal(0); let loopNextLevel = 0; let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); let partnerLevel = 0; let nextTotalUpgradeFee = new Decimal(0); let heroCoin = new Decimal(hero.coin); if(unlockPartner && unlockPartner.level > 0) { loopNextLevel = setting.levelUpgradeMultiplier; partnerLevel = unlockPartner.level }else loopNextLevel = 1; if(loopNextLevel > 0){ for(let a=0; a<loopNextLevel; a++){ let upgradeFee = new Decimal(formulaUpgradePartnerFee(partnerLevel+a, partnerData.basePrice)); totalUpgradeFee = totalUpgradeFee.plus(upgradeFee); } }else{ if(setting.levelUpgradeMultiplier == 0){ let c=0; do{ let upgradeFee = new Decimal(formulaUpgradePartnerFee(partnerLevel+c, partnerData.basePrice)); nextTotalUpgradeFee = totalUpgradeFee.plus(upgradeFee); if(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)){ totalUpgradeFee = nextTotalUpgradeFee; c++; } }while(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin)); let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === partnerId); if(localMaxPartnerLevelBuy) localMaxPartnerLevelBuy.maxLevelBuy = c; } } componentAction ("upgrade-partner-fee-"+partnerId, "replaceText", numberFormat(totalUpgradeFee.ceil())); return totalUpgradeFee.ceil(); } }; var updateUpgradeLevelFeeAllSkill = function() { for(let i=0; i<hero.countSkill; i++){ updateUpgradeLevelFeeSkill(i); } }; var updateUpgradeLevelFeeSkill = function(skillId){ if(skillId >= 0){ let totalUpgradeFee = new Decimal(0); let loopNextLevel = 0; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let skillData = skill.find(item => item.id === skillId); let skillLevel = 0; let nextTotalUpgradeFee = new Decimal(0); let heroCoin = new Decimal(hero.coin); if (unlockSkill) { loopNextLevel = setting.levelUpgradeMultiplier; skillLevel = unlockSkill.level; componentAction ("skill-use-div-"+skillId, "removeClass", "d-none"); if(!unlockSkill.isCooldown){ $("#use-skill-button-"+skillId).prop('disabled', false); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-disabled,skill-active"); } }else{ loopNextLevel = 1; } if(skillLevel==skillData.maxLevel){ $("#upgrade-skill-button-"+skillId).remove(); }else{ if(loopNextLevel > 0){ if((skillLevel+loopNextLevel) > skillData.maxLevel) loopNextLevel = skillData.maxLevel - skillLevel; for(let a=0; a<loopNextLevel; a++){ let upgradeFee = new Decimal(setting.skillUpgradeCoinMultiplier).pow(skillLevel + a).mul(skillData.basePrice); let skillUpgradeFeePercentage = new Decimal(100).sub(hero.bonusSkillUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(skillUpgradeFeePercentage); totalUpgradeFee = totalUpgradeFee.plus(upgradeFee); } }else if(loopNextLevel == 0){ let d=0; do{ let upgradeFee = new Decimal(setting.skillUpgradeCoinMultiplier).pow(skillLevel + d).mul(skillData.basePrice); let skillUpgradeFeePercentage = new Decimal(100).sub(hero.bonusSkillUpgradeFeePercentage).div(100); upgradeFee = upgradeFee.mul(skillUpgradeFeePercentage); nextTotalUpgradeFee = totalUpgradeFee.plus(upgradeFee); if(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin) && (skillLevel+d) < skillData.maxLevel){ totalUpgradeFee = nextTotalUpgradeFee; d++; } }while(nextTotalUpgradeFee.lessThanOrEqualTo(heroCoin) && (skillLevel+d) < skillData.maxLevel); loopNextLevel = d; } let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === skillId); localMaxSkillLevelBuy.maxLevelBuy = loopNextLevel; componentAction ("upgrade-skill-fee-"+skillId, "replaceText", numberFormat(totalUpgradeFee.ceil())); } return totalUpgradeFee.ceil(); } }; var clearBodyArea = function() { setting.heroAreaShow = 0; setting.partnerAreaShow = 0; setting.skillAreaShow = 0; setting.shopAreaShow = 0; }; var showGameVersion = function(){ componentAction ("version", "replaceText", "["+setting.gameVersion+"]"); $("#current-year").text(new Date().getFullYear()); }; var showAutoProgress = function(){ if(hero.autoProgressShow == 1) componentAction ("auto-progress-div", "removeClass", "d-none"); $("#auto-progress-switch").prop("checked", setting.autoProgress); }; var showFloorNumber = function() { switch (hero.floor){ case 1: componentAction ("floor-number-text-1", "updateClass", "tab-button-unactive,d-none"); componentAction ("floor-number-text-2", "updateClass", "tab-button-unactive,d-none"); componentAction ("floor-number-text-1", "clearText", ""); componentAction ("floor-number-text-2", "clearText", ""); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "replaceText", hero.floor+1); componentAction ("floor-number-text-5", "replaceText", hero.floor+2); break; case 2: componentAction ("floor-number-text-1", "updateClass", "tab-button-unactive,d-none"); componentAction ("floor-number-text-2", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-1", "clearText", ""); componentAction ("floor-number-text-2", "replaceText", (hero.floor-1)); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "replaceText", hero.floor+1); componentAction ("floor-number-text-5", "replaceText", hero.floor+2); break; case (setting.limitFloor-1): componentAction ("floor-number-text-1", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-2", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-4", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-5", "updateClass", "tab-button-unactive,d-none"); componentAction ("floor-number-text-1", "replaceText", (hero.floor-2)); componentAction ("floor-number-text-2", "replaceText", (hero.floor-1)); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "replaceText", hero.floor+1); componentAction ("floor-number-text-5", "clearText", ""); break; case setting.limitFloor: componentAction ("floor-number-text-1", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-2", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-4", "updateClass", "tab-button-unactive,d-none"); componentAction ("floor-number-text-5", "updateClass", "tab-button-unactive,d-none"); componentAction ("floor-number-text-1", "replaceText", (hero.floor-2)); componentAction ("floor-number-text-2", "replaceText", (hero.floor-1)); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "clearText", ""); componentAction ("floor-number-text-5", "clearText", ""); break; default: componentAction ("floor-number-text-1", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-2", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-4", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-5", "updateClass", "d-none,tab-button-unactive"); componentAction ("floor-number-text-1", "replaceText", (hero.floor-2)); componentAction ("floor-number-text-2", "replaceText", (hero.floor-1)); componentAction ("floor-number-text-3", "replaceText", hero.floor); componentAction ("floor-number-text-4", "replaceText", hero.floor+1); componentAction ("floor-number-text-5", "replaceText", hero.floor+2); break; } }; var showBuyArea = function(){ componentAction ("button-buy-multiplier-1", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("button-buy-multiplier-10", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("button-buy-multiplier-100", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("button-buy-multiplier-0", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("button-buy-multiplier-"+setting.levelUpgradeMultiplier, "updateClass", "tab-button-unactive,tab-button-active"); }; var showDungeonArea = function(){ lastActiveMenu = 'dungeon'; hideAllContent(); initDisplay(); componentAction ("dungeon-div", "removeClass", "d-none"); componentAction ("dungeon", "updateClass", "cursor-button,active"); if(!hero.lastPrestigeShow){ let textOrbs = "Orb"; if(hero.lastPrestigeOrbs > 1) textOrbs = "Orbs"; componentAction ("prestige-text", "replaceText", numberFormat(hero.lastPrestigeOrbs)+" "+textOrbs); $("#modalPrestigeForm").modal('show'); hero.lastPrestigeShow = true; } }; var showOrbsArea = function(){ let heroOrbs = new Decimal(hero.orbs); if(heroOrbs.greaterThan(0) || hero.unlockArtifact.length > 0){ componentAction("hero-orbs-div", "removeClass", "d-none"); componentAction ("hero-orbs-title", "replaceText", "Orbs : "); updateHeroOrbs(); } }; var showBodyArea = function(){ if(setting.heroAreaShow == 1 || hero.coin >= setting.unlockRequirementCoinForHero || hero.heroLevel > 1){ setting.heroAreaShow = 1; componentAction ("body-area-div", "removeClass", "d-none"); componentAction ("hero-user-name", "replaceText", hero.userName); updateHeroLevel(); if(setting.levelUpgradeMultiplier > 0) componentAction ("level-hero-upgrade-multiplier", "replaceText", setting.levelUpgradeMultiplier); else if(setting.levelUpgradeMultiplier == 0) componentAction ("level-hero-upgrade-multiplier", "replaceText", maxHeroLevelBuy); componentAction ("unlock-weapon-requirement", "replaceText", setting.unlockRequirementLevelForWeapon); } componentAction ("unlock-partner-requirement", "replaceText", partner[0].unlockReq); }; var showWeaponArea = function(){ if(hero.weaponAreaShow == 1 || hero.heroLevel >= setting.unlockRequirementLevelForWeapon){ componentAction ("weapon-unlock-div", "removeClass", "d-none"); componentAction ("weapon-area-div", "removeClass", "d-none"); componentAction ("weapon-unlock-div", "addClass", "d-none"); hero.weaponAreaShow = 1; } }; var showPartnerArea = function(){ let openNewPartner = 0; let countPartner = 0; let partnerData; let prevPartnerName = ''; if($("#partner-unlock-div").length) $("#partner-unlock-div").remove(); for(let i = 0; i<partner.length; i++){ let currentUnlockPartner = hero.unlockPartner.find(item => item.id === partner[i].id); let currentLevel = 0; let partnerLevel = 0; let partnerDPS = 0; let nextPartnerDPS = 0; let upgradeFee = 0; let upgradeText = ''; let upgradeMultiplier = ''; let skillImageClass = ''; let partnerSkillImage = ''; let partnerClass = ''; let nextUnlockPartnerData = []; if(!currentUnlockPartner || (currentUnlockPartner && currentUnlockPartner.status == "Battling")){ if(i == 0){ currentLevel = hero.heroLevel; prevPartnerName = 'Hero'; nextUnlockPartnerData = { unlockReq: partner[i].unlockReq, prevPartnerName: 'Hero', }; }else{ let prevPartnerId = i - 1; let unlockPartner = hero.unlockPartner.find(item => item.id === prevPartnerId); if(unlockPartner) currentLevel = unlockPartner.level; nextUnlockPartnerData = { unlockReq: partner[i].unlockReq, prevPartnerName: partner[prevPartnerId].name, }; } }else{ if(i == 0){ nextUnlockPartnerData = checkNextUnlockPartner(i); currentLevel = hero.heroLevel; i = nextUnlockPartnerData.nextPartnerId; }else{ nextUnlockPartnerData = checkNextUnlockPartner(i); let prevPartnerId = i - 1; let unlockPartner = hero.unlockPartner.find(item => item.id === prevPartnerId); if(unlockPartner)currentLevel = unlockPartner.level; prevPartnerName = nextUnlockPartnerData.prevPartnerName; i = nextUnlockPartnerData.nextPartnerId; } } if(currentLevel >= nextUnlockPartnerData.unlockReq){ let searchPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === i); if(!searchPartnerLevelBuy){ let newObjMaxPartnerLevelBuy = { id: i, maxLevelBuy: 0 }; maxPartnerLevelBuy.push(newObjMaxPartnerLevelBuy); } if( !$( "#partner-area-" + i ).length){ partnerData = partner.find(item => item.id === i); let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === i); let abilityUnlockPartner; if(highestUnlockPartner) abilityUnlockPartner = highestUnlockPartner.ability.find(item => item.isActive === true); let unlockPartner = hero.unlockPartner.find(item => item.id === i); if(unlockPartner && unlockPartner.level > 0){ partnerLevel = unlockPartner.level; upgradeFee = updateUpgradeLevelFeePartner(i); upgradeText = 'Level Up x'; upgradeMultiplier = setting.levelUpgradeMultiplier; }else{ upgradeFee = partnerData.basePrice; upgradeText = 'Unlock'; } partnerDPS = calcTotalPartnerDps(i,"current"); nextPartnerDPS = calcTotalPartnerDps(i,"next"); if(unlockPartner && unlockPartner.status != "Battling") partnerClass = 'd-none'; openNewPartner = 1; if(abilityUnlockPartner){ let partnerAbilityData = partnerAbility.find(item => item.id === abilityUnlockPartner.abilityId); let abilityTypeData = abilityType.find(item => item.id === partnerAbilityData.abilityTypeId); partnerSkillImage = 'assets/images/'+abilityTypeData.name.charAt(0).toLowerCase()+'.svg'; skillImageClass = ''; }else{ skillImageClass = 'd-none'; partnerSkillImage = ''; } let appendPartnerDiv = '<div id="partner-area-' + i + '" class="row border-top rounded-card '+partnerClass+'">'; appendPartnerDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-6 col-6 v-center-flex">'; appendPartnerDiv += '<img src="assets/images/' + partnerData.type.toLowerCase() + '.svg" class="image-size-static"></img>&nbsp;'; appendPartnerDiv += partnerData.name + '&nbsp;Lv&nbsp;<span id="partner-level-' + i + '">' + partnerLevel + '</span>&nbsp;'; appendPartnerDiv += '<img id="partner-skill-image-'+i+'" src="' + partnerSkillImage + '" class="image-size-static ' + skillImageClass + '"></img>&nbsp;'; appendPartnerDiv += '</div>'; appendPartnerDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-6 col-6 v-center-flex">'; appendPartnerDiv += 'DPS&nbsp;:&nbsp;<span id="current-partner-dps-' + i + '">' + partnerDPS + '</span>&nbsp;(+<span id="next-partner-dps-' + i + '">' + nextPartnerDPS + '</span>)'; appendPartnerDiv += '</div>'; appendPartnerDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendPartnerDiv += '<button id="upgrade-partner-button-' + i + '" class="upgrade-level-button v-flex-grid" value="' + i + '"><img src="assets/images/levelup.svg" class="image-size-2">&nbsp;<span id="upgrade-partner-text-' + i + '">' + upgradeText + '</span><span id="level-partner-upgrade-multiplier-' + i + '">' + upgradeMultiplier + '</span> - <span id="upgrade-partner-fee-' + i + '">' + numberFormat(upgradeFee) + '</span> Coin</button>'; appendPartnerDiv += '</div>'; appendPartnerDiv += '</div>'; if(hero.settingOrderPartner == "asc"){ $("#partner-area-div").append(appendPartnerDiv).off('click','#upgrade-partner-button-'+i).on('click','#upgrade-partner-button-'+i,function(){ upgradeLevelPartner(this); }); }else{ $("#partner-area-div").prepend(appendPartnerDiv).off('click','#upgrade-partner-button-'+i).on('click','#upgrade-partner-button-'+i,function(){ upgradeLevelPartner(this); }); } }else{ let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === i); let abilityUnlockPartner; if(highestUnlockPartner) abilityUnlockPartner = highestUnlockPartner.ability.find(item => item.isActive === true); if(abilityUnlockPartner){ let partnerAbilityData = partnerAbility.find(item => item.id === abilityUnlockPartner.abilityId); let abilityTypeData = abilityType.find(item => item.id === partnerAbilityData.abilityTypeId); partnerSkillImage = 'assets/images/'+abilityTypeData.name.charAt(0).toLowerCase()+'.svg'; $("#partner-skill-image-"+i).attr("src", partnerSkillImage); componentAction("partner-skill-image-"+i,"removeClass","d-none"); }else componentAction("partner-skill-image-"+i,"addClass","d-none"); } }else{ let appendPartnerDiv = '<div id="partner-unlock-div" class="rounded-card middle-align unlock-info">Unlock Partner at ' + nextUnlockPartnerData.prevPartnerName + ' level ' + nextUnlockPartnerData.unlockReq + '</div>'; if(hero.settingOrderPartner == "asc")$("#partner-area-div").append(appendPartnerDiv); else $("#partner-area-div").prepend(appendPartnerDiv); i = partner.length; } } if(openNewPartner == 1 && hero.totalGainOrbs == 0) updateTab("partner"); if(setting.partnerAreaShow == 1){ componentAction ("partner-area-div", "removeClass", "d-none"); setting.partnerAreaShow = 1; } }; var showSkillArea = function(){ let openNewSkill = 0; let countSkill = 0; let skillData; if(hero.unlockSkill.length > 1 && !$( "#start-all-skill").length){ let appendStartAllDiv = '<div id="start-all-skill" class="row border-top rounded-card p-0 border-0">'; appendStartAllDiv += '<button id="start-all-skill-button" class="upgrade-level-button skill-active">Start All Skill</button>'; appendStartAllDiv += '</div>'; $("#skill-area-div").prepend(appendStartAllDiv).on('click','#start-all-skill-button',function(){ startAllSkill(); }); } for(let i=0; i<skill.length; i++){ let skillLevel = 0; let skillDamage = 0; let nextSkillDamage = 0; let upgradeFee = 0; let upgradeText = ''; let skillImage = ''; let upgradeMultiplier = ''; let styleDivBtnUseSkill = 'd-none'; let styleBtnUseSkill = 'skill-disabled'; let propBtnUseSkill = 'disabled'; let textBtnUseSkill = 'Use Skill - Ready To Use'; let unlockReqFloor = hero.maxFloor; if($("#skill-unlock-div").length) $("#skill-unlock-div").remove(); if(unlockReqFloor >= skill[i].unlockReqFloor){ countSkill++; let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === i); if(!localMaxSkillLevelBuy){ let newObjMaxSkillLevelBuy = { id: i, maxLevelBuy: 0 }; maxSkillLevelBuy.push(newObjMaxSkillLevelBuy); } if( !$( "#skill-area-" + i ).length){ skillData = skill.find(item => item.id === i); let unlockSkillData = hero.unlockSkill.find(item => item.id === i); if(unlockSkillData){ let damageSkill = new Decimal(unlockSkillData.damage).plus(artifactSkillDamage(i)); let durationSkill = new Decimal(unlockSkillData.duration).plus(artifactSkillDuration(i)); let cooldownSkill = new Decimal(unlockSkillData.cooldown).sub(artifactSkillCooldown(i)); propBtnUseSkill = ''; styleDivBtnUseSkill = ''; styleBtnUseSkill = 'skill-active'; if(unlockSkillData.isActive){ let pastDurationSkill = new Decimal(Math.floor((Date.now() - unlockSkillData.lastStartDatetime) / 1000)); let restDurationSkill = new Decimal(durationSkill).sub(pastDurationSkill); if(pastDurationSkill.lessThan(durationSkill)){ styleBtnUseSkill = 'skill-running'; propBtnUseSkill = ''; textBtnUseSkill = "Click to Stop - "+offlineTimeText(restDurationSkill); }else{ unlockSkillData.isCooldown = true; unlockSkillData.lastCooldownDatetime = new Decimal(1000).mul(durationSkill).plus(unlockSkillData.lastStartDatetime); unlockSkillData.isActive = false; unlockSkillData.lastStartDatetime = 0; } } if(unlockSkillData.isCooldown){ let pastCooldownSkill = new Decimal(Math.floor((Date.now() - unlockSkillData.lastCooldownDatetime) / 1000)); let restCooldownSkill = new Decimal(cooldownSkill).sub(pastCooldownSkill); if(pastCooldownSkill.lessThan(cooldownSkill)){ propBtnUseSkill = 'disabled'; styleBtnUseSkill = 'skill-disabled'; textBtnUseSkill = "Cooldown Timer - "+offlineTimeText(restCooldownSkill); startCooldownSkill(i); }else{ unlockSkillData.isCooldown = false; unlockSkillData.lastCooldownDatetime = 0; } } skillDamage = damageSkill; skillLevel = unlockSkillData.level; nextSkillDamage = calcNextSkillDamage(i)-unlockSkillData.damage; upgradeFee = updateUpgradeLevelFeeSkill(i); upgradeText = 'Level Up x'; skillImage = 'levelup'; upgradeMultiplier = setting.levelUpgradeMultiplier; }else{ nextSkillDamage = skillData.baseDamage; upgradeFee = skillData.basePrice; upgradeText = 'Unlock'; skillImage = 'unlock'; } openNewSkill = 1; let appendSkillDiv = '<div id="skill-area-' + i + '" class="row border-top rounded-card">'; appendSkillDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-6 col-6">'; appendSkillDiv += skillData.name + ' Lv <span id="skill-level-' + i + '">' + skillLevel + '</span>'; appendSkillDiv += '</div>'; appendSkillDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-6 col-6">'; appendSkillDiv += '<span id="current-skill-damage-' + i + '">' + numberFormat(skillDamage) + '</span> <span id="next-skill-damage-' + i + '">'; if(skillLevel < skillData.maxLevel) appendSkillDiv += '(+' + nextSkillDamage + ')'; appendSkillDiv += '</span> <span id ="skill-desc-' + i + '">' + skillData.description + '</span>'; appendSkillDiv += '</div>'; appendSkillDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; if(skillLevel < skillData.maxLevel)appendSkillDiv += '<button id="upgrade-skill-button-' + i + '" class="upgrade-level-button" value="' + i + '"><img id="skill-image-'+i+'" src="assets/images/' + skillImage + '.svg" class="image-size-2"></img>&nbsp;<span id="upgrade-skill-text-' + i + '">' + upgradeText + '</span><span id="level-skill-upgrade-multiplier-' + i + '">' + upgradeMultiplier + '</span> - <span id="upgrade-skill-fee-' + i + '">' + numberFormat(upgradeFee) + '</span> Coin</button>'; appendSkillDiv += '</div>'; appendSkillDiv += '</div>'; $("#skill-area-div").append(appendSkillDiv).on('click','#upgrade-skill-button-'+i,function(){ upgradeLevelSkill(this); }); appendSkillDiv = '<div id="skill-use-div-' + i + '" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 mt-2 ' + styleDivBtnUseSkill + '">'; appendSkillDiv += '<button id="use-skill-button-' + i + '" class="use-skill-button ' + styleBtnUseSkill + '" value="' + i + '" ' + propBtnUseSkill + '><span id ="skill-timer-desc-' + i + '">' + textBtnUseSkill + '</span></button>'; appendSkillDiv += '</div>'; $("#skill-area-"+i).append(appendSkillDiv).on('click','#use-skill-button-'+i,function(){ useSkill(i); }); if(unlockSkillData && unlockSkillData.isActive)useSkill(i); } }else{ if(i+1 < skill.length){ let appendSkillDiv = '<div id="skill-unlock-div" class="rounded-card middle-align unlock-info">Unlock Next Skill at Floor ' + skill[i].unlockReqFloor + '</div>'; $("#skill-area-div").append(appendSkillDiv); i = skill.length; } } } hero.countSkill = countSkill; if(openNewSkill == 1 && hero.totalGainOrbs == 0) updateTab("skill"); if(setting.skillAreaShow == 1){ componentAction ("skill-area-div", "removeClass", "d-none"); setting.skillAreaShow = 1; } }; var updateShopTimer = function(){ let restTempBonusShopDpcTime = 0; let restTempBonusShopDpsTime = 0; let restTempBonusShopCoinTime = 0; let timeDescription = "-"; if(hero.tempBonusShopDpcTime > 0){ restTempBonusShopDpcTime = hero.tempBonusShopDpcTime-Date.now(); if(restTempBonusShopDpcTime > 0) timeDescription = offlineTimeText(restTempBonusShopDpcTime/1000); else hero.tempBonusShopDpcTime = 0; componentAction ("bonus-shop-dpc-percentage", "replaceText", numberFormat(hero.bonusShopDpcPercentage)); componentAction ("temp-bonus-shop-dpc-time", "replaceText", ); } if(hero.tempBonusShopDpsTime > 0){ restTempBonusShopDpsTime = hero.tempBonusShopDpsTime-Date.now(); if(restTempBonusShopDpsTime > 0) timeDescription = offlineTimeText(restTempBonusShopDpsTime/1000); else hero.tempBonusShopDpsTime = 0; componentAction ("bonus-shop-dps-percentage", "replaceText", numberFormat(hero.bonusShopDpsPercentage)); componentAction ("temp-bonus-shop-dps-time", "replaceText", ); } if(hero.tempBonusShopCoinTime > 0){ restTempBonusShopCoinTime = hero.tempBonusShopCoinTime-Date.now(); if(restTempBonusShopCoinTime > 0) timeDescription = offlineTimeText(restTempBonusShopCoinTime/1000); else hero.tempBonusShopCoinTime = 0; componentAction ("bonus-shop-coin-percentage", "replaceText", numberFormat(hero.bonusShopCoinPercentage)); componentAction ("temp-bonus-shop-coin-time", "replaceText", offlineTimeText(restTempBonusShopCoinTime/1000)); } calcTotalDpc(); calcTotalDps(); calcTotalRewardCoin(); if(!tempShopInterval)tempShopInterval = setTimeout(updateShopTimer,1000); if(hero.tempBonusShopDpcTime <= 0 && hero.tempBonusShopDpsTime <= 0 && hero.tempBonusShopCoinTime <= 0) tempShopInterval = clearTimeout(tempShopInterval); }; var showShopArea = function(){ let appendShopDiv = ''; let restTempBonusShopDpcTime = hero.tempBonusShopDpcTime-Date.now(); let restTempBonusShopDpsTime = hero.tempBonusShopDpsTime-Date.now(); let restTempBonusShopCoinTime = hero.tempBonusShopCoinTime-Date.now(); let seen = new Set(); let cleanShop = shop.filter(el => { let duplicate = seen.has(el.typeName); seen.add(el.typeName); return !duplicate; }); componentAction ("total-token", "replaceText", hero.token); componentAction ("bonus-shop-dpc-percentage", "replaceText", numberFormat(hero.bonusShopDpcPercentage)); componentAction ("bonus-shop-dps-percentage", "replaceText", numberFormat(hero.bonusShopDpsPercentage)); componentAction ("bonus-shop-coin-percentage", "replaceText", numberFormat(hero.bonusShopCoinPercentage)); componentAction ("temp-bonus-shop-dpc-time", "replaceText", offlineTimeText(restTempBonusShopDpcTime/1000)); componentAction ("temp-bonus-shop-dps-time", "replaceText", offlineTimeText(restTempBonusShopDpsTime/1000)); componentAction ("temp-bonus-shop-coin-time", "replaceText", offlineTimeText(restTempBonusShopCoinTime/1000)); componentAction ("hero-gods-slot", "replaceText", hero.activeGodsSlot+" Slot"); if(hero.tempBonusShopDpcTime > 0 || hero.tempBonusShopDpsTime > 0 || hero.tempBonusShopCoinTime > 0) updateShopTimer(); for(let i=0;i<cleanShop.length;i++){ if(cleanShop[i].typeName == "Gods Slot") $( "#shop-area-" + i ).remove(); if( !$( "#shop-area-" + i ).length){ let arrayShopData = shop.filter(item => item.typeName === cleanShop[i].typeName); appendShopDiv += '<div id="shop-area-' + i + '" class="row border-top rounded-card">'; appendShopDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'; if(cleanShop[i].typeName == "Gods Slot") appendShopDiv += 'Increase ' + cleanShop[i].bonusValue + ' ' + cleanShop[i].typeName; else appendShopDiv += 'Increase ' + cleanShop[i].bonusValue + '% ' + cleanShop[i].typeName; appendShopDiv += '</div>'; for(let a=0;a<arrayShopData.length;a++){ let textBtnShop = ''; let disableButton = ''; if(arrayShopData[a].duration == 0){ if(cleanShop[i].typeName == "Gods Slot"){ if(hero.activeGodsSlot == setting.maxActiveGodsSlot){ textBtnShop = "Maxed"; disableButton = 'disabled'; } else textBtnShop += arrayShopData[a].unit+' - '+numberFormat(arrayShopData[a].token)+' Token'; }else textBtnShop += arrayShopData[a].unit+' - '+numberFormat(arrayShopData[a].token)+' Token'; }else textBtnShop += arrayShopData[a].duration+' '+arrayShopData[a].unit+' - '+numberFormat(arrayShopData[a].token)+' Token'; appendShopDiv += '<div class="col-xl-3 col-lg-3 col-md-6 col-sm-6 col-12">'; appendShopDiv += '<button id="shop-button-' + i + '-' + a + '" class="shop-button-class" value="' + arrayShopData[a].id + '"' + disableButton + '><span id ="button-desc-' + i + '-' + a + '">' + textBtnShop + '</span></button>'; appendShopDiv += '</div>'; } appendShopDiv += '</div>'; } } $("#shop-area-div").append(appendShopDiv).off('click','.shop-button-class').on('click','.shop-button-class',function(){ shopTradeToken(this); }); }; var showPrestigeArea = function(){ if(hero.maxFloor >= setting.unlockReqFloorPrestige){ if(!$("#prestige-area-div").length){ let appendPrestigeDiv = '<div id="prestige-area-div" class="row border-top rounded-card prestige-button text-center">'; appendPrestigeDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">Prestige</div>'; appendPrestigeDiv += '</div>'; $("#hero-area-div").append(appendPrestigeDiv).on('click','#prestige-area-div',function(){ startPrestige(); }); } } }; var showArtifactArea = function(){ checkDuplicateArtifact(); let totalGainOrbs = new Decimal(hero.totalGainOrbs); let cleanArtifact = cleanDuplicateArray(availableArtifact); let unlockFee = new Decimal(calcNextUnlockArtifactFee()).mul(100-hero.bonusArtifactUnlockFeePercentage).div(100).ceil(); componentAction ("total-orbs", "replaceText", numberFormat(hero.orbs)); componentAction ("total-artifact-damage", "replaceText", numberFormat(hero.artifactDamagePercentage)); if(cleanArtifact.length > 0) componentAction ("unlock-artifact-fee", "replaceText", numberFormat(unlockFee)+" Orbs"); else{ componentAction ("total-orbs-div", "removeClass", "pt-3"); componentAction ("unlock-artifact-text", "replaceText", "Maxed"); componentAction ("unlock-artifact-hyphen", "replaceText", ""); componentAction ("unlock-artifact-button", "addClass", "skill-disabled"); componentAction ("unlock-artifact-fee", "clearText", ""); $("#unlock-artifact-button").prop('disabled', true); } componentAction ("artifact-div", "removeClass", "d-none"); componentAction ("artifact", "updateClass", "cursor-button,active"); for(let i=0; i<hero.countArtifact; i++){ let unlockArtifact = hero.unlockArtifact[i]; let unlockArtifactId = unlockArtifact.id; let artifactData = artifact.find(item => item.id === unlockArtifactId); let upgradeFee = new Decimal(calcNextUpgradeArtifactFee(unlockArtifactId)).mul(100-hero.bonusArtifactUpgradeFeePercentage).div(100).ceil(); if( !$( "#artifact-area-" + unlockArtifactId ).length){ let appendArtifactDiv = '<div id="artifact-area-' + unlockArtifactId + '" class="row border-top rounded-card">'; appendArtifactDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-8 col-8 v-center-flex">'; appendArtifactDiv += '<span id="artifact-name-' + unlockArtifactId + '">' + artifactData.name + '</span>&nbsp;Lv&nbsp;<span id="artifact-level-' + unlockArtifactId + '">' + unlockArtifact.level + '</span>'; appendArtifactDiv += '</div>'; appendArtifactDiv += '<div class="col-xl-4 col-lg-4 col-md-3 col-sm-4 col-4 v-center-flex">'; appendArtifactDiv += '<span id="artifact-calc-damage-' + unlockArtifactId + '">' + artifactData.calcDamage + '</span>&nbsp;<span id="artifact-damage-' + unlockArtifactId + '">' + numberFormat(unlockArtifact.damage) + '</span>&nbsp;<span id="artifact-desc-damage-' + unlockArtifactId + '">' + artifactData.descDamage + '</span>'; appendArtifactDiv += '</div>'; appendArtifactDiv += '<div class="col-xl-4 col-lg-4 col-md-5 col-sm-12 col-12 v-center-flex">'; appendArtifactDiv += '<span id="artifact-desc-' + unlockArtifactId + '">' + artifactData.description + ' ' + artifactData.baseDamage + artifactData.descDamage + ' / level</span>'; appendArtifactDiv += '</div>'; appendArtifactDiv += '<div class="col-xl-10 col-lg-10 col-md-10 col-sm-10 col-10 no-padding v-center-grid">'; if(unlockArtifact.level < artifactData.maxLevel || artifactData.maxLevel == 0) appendArtifactDiv += '<button id="upgrade-artifact-button-' + unlockArtifactId + '" class="upgrade-level-button" value="' + unlockArtifactId + '"><img src="assets/images/upgrade.svg" class="image-size-2"></img>&nbsp;<span id="upgrade-artifact-fee-' + unlockArtifactId + '">Upgrade - ' + numberFormat(upgradeFee) + ' Orbs</span></button>'; else appendArtifactDiv += '<button id="upgrade-artifact-button-' + unlockArtifactId + '" class="upgrade-level-button" disabled><span id="upgrade-artifact-fee-' + unlockArtifactId + '">Maxed</span></button>'; appendArtifactDiv += '</div>'; appendArtifactDiv += '<div id="sell-artifact-div-' + unlockArtifactId + '" class="col-xl-2 col-lg-2 col-md-2 col-sm-2 col-2 no-padding">'; appendArtifactDiv += '</div>'; appendArtifactDiv += '</div>'; $("#artifact-area-div").append(appendArtifactDiv).off('click','#upgrade-artifact-button-'+unlockArtifactId).on('click','#upgrade-artifact-button-'+unlockArtifactId,function(){ upgradeLevelArtifact(unlockArtifactId); }); let sellArtifactDiv = '<button id="sell-artifact-button-' + unlockArtifactId + '" class="upgrade-level-button btn-secondary" value="' + unlockArtifactId + '"><img src="assets/images/trade.svg" class="image-size-2-static"></img></button>'; $("#sell-artifact-div-"+unlockArtifactId).append(sellArtifactDiv).on('click','#sell-artifact-button-'+unlockArtifactId,function(){ confirmSellArtifact(this); }); }else{ componentAction ("artifact-level-"+unlockArtifactId, "replaceText", unlockArtifact.level); componentAction ("artifact-damage-"+unlockArtifactId, "replaceText", unlockArtifact.damage); if(unlockArtifact.level < artifactData.maxLevel || artifactData.maxLevel == 0) componentAction ("upgrade-artifact-fee-"+unlockArtifactId, "replaceText", "Upgrade - "+numberFormat(upgradeFee)+" Orbs"); else{ componentAction ("upgrade-artifact-fee-"+unlockArtifactId, "replaceText", "Maxed"); $("#upgrade-artifact-button-"+unlockArtifactId).prop('disabled', true); } } } calcHeightScrollDiv("artifact"); }; var cleanDuplicateArray = function(listArray){ let seen = new Set(); let cleanArray = listArray.filter(el => { let duplicate = seen.has(el); seen.add(el); return !duplicate; }); return cleanArray; }; var checkNextUnlockPartner = function(currentPartnerId){ let currentPartnerData = partner.find(item => item.id === currentPartnerId); let nextUnlockPartner = hero.unlockPartner.find(item => item.id === currentPartnerId); let totalUpgradeFee = new Decimal(0); let nextPartnerIsReady = true; let newReqLevel = 0; let prevPartnerId = -1; let prevPartnerName = ""; let partnerId = currentPartnerId; while(nextUnlockPartner && nextUnlockPartner.status != "Battling"){ let nextPartnerId = partnerId + 1; let partnerData = partner.find(item => item.id === partnerId); let nexPartnerData = partner.find(item => item.id === nextPartnerId); let reqUnlockLevel = nexPartnerData.unlockReq; for(let i=0;i<reqUnlockLevel;i++){ let upgradeFee = new Decimal(formulaUpgradePartnerFee(i,partnerData.basePrice)); totalUpgradeFee = totalUpgradeFee.plus(upgradeFee); } partnerId +=1; nextPartnerIsReady = false; nextUnlockPartner = hero.unlockPartner.find(item => item.id === partnerId); } if(currentPartnerId > 0){ prevPartnerId = currentPartnerId - 1; let prevPartnerData = partner.find(item => item.id === prevPartnerId); if(!nextPartnerIsReady){ let tempUpgradeFee = new Decimal(0); newReqLevel = currentPartnerData.unlockReq; while(tempUpgradeFee.lessThan(totalUpgradeFee)){ let upgradeFee = formulaUpgradePartnerFee(newReqLevel,prevPartnerData.basePrice); tempUpgradeFee = tempUpgradeFee.plus(upgradeFee); newReqLevel += 1; } } prevPartnerName = prevPartnerData.name; }else{ if(!nextPartnerIsReady){ let tempUpgradeFee = new Decimal(0); newReqLevel = currentPartnerData.unlockReq; while(tempUpgradeFee.lessThan(totalUpgradeFee)){ newReqLevel += 1; let upgradeFee = formulaUpgradeHeroFee(newReqLevel-1); tempUpgradeFee = tempUpgradeFee.plus(upgradeFee); } } prevPartnerName = "Hero"; } if(newReqLevel % 5 != 0) newReqLevel = Math.ceil(newReqLevel/5)*5; let newObjUnlockNewPartner = { unlockReq: newReqLevel, prevPartnerId: prevPartnerId, prevPartnerName: prevPartnerName, nextPartnerId: partnerId, }; return newObjUnlockNewPartner; }; var checkDuplicateArtifact = function(){ let seen = new Set(); let cleanArtifact = hero.unlockArtifact.filter(el => { let duplicate = seen.has(el.id); seen.add(el.id); return !duplicate; }); if(hero.countArtifact != cleanArtifact.length){ hero.countArtifact = cleanArtifact.length; hero.unlockArtifact = []; hero.unlockArtifact = cleanArtifact; } }; var checkDuplicateAdventure = function(objAdventureSlot){ let seen = new Set(); let cleanAdventure = objAdventureSlot.filter(el => { let duplicate = seen.has(el.slotId); seen.add(el.slotId); return !duplicate; }); objAdventureSlot = []; objAdventureSlot = cleanAdventure; return objAdventureSlot; }; var showProfileArea = function(){ lastActiveMenu = 'profile'; componentAction ("profile-div", "removeClass", "d-none"); componentAction ("profile", "updateClass", "cursor-button,active"); componentAction ("profile-user-id", "inputText", hero.userId); componentAction ("profile-user-name", "inputText", hero.userName); }; var showStatisticArea = function(){ let highestPartnerLevelString = ''; componentAction ("statistic-div", "removeClass", "d-none"); componentAction ("statistic", "updateClass", "cursor-button,active"); componentAction ("stat-first-datetime", "replaceText", dateFormat(hero.firstPlayDateTime)); componentAction ("stat-online-duration", "replaceText", offlineTimeText(hero.totalOnlineDuration)); componentAction ("stat-offline-duration", "replaceText", offlineTimeText(hero.totalOfflineDuration)); componentAction ("stat-percentage-bonus-coin", "replaceText", numberFormat(hero.percentageBonusCoin)); componentAction ("stat-online-gain-coin", "replaceText", numberFormat(hero.totalGainCoin)); componentAction ("stat-offline-gain-coin", "replaceText", numberFormat(hero.totalOfflineCoin)); componentAction ("stat-spent-coin", "replaceText", numberFormat(hero.totalSpentCoin)); componentAction ("stat-total-click", "replaceText", numberFormat(hero.totalClick)); componentAction ("stat-percentage-bonus-dpc", "replaceText", numberFormat(hero.percentageBonusDpc)); componentAction ("stat-highest-dpc", "replaceText", numberFormat(hero.highestDpc)); componentAction ("stat-percentage-bonus-dps", "replaceText", numberFormat(hero.percentageBonusDps)); componentAction ("stat-highest-dps", "replaceText", numberFormat(hero.highestDps)); componentAction ("stat-highest-floor", "replaceText", numberFormat(hero.highestFloor)); componentAction ("stat-total-prestige", "replaceText", numberFormat(hero.totalCountPrestige)); componentAction ("stat-percentage-bonus-orbs", "replaceText", numberFormat(hero.percentageBonusOrbs)); componentAction ("stat-total-gain-orbs", "replaceText", numberFormat(hero.totalGainOrbs)); componentAction ("stat-total-spent-orbs", "replaceText", numberFormat(hero.totalSpentOrbs)); componentAction ("stat-total-artifact-unlock", "replaceText", numberFormat(hero.totalArtifactUnlock)); componentAction ("stat-highest-hero-level", "replaceText", numberFormat(hero.highestHeroLevel)); componentAction ("stat-highest-weapon-level", "replaceText", numberFormat(hero.highestWeaponLevel)); for(let i=0;i<hero.highestUnlockPartner.length;i++){ let partnerId = hero.highestUnlockPartner[i].id; let partnerLevel = hero.highestUnlockPartner[i].level; let partnerDps = hero.highestUnlockPartner[i].dps; let partnerData = partner.find(item => item.id === partnerId); highestPartnerLevelString += partnerData.name+" - Level "+partnerLevel+" - DPS "+numberFormat(partnerDps)+"\n"; } componentAction ("stat-highest-partner-level", "replaceText", highestPartnerLevelString); calcHeightScrollDiv("statistic"); }; var showAchievementArea = function(){ let highestPartnerLevelString = ''; componentAction ("achievement-div", "removeClass", "d-none"); componentAction ("achievement", "updateClass", "cursor-button,active"); componentAction ("achievement-token", "replaceText", numberFormat(hero.token)); for(let i=0;i<hero.achievement.length;i++){ let unlockAchievement = hero.achievement.find(item => item.id === i); let achievementData = achievement.find(item => item.id === i); let achievementReward = (unlockAchievement.level%2==0 ? (unlockAchievement.level+1): unlockAchievement.level); let achievementBalance = new Decimal(unlockAchievement.balance); let achievementTarget = new Decimal(unlockAchievement.target); let disableButton = ''; let buttonText = ''; if(unlockAchievement.level < achievementData.maxLoop){ if(achievementBalance.lessThan(achievementTarget)){ disableButton = 'disabled'; buttonText = 'Next Reward - ' + numberFormat(achievementReward) + ' Token'; }else buttonText = 'Collect Reward - ' + numberFormat(achievementReward) + ' Token'; }else{ disableButton = 'disabled'; buttonText = 'Maxed'; } if( !$( "#achievement-area-" + i ).length){ let appendAchievementDiv = '<div id="achievement-area-' + i + '" class="row border-top no-gutters rounded-card">'; appendAchievementDiv += '<div class="col-xl-3 col-lg-3 col-md-3 col-sm-9 col-9 py-3">'; appendAchievementDiv += '<span id="achievement-name-' + i + '" class="strong">' + achievementData.name + '</span>'; appendAchievementDiv += '</div>'; if(unlockAchievement.level == 0) appendAchievementDiv += '<div id="achievement-image-' + i + '" class="col-xl-1 col-lg-1 col-md-1 col-sm-3 col-3 right-align achievement-bg-bw">'; else appendAchievementDiv += '<div id="achievement-image-' + i + '" class="col-xl-1 col-lg-1 col-md-1 col-sm-3 col-3 right-align achievement-bg-color">'; appendAchievementDiv += '<div class="middle-align pt-10x">'; appendAchievementDiv += '<span id="achievement-level-' + i + '">' + unlockAchievement.level + '</span>'; appendAchievementDiv += '</div>'; appendAchievementDiv += '</div>'; appendAchievementDiv += '<div class="col-xl-8 col-lg-8 col-md-8 col-sm-12 col-12 animate-bar no-padding mt-2-5-cond">'; appendAchievementDiv += '<div class="progress-bar-div">'; appendAchievementDiv += '<span id="achievement-count-' + i + '">' + numberFormat(unlockAchievement.balance) + '</span> / <span id="achievement-target-' + i + '">'+ numberFormat(unlockAchievement.target)+ '</span>'; appendAchievementDiv += '</div>'; appendAchievementDiv += '<div id="achievement-bar-' + i + '" class="progress-bar achievement-progress-bar-color">&nbsp;</div>'; appendAchievementDiv += '</div>'; appendAchievementDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'; appendAchievementDiv += '<button id="achievement-button-' + i + '" class="upgrade-level-button mt-1" value="' + i + '"' + disableButton + '><span id="achievement-reward-' + i + '">' + buttonText + '</span></button>'; appendAchievementDiv += '</div>'; appendAchievementDiv += '</div>'; $("#achievement-area-div").append(appendAchievementDiv).off('click','#achievement-button-'+i).on('click','#achievement-button-'+i,function(){ collectAchievementReward(this); }); }else{ componentAction ("achievement-level-"+i, "replaceText", unlockAchievement.level); componentAction ("achievement-count-"+i, "replaceText", numberFormat(unlockAchievement.balance)); componentAction ("achievement-target-"+i, "replaceText", numberFormat(unlockAchievement.target)); componentAction ("achievement-reward-"+i, "replaceText", buttonText); if(unlockAchievement.level > 0) componentAction ("achievement-image-"+i, "updateClass", "achievement-bg-bw,achievement-bg-color"); if(disableButton == '') $("#achievement-button-"+i).prop('disabled', false); else $("#achievement-button-"+i).prop('disabled', true); } let currentBalance = new Decimal(unlockAchievement.balance).sub(unlockAchievement.prevTarget); let currentTarget = new Decimal(unlockAchievement.target).sub(unlockAchievement.prevTarget); let newAchievementBar = currentBalance.div(currentTarget).mul(100); if(newAchievementBar.greaterThan(100)) newAchievementBar = 100; componentAction ("achievement-bar-"+i, "animate", newAchievementBar); } calcHeightScrollDiv("achievement"); }; var showDailyTaskArea = function(){ componentAction ("daily-task-div", "removeClass", "d-none"); componentAction ("daily-task", "updateClass", "cursor-button,active"); for(let i=0; i<hero.dailyTask.task.length; i++){ let unlockDailyTask = hero.dailyTask.task[i]; let unlockDailyTaskId = unlockDailyTask.id; let dailyTaskData = dailyTask.find(item => item.id === unlockDailyTaskId); if( !$( "#daily-task-area-" + unlockDailyTaskId ).length){ let appendDailyTaskDiv = '<div id="daily-task-area-' + unlockDailyTaskId + '" class="row border-top rounded-card">'; appendDailyTaskDiv += '<div class="col-xl-3 col-lg-3 col-md-3 col-sm-10 col-10 v-center">'; appendDailyTaskDiv += '<span id="daily-task-name-' + unlockDailyTaskId + '" class="strong">' + dailyTaskData.name + ' ('+dailyTaskData.prize+' Token)</span>'; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '<div class="col-xl-1 col-lg-1 col-md-1 col-sm-2 col-2 right-align">'; if(unlockDailyTask.complete) appendDailyTaskDiv += '<span id="daily-task-complete-' + unlockDailyTaskId + '"><img src="assets/images/complete.svg" height="20px"></img></span>'; else appendDailyTaskDiv += '<span id="daily-task-complete-' + unlockDailyTaskId + '" class="d-none"><img src="assets/images/complete.svg" height="20px"></img></span>'; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 v-center">'; appendDailyTaskDiv += '<span id="artifact-desc-' + unlockDailyTaskId + '">' + dailyTaskData.description + ' ' + numberFormat(dailyTaskData.required) + ' ' + dailyTaskData.unit+'</span>'; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 v-center animate-bar no-padding">'; appendDailyTaskDiv += '<div class="progress-bar-div">'; appendDailyTaskDiv += '<span id="current-count-' + unlockDailyTaskId + '">' + numberFormat(unlockDailyTask.count) + '</span> / '+ numberFormat(dailyTaskData.required); appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '<div id="daily-task-bar-' + unlockDailyTaskId + '" class="progress-bar daily-task-progress-bar-color">&nbsp;</div>'; appendDailyTaskDiv += '</div>'; appendDailyTaskDiv += '</div>'; $("#daily-task-area-div").append(appendDailyTaskDiv); }else{ componentAction ("current-count-"+unlockDailyTaskId, "replaceText", unlockDailyTask.count); if(unlockDailyTask.complete) componentAction ("daily-task-complete-"+unlockDailyTaskId, "removeClass", "d-none"); } let newDailyTaskBar = unlockDailyTask.count / dailyTaskData.required * 100; componentAction ("daily-task-bar-"+unlockDailyTaskId, "animate", newDailyTaskBar); } if(!hero.token)hero.token = 0; componentAction ("hero-token", "replaceText", hero.token); calcHeightScrollDiv("daily-task"); }; var showGodsArea = function(selectedGodsId=null){ showGodsTab("gods"); if(hero.highestFloor >= setting.unlockReqFloorGods){ if(hero.unlockFragment.length > 0){ $("#god-unlock-div").remove(); let tempUnlockFragment = []; if(hero.unlockGods.length > 0){ hero.unlockGods.sort((a, b) => (a.isActive < b.isActive) ? 1 : (a.isActive === b.isActive) ? ((a.id > b.id) ? 1 : -1) : -1 ); for(let i=0;i<hero.unlockGods.length;i++){ tempUnlockFragment.push(hero.unlockGods[i].id); } } if(hero.unlockFragment.length > 0){ hero.unlockFragment.sort((a, b) => (a.id > b.id) ? 1 : -1); for(let i=0;i<hero.unlockFragment.length;i++){ let indexId = tempUnlockFragment.indexOf(hero.unlockFragment[i].id); if (indexId === -1){ tempUnlockFragment.push(hero.unlockFragment[i].id); } } } for(let i=0; i<tempUnlockFragment.length; i++){ let fragmentId = tempUnlockFragment[i]; let godsData = gods.find(item => item.id === fragmentId); let unlockFragment = hero.unlockFragment.find(item => item.id === fragmentId); let unlockGods = hero.unlockGods.find(item => item.id === fragmentId); let godsLevel = 0; let godsImage = ""; let godsDesc = godsData.desc; let godsDamage = 0; let disableButton = ""; let textActivateGods = ""; let styleActivateButton = "d-none"; let godsActiveStyle = ''; if(godsData.gender == "M") godsImage = "gods"; else godsImage = "goddess"; if(unlockGods){ godsLevel = unlockGods.level; godsImage += "-color"; godsDamage = unlockGods.level * godsData.levelMultiplier; if(unlockGods.isActive){ textActivateGods = "Deactivate"; godsActiveStyle = "tab-active"; }else textActivateGods = "Activate"; styleActivateButton = ""; } if(!unlockGods || unlockGods.level < godsData.maxLevel) godsDesc = godsDesc.replace("x",godsDamage+"(+"+godsData.levelMultiplier+")"); else godsDesc = godsDesc.replace("x",godsDamage); let targetFragment = Math.ceil((godsLevel+1)/5)*10; let buttonText = "Summon Gods Lv "+(godsLevel+1); if(unlockFragment.count < targetFragment) disableButton = "disabled"; if( !$( "#gods-area-" + unlockFragment.id ).length){ let appendGodsDiv = '<div id="gods-area-' + unlockFragment.id + '" class="row border-top rounded-card no-gutters mx-1 ' + godsActiveStyle + '">'; appendGodsDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-4 col-4 middle-align '+godsImage+'">'; appendGodsDiv += '<img id="gods-image-' + unlockFragment.id + '" src="assets/images/'+godsImage+'.svg" class="'+godsImage+' invisible"></img>'; appendGodsDiv += '</div>'; appendGodsDiv += '<div class="col-xl-8 col-lg-8 col-md-8 col-sm-8 col-8">'; appendGodsDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'; appendGodsDiv += godsData.name + ' Lv <span id="gods-level-' + unlockFragment.id + '">' + godsLevel + '</span>'; appendGodsDiv += '</div>'; appendGodsDiv += '<div id="gods-desc-' + unlockFragment.id + '" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'+godsDesc+'</div>'; appendGodsDiv += '</div>'; appendGodsDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 animate-bar no-padding mt-1">'; appendGodsDiv += '<div class="progress-bar-div">'; appendGodsDiv += '<span id="gods-count-' + unlockFragment.id + '">' + numberFormat(unlockFragment.count) + '</span> / <span id="gods-target-' + unlockFragment.id + '">'+ numberFormat(targetFragment)+ '</span>'; appendGodsDiv += '</div>'; appendGodsDiv += '<div id="gods-bar-' + unlockFragment.id + '" class="progress-bar gods-progress-bar-color">&nbsp;</div>'; appendGodsDiv += '</div>'; appendGodsDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'; appendGodsDiv += '<button id="summon-gods-button-' + unlockFragment.id + '" class="upgrade-level-button mt-1" value="' + unlockFragment.id + '"' + disableButton + '><span id="summon-gods-text-' + unlockFragment.id + '">' + buttonText + '</span></button>'; appendGodsDiv += '</div>'; appendGodsDiv += '</div>'; $("#gods-area-div").append(appendGodsDiv).off('click','#summon-gods-button-'+unlockFragment.id).on('click','#summon-gods-button-'+unlockFragment.id,function(){ summonGods(this); }); appendGodsDiv = '<div id="activate-gods-div-'+unlockFragment.id+'" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 ' + styleActivateButton + '">'; appendGodsDiv += '<button id="activate-gods-button-' + unlockFragment.id + '" class="upgrade-level-button mt-1" value="' + unlockFragment.id + '"><span id ="activate-text-' + unlockFragment.id + '">' + textActivateGods + '</span></button>'; appendGodsDiv += '</div>'; $("#gods-area-"+unlockFragment.id).append(appendGodsDiv).off('click','#activate-gods-button-'+unlockFragment.id).on('click','#activate-gods-button-'+unlockFragment.id,function(){ activateGods(this); }); }else{ $("#gods-image-"+unlockFragment.id).attr("src", "assets/images/"+godsImage+".svg"); componentAction ("gods-level-"+unlockFragment.id, "replaceText", godsLevel); componentAction ("gods-target-"+unlockFragment.id, "replaceText", targetFragment); componentAction ("gods-count-"+unlockFragment.id, "replaceText", unlockFragment.count); componentAction ("gods-desc-"+unlockFragment.id, "replaceText", godsDesc); if(unlockFragment.count < targetFragment) $("#summon-gods-button-"+unlockFragment.id).prop('disabled', true); else $("#summon-gods-button-"+unlockFragment.id).prop('disabled', false); if(styleActivateButton=="")componentAction ("activate-gods-div-"+unlockFragment.id, "removeClass", "d-none"); if(unlockGods){ if(unlockGods.level < godsData.maxLevel)componentAction ("summon-gods-text-"+unlockFragment.id, "replaceText", "Summon Gods Lv "+(unlockGods.level+1)); else{ componentAction ("summon-gods-text-"+unlockFragment.id, "replaceText", "Maxed"); $("#summon-gods-button-"+unlockFragment.id).prop('disabled', true); } } } let newFragmentBar = unlockFragment.count / targetFragment * 100; if(newFragmentBar > 100) newFragmentBar = 100; componentAction ("gods-bar-"+unlockFragment.id, "animate", newFragmentBar); } }else{ if( !$( "#god-unlock-div").length){ let appendGodsDiv = '<div id="god-unlock-div" class="rounded-card unlock-info middle-align">Exchange Gods Fragment First at the Temple</div>'; $("#gods-area-div").append(appendGodsDiv); } } }else{ if( !$( "#god-unlock-div").length){ let appendGodsDiv = '<div id="god-unlock-div" class="rounded-card unlock-info middle-align">Unlock this gods at floor ' + setting.unlockReqFloorGods + ' </div>'; $("#gods-area-div").append(appendGodsDiv); } } if(selectedGodsId != null){ $("#gods-area-"+selectedGodsId)[0].scrollIntoView({ behavior: "instant", /* or "smooth" or "auto" */ block: "start" /* or "end" */ }); } calcHeightScrollDiv("gods"); }; var showTempleArea = function(){ showGodsTab("temple"); if(hero.highestFloor >= setting.unlockReqFloorGods){ $("#temple-area-div").empty(); insertAvailableGods(); let disableButton = ''; let buttonText = 'Exchange Gods Fragment'; if(hero.soul < setting.soulEachFragment) disableButton = 'disabled'; let dropDownList = ["All=All Soul","1="+(setting.soulEachFragment*1)+" Soul"]; if(!$( "#temple-area" ).length){ let appendTempleDiv = '<div id="temple-area" class="row border-top rounded-card no-gutters mx-1">'; appendTempleDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 middle-align">'; appendTempleDiv += '<img src="assets/images/temple.svg" class="temple-img"></img>'; appendTempleDiv += '</div>'; appendTempleDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 animate-bar no-padding mt-2-5-cond">'; appendTempleDiv += '<div class="progress-bar-div">'; appendTempleDiv += '<span id="soul-count">' + numberFormat(hero.soul) + '</span> / <span id="soul-target">'+ numberFormat(setting.soulEachFragment)+ '</span>'; appendTempleDiv += '</div>'; appendTempleDiv += '<div id="soul-bar" class="progress-bar soul-progress-bar-color">&nbsp;</div>'; appendTempleDiv += createDropDownList(dropDownList,'fragment-count'); appendTempleDiv += '<button id="soul-button" class="upgrade-level-button mt-2"' + disableButton + '><span id="soul-trade">' + buttonText + '</span></button>'; appendTempleDiv += '</div>'; appendTempleDiv += '</div>'; $("#temple-area-div").append(appendTempleDiv).off('click','#soul-button').on('click','#soul-button',function(){ confirmTradeGodsFragment($("#fragment-count").val()); }); }else{ componentAction ("soul-count", "replaceText", numberFormat(hero.soul)); if(hero.soul >= setting.soulEachFragment) $("#soul-button").prop('disabled', false); else $("#soul-button").prop('disabled', true); } let newSoulBar = hero.soul / setting.soulEachFragment * 100; if(newSoulBar > 100) newSoulBar = 100; componentAction ("soul-bar", "animate", newSoulBar); }else{ if( !$( "#temple-unlock-div").length){ let appendTempleDiv = '<div id="temple-unlock-div" class="rounded-card unlock-info middle-align">Unlock this temple at floor ' + setting.unlockReqFloorGods + ' </div>'; $("#temple-area-div").append(appendTempleDiv); } } calcHeightScrollDiv("gods"); }; var insertAchievement = function(){ if(hero.achievement.length == 0){ for(let i=0;i<achievement.length;i++){ let newObjectAchievement = { id: achievement[i].id, level: 0, prevTarget: 0, target: achievement[i].baseTarget, balance: 0 }; hero.achievement.push(newObjectAchievement); } } }; var insertDailyTask = function(){ let isInsertNewDailyTask = false; let date = new Date(); let currentDailyTaskDate = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()); if(!hero.dailyTask || hero.dailyTask.length == 0) isInsertNewDailyTask = true; else{ if(hero.dailyTask.date > 0){ let msPerDay = 1000 * 60 * 60 * 24; let dateDiff = Math.floor((currentDailyTaskDate - hero.dailyTask.date) / msPerDay); if(dateDiff > 0)isInsertNewDailyTask = true; } } if(isInsertNewDailyTask){ let heroDailyTask = []; let availableDailyTask = []; let addDailyTask = true; for(let i=1;i<dailyTask.length;i++){ addDailyTask = true; switch(dailyTask[i].id){ case 12: case 18: case 19: if(hero.unlockPet.length == 0) addDailyTask = false; break; case 13: case 14: case 15: case 16: case 17: let zoneId = dailyTask[i].id - 13; let unlockZone = hero.unlockZone.find(item => item.id === zoneId); if(!unlockZone) addDailyTask = false; break; } if(addDailyTask) availableDailyTask.push(dailyTask[i].id); } for(let i=0;i<setting.dailyTaskCount;i++){ let unlockDailyTaskId = availableDailyTask[Math.floor(Math.random() * availableDailyTask.length)]; let unlockIndex = availableDailyTask.indexOf(unlockDailyTaskId); if (unlockIndex !== -1){ availableDailyTask.splice(unlockIndex, 1); let newObjectDailyTask = { id: unlockDailyTaskId, count: 0, complete : false, }; heroDailyTask.push(newObjectDailyTask); } } let newObjectDailyTask = { id: 0, count: 0, complete : false, }; heroDailyTask.push(newObjectDailyTask); hero.dailyTask = { date: currentDailyTaskDate, task: heroDailyTask, }; updateDailyTask(1); } }; var unlockNewPet = function(petId=-1){ if(petId == -1){ for(let i=0;i<pet.length;i++){ let unlockPet = hero.unlockPet.find(item => item.id === i); if(hero.highestFloor >= pet[i].unlockReqFloor && !unlockPet){ petId = i; i = pet.length; } } } if(petId >= 0){ let unlockPet = hero.unlockPet.find(item => item.id === petId); let petData = pet.find(item => item.id === petId); let canUnlockNewPet = false; switch(petId){ case 1: if(hero.highestWeaponLevel > 0 && hero.highestFloor >= petData.unlockReqFloor) canUnlockNewPet = true; break; case 2: if(hero.highestFloor >= petData.unlockReqFloor) canUnlockNewPet = true; break; default: if(petId >= 3){ let partnerId = petId - 3; let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); if(unlockPartner && hero.highestFloor >= petData.unlockReqFloor) canUnlockNewPet = true; }else canUnlockNewPet = true; break; } if(canUnlockNewPet && !unlockPet){ if(hero.countPet == 0) unlockNewFeatures("pet"); hero.countPet++; let newObjPet = { id: petId, level: 1, currExp: 0, currBonus: petData.multiplierBonus, adventureZone: -1, adventureSlot: -1, statusAdventure: '', collectReward: '' }; hero.unlockPet.push(newObjPet); $("#pet-area-div").empty(); if(!$("#pet-div").hasClass("d-none"))showPetArea(); } if(hero.countPet == 1) unlockNewAdventureArea(); } }; var unlockNewAdventureArea = function(zoneId=-1){ if(zoneId == -1){ for(let i=hero.countZone;i<zone.length;i++){ let zoneData = zone.find(item => item.id === i); if(i == 0){ zoneId = i; }else{ let prevZoneId = i - 1; let prevZone = hero.unlockZone.find(item => item.id === prevZoneId); if(prevZone.level >= zoneData.unlockReqLevel) zoneId = i; } i = zone.length; } } if(zoneId >= 0){ let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let zoneData = zone.find(item => item.id === zoneId); if(!unlockZone) insertNewUnlockZone(zoneId,zoneData); } }; var unlockNewFeatures = function(featureName=""){ let newFeature = ""; let notifText = ""; if(featureName != ""){ switch(featureName){ case "pet": newFeature = "pet"; notifText = "Congratz you just unlock your first pet. Do you want to see your pet?"; break; }; }else{ switch(hero.highestFloor){ case setting.unlockReqFloorBarracks: if(hero.activeTrainingSlot == 0){ newFeature = "barracks"; hero.activeTrainingSlot = 1; notifText = "Congratz you just unlock Barracks feature. Do you want to see your Barracks?"; hero.trainingZone = { level: 1, reqMaterial: [], buildingTime: 0, maxSlot: 1, trainingSlot: [], }; for(let i=0;i<hero.highestUnlockPartner.length;i++){ let highestUnlockPartner = hero.highestUnlockPartner[i]; let partnerId = highestUnlockPartner.id; let partnerData = partner.find(item => item.id === partnerId); insertPartnerAbility(partnerId, partnerData.type); } } break; case setting.unlockReqFloorGods: if(hero.activeGodsSlot == 0){ newFeature = "gods"; hero.activeGodsSlot = 1; notifText = "Congratz you just unlock Gods feature. Do you want to see your Gods?"; } break; }; } if(newFeature != ""){ $("#modalNotifNewFeatures").modal("show"); componentAction ("notif-features-ok-button", "inputText", newFeature); componentAction ("notif-new-feature", "replaceText", notifText); } }; var showBarracksTab = function(tabName){ componentAction ("barracks-div", "removeClass", "d-none"); componentAction ("barracks", "updateClass", "cursor-button,active"); switch(tabName){ case 'barracks': componentAction ("barracks-tab-button", "updateClass", "tab-button-unactive,tab-button-active"); componentAction ("training-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("barracks-area-div", "removeClass", "d-none"); componentAction ("training-area-div", "addClass", "d-none"); break; case 'training': componentAction ("barracks-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("training-tab-button", "updateClass", "tab-button-unactive,tab-button-active"); componentAction ("barracks-area-div", "addClass", "d-none"); componentAction ("training-area-div", "removeClass", "d-none"); break; } }; var showPetTab = function(tabName){ componentAction ("pet-div", "removeClass", "d-none"); componentAction ("pet", "updateClass", "cursor-button,active"); switch(tabName){ case 'pet': componentAction ("pet-tab-button", "updateClass", "tab-button-unactive,tab-button-active"); componentAction ("area-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("pet-area-div", "removeClass", "d-none"); componentAction ("adventure-area-div", "addClass", "d-none"); break; case 'area': componentAction ("pet-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("area-tab-button", "updateClass", "tab-button-unactive,tab-button-active"); componentAction ("pet-area-div", "addClass", "d-none"); componentAction ("adventure-area-div", "removeClass", "d-none"); break; } }; var showGodsTab = function(tabName){ componentAction ("gods-div", "removeClass", "d-none"); componentAction ("gods", "updateClass", "cursor-button,active"); switch(tabName){ case 'gods': componentAction ("gods-tab-button", "updateClass", "tab-button-unactive,tab-button-active"); componentAction ("temple-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("gods-area-div", "removeClass", "d-none"); componentAction ("temple-area-div", "addClass", "d-none"); break; case 'temple': componentAction ("gods-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("temple-tab-button", "updateClass", "tab-button-unactive,tab-button-active"); componentAction ("gods-area-div", "addClass", "d-none"); componentAction ("temple-area-div", "removeClass", "d-none"); break; } }; var showBarracksArea = function(runCalculate=false){ showBarracksTab('barracks'); if(runCalculate) calculateAllPartnerAbility(); if(hero.highestFloor >= setting.unlockReqFloorBarracks){ $("#ability-unlock-div").empty(); let appendBarracksDiv = ""; let tempHighestUnlockPartner = []; if(hero.settingOrderPartner == "asc"){ for(let i=0;i<hero.highestUnlockPartner.length;i++){ tempHighestUnlockPartner.push(hero.highestUnlockPartner[i]); } }else{ for(let i=hero.highestUnlockPartner.length-1;i>=0;i--){ tempHighestUnlockPartner.push(hero.highestUnlockPartner[i]); } } for(let i=0;i<tempHighestUnlockPartner.length;i++){ let partnerId = tempHighestUnlockPartner[i].id; let highestUnlockPartner = tempHighestUnlockPartner[i]; let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); let partnerStatus = ''; let disableSaveButton = 'disabled'; let hiddenSaveButton = ''; let hiddenActivateButton = ''; let textActivateAbility = ''; let activeBgColor = 'active-bg-color'; let showMenuButton = 'hide-menu'; let abilityArea = 'd-none'; let iconPoint = 'd-none'; let trainingTimeClass = 'd-none'; if( !$( "#barracks-partner-area-" + partnerId ).length){ if(unlockPartner){ appendBarracksDiv += '<div id="barracks-partner-area-' + partnerId + '" class="row border-top rounded-card cursor-button pb-0">'; appendBarracksDiv += '<div id="ability-header-' + partnerId + '" class="row col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 pb-1 ability-menu">'; appendBarracksDiv += '<div class="col-xl-11 col-lg-11 col-md-11 col-sm-11 col-11 v-center-flex font-weight-bolder">'; appendBarracksDiv += '<img src="assets/images/' + partnerData.type.toLowerCase() + '.svg" class="image-size-static"></img>&nbsp;' + partnerData.name ; appendBarracksDiv += '&nbsp;&nbsp;&nbsp;<img id="partner-status-image-'+partnerId+'" src="assets/images/' + highestUnlockPartner.status.toLowerCase() + '.svg" class="image-size-static">&nbsp;'; appendBarracksDiv += '<span id="partner-status-text-'+partnerId+'">'+unlockPartner.status+'</span>'; appendBarracksDiv += '</div>'; appendBarracksDiv += '<div id="show-hide-menu-'+partnerId+'" class="col-xl-1 col-lg-1 col-md-1 col-sm-1 col-1 ' + showMenuButton + '"></div>'; appendBarracksDiv += '</div>'; if(highestUnlockPartner.ability.length > 0){ for(let a=0;a<highestUnlockPartner.ability.length;a++){ let unlockPartnerAbility = highestUnlockPartner.ability[a]; let abilityId = unlockPartnerAbility.abilityId; disableSaveButton = 'disabled'; hiddenSaveButton = ''; hiddenActivateButton = ''; let partnerAbilityData = partnerAbility.find(item => item.id === unlockPartnerAbility.abilityId); let abilityTypeData = abilityType.find(item => item.id === partnerAbilityData.abilityTypeId); if(unlockPartnerAbility.abilityPoint != unlockPartnerAbility.tempAbilityPoint){ disableSaveButton = ''; hiddenSaveButton = ''; hiddenActivateButton = 'd-none'; }else{ hiddenSaveButton = 'd-none'; hiddenActivateButton = ''; } if(unlockPartnerAbility.isActive){ textActivateAbility = 'Deactivate'; activeBgColor = 'active-bg-color'; }else{ textActivateAbility = 'Activate'; activeBgColor = ''; } if(unlockPartnerAbility.abilityPoint > 0) iconPoint = ''; else iconPoint = 'd-none'; if(unlockPartnerAbility.trainingTime > 0) trainingTimeClass = ''; else trainingTimeClass = 'd-none'; appendBarracksDiv += '<div id="ability-partner-title-'+partnerId+'-'+abilityId+'" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 py-1 border-top-only v-center-grid ' + activeBgColor + '">'; appendBarracksDiv += '<img src="assets/images/' + abilityTypeData.name.charAt(0).toLowerCase() + '.svg" class="image-size-static">&nbsp;'; appendBarracksDiv += '(' + abilityTypeData.name + ')&nbsp;' + partnerAbilityData.name + ' Lv&nbsp;'; appendBarracksDiv += '<span id="ability-partner-level-'+partnerId+'-'+abilityId+'">' + unlockPartnerAbility.abilityLevel + '</span> /&nbsp;<span id="ability-partner-max-level-'+partnerId+'-'+abilityId+'">' + unlockPartnerAbility.maxLevel + '</span>'; appendBarracksDiv += '&nbsp;&nbsp;<img id="icon-point-'+partnerId+'-'+abilityId+'" src="assets/images/upgrade.svg" class="image-size-2-static '+iconPoint+'"></img>'; if(unlockPartnerAbility.newAbility) appendBarracksDiv += '&nbsp;&nbsp;<img id="icon-new-'+partnerId+'-'+abilityId+'" src="assets/images/new.svg" class="image-size-2-static"></img>'; appendBarracksDiv += '</div>'; appendBarracksDiv += '<div id="ability-partner-area-'+partnerId+'-'+abilityId+'" class="row col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 ' + activeBgColor + ' ' + abilityArea + '">'; appendBarracksDiv += '<div class="col-xl-6 col-lg-6 col-md-6 col-sm-6 col-12 v-center-grid my-1">Accuracy : '; appendBarracksDiv += '<button id="acc-minus-'+partnerId+'-'+abilityId+'" class="down-count btn-info" title="Down" value="'+partnerId+'='+abilityId+'=acc=minus">-</button>'; appendBarracksDiv += '<span id="acc-counter-'+partnerId+'-'+abilityId+'">'+unlockPartnerAbility.accuracy +'</span>%'; appendBarracksDiv += '<button id="acc-plus-'+partnerId+'-'+abilityId+'" class="up-count btn-info" title="Up" value="'+partnerId+'='+abilityId+'=acc=plus">+</button>'; appendBarracksDiv += '</div>'; appendBarracksDiv += '<div class="col-xl-6 col-lg-6 col-md-6 col-sm-6 col-12 v-center-grid my-1">Damage : '; appendBarracksDiv += '<button id="dam-minus-'+partnerId+'-'+abilityId+'" class="down-count btn-info" title="Down" value="'+partnerId+'='+abilityId+'=dam=minus">-</button>'; appendBarracksDiv += '<span id="dam-counter-'+partnerId+'-'+abilityId+'">'+unlockPartnerAbility.damage +'</span>%'; appendBarracksDiv += '<button id="dam-plus-'+partnerId+'-'+abilityId+'" class="up-count btn-info" title="Up" value="'+partnerId+'='+abilityId+'=dam=plus">+</button>'; appendBarracksDiv += '</div>'; appendBarracksDiv += '<div class="col-xl-6 col-lg-6 col-md-6 col-sm-6 col-12 v-center-flex my-1">Interval : ' + unlockPartnerAbility.interval + '</div>'; appendBarracksDiv += '<div class="col-xl-6 col-lg-6 col-md-6 col-sm-6 col-12 v-center-flex my-1">Point :&nbsp;'; appendBarracksDiv += '<span id="ability-point-'+partnerId+'-'+abilityId+'">'+unlockPartnerAbility.abilityPoint + '</span></div>'; appendBarracksDiv += '<div id="training-time-div-'+partnerId+'-'+abilityId+'" class="col-xl-6 col-lg-6 col-md-6 col-sm-6 col-12 v-center-flex my-1 '+trainingTimeClass+'">Training Time :&nbsp;'; appendBarracksDiv += '<span id="training-time-text-'+partnerId+'-'+abilityId+'">'+offlineTimeText(unlockPartnerAbility.trainingTime) + '</span></div>'; appendBarracksDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 animate-bar no-padding">'; appendBarracksDiv += '<div class="progress-bar-div">'; appendBarracksDiv += '<span id="ability-exp-'+partnerId+'-'+ abilityId + '">' + numberFormat(unlockPartnerAbility.exp) + '</span> / <span id="ability-max-exp-'+partnerId+'-'+abilityId + '">'+ numberFormat(unlockPartnerAbility.maxExp)+ '</span>'; appendBarracksDiv += '</div>'; appendBarracksDiv += '<div id="ability-bar-'+partnerId+'-'+ abilityId + '" class="progress-bar ability-progress-bar-color">&nbsp;</div>'; appendBarracksDiv += '</div>'; appendBarracksDiv += '<div class="col-xl-6 col-lg-6 col-md-6 col-sm-6 col-12 px-0">'; appendBarracksDiv += '<button id="save-ability-partner-button-' + partnerId + '-' + abilityId + '" class="upgrade-level-button mt-1 save-ability ' + hiddenSaveButton + '" value="' + partnerId + '=' + abilityId + '"' + disableSaveButton + ' >Save</button>'; appendBarracksDiv += '</div>'; appendBarracksDiv += '<div class="col-xl-6 col-lg-6 col-md-6 col-sm-6 col-12 px-0 mb-1">'; appendBarracksDiv += '<button id="activate-ability-partner-button-' + partnerId + '-' + abilityId + '" class="upgrade-level-button mt-1 activate-ability ' + hiddenActivateButton + '" value="' + partnerId + '=' + abilityId + '">'; appendBarracksDiv += '<span id="activate-ability-partner-text-' + partnerId + '-' + abilityId + '">'+textActivateAbility+'</span>'; appendBarracksDiv += '</button>'; appendBarracksDiv += '</div>'; appendBarracksDiv += '</div>'; } if(highestUnlockPartner.ability.length < 4){ let unlockPartnerAbility = highestUnlockPartner.ability[highestUnlockPartner.ability.length-1]; let partnerAbilityData = partnerAbility.find(item => item.id === unlockPartnerAbility.abilityId); appendBarracksDiv += '<div id="unlock-ability-partner-'+partnerId+'" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 py-1 border-top-only v-center-grid unlock-info">'; appendBarracksDiv += 'Unlock New Ability at '+partnerAbilityData.name+' lv '+setting.reqLevelUnlockNewAbility; appendBarracksDiv += '</div>'; } appendBarracksDiv += '</div>'; } appendBarracksDiv += '</div>'; } }else{ componentAction("partner-status-text-"+partnerId,"replaceText",unlockPartner.status); $("#partner-status-image-"+partnerId).attr("src", "assets/images/"+unlockPartner.status+".svg"); if(highestUnlockPartner.ability.length > 0){ for(let a=0;a<highestUnlockPartner.ability.length;a++){ let unlockPartnerAbility = highestUnlockPartner.ability[a]; let abilityId = unlockPartnerAbility.abilityId; if(unlockPartnerAbility.isActive){ textActivateAbility = 'Deactivate'; componentAction("ability-partner-title-"+partnerId+"-"+abilityId, "addClass", "active-bg-color"); componentAction("ability-partner-area-"+partnerId+"-"+abilityId, "addClass", "active-bg-color"); }else{ textActivateAbility = 'Activate'; componentAction("ability-partner-title-"+partnerId+"-"+abilityId, "removeClass", "active-bg-color"); componentAction("ability-partner-area-"+partnerId+"-"+abilityId, "removeClass", "active-bg-color"); } let currentAccCounter = $('#acc-counter-'+partnerId+'-'+abilityId).css("fontWeight"); let currentDamCounter = $('#dam-counter-'+partnerId+'-'+abilityId).css("fontWeight"); /*700 = bold, 400 = normal*/ if(currentAccCounter == 400 && currentDamCounter == 400){ if(unlockPartnerAbility.abilityPoint != unlockPartnerAbility.tempAbilityPoint){ $("#save-ability-partner-button-" + partnerId + "-" + abilityId).prop('disabled', false); componentAction("save-ability-partner-button-"+partnerId+"-"+abilityId, "removeClass", "d-none"); componentAction("activate-ability-partner-button-"+partnerId+"-"+abilityId, "addClass", "d-none"); }else{ $("#save-ability-partner-button-" + partnerId + "-" + abilityId).prop('disabled', true); componentAction("save-ability-partner-button-"+partnerId+"-"+abilityId, "addClass", "d-none"); componentAction("activate-ability-partner-button-"+partnerId+"-"+abilityId, "removeClass", "d-none"); } componentAction("ability-point-"+partnerId+"-"+abilityId, "replaceText", unlockPartnerAbility.abilityPoint); } if(unlockPartnerAbility.abilityPoint > 0) componentAction("icon-point-"+partnerId+"-"+abilityId, "removeClass", "d-none"); else componentAction("icon-point-"+partnerId+"-"+abilityId, "addClass", "d-none"); if($("#icon-new-"+partnerId+"-"+abilityId).length){ if(unlockPartnerAbility.newAbility) componentAction("icon-new-"+partnerId+"-"+abilityId, "removeClass", "d-none"); else componentAction("icon-new-"+partnerId+"-"+abilityId, "addClass", "d-none"); } if(unlockPartnerAbility.trainingTime > 0){ componentAction("training-time-div-"+partnerId+"-"+abilityId, "removeClass", "d-none"); componentAction("training-time-text-"+partnerId+"-"+abilityId, "replaceText", offlineTimeText(unlockPartnerAbility.trainingTime)); }else componentAction("training-time-div-"+partnerId+"-"+abilityId, "addClass", "d-none"); componentAction("ability-partner-level-"+partnerId+"-"+abilityId,"replaceText",unlockPartnerAbility.abilityLevel); componentAction("ability-partner-max-level-"+partnerId+"-"+abilityId,"replaceText",unlockPartnerAbility.maxLevel); componentAction("activate-ability-partner-text-"+partnerId+"-"+abilityId, "replaceText", textActivateAbility); componentAction("ability-exp-"+partnerId+"-"+abilityId, "replaceText", unlockPartnerAbility.exp); componentAction("ability-max-exp-"+partnerId+"-"+abilityId, "replaceText", unlockPartnerAbility.maxExp); let newAbilityBar = unlockPartnerAbility.exp / unlockPartnerAbility.maxExp * 100; if(newAbilityBar > 100) newAbilityBar = 100; componentAction ("ability-bar-"+partnerId+"-"+abilityId, "animate", newAbilityBar); } } } } if(appendBarracksDiv != ""){ if(hero.settingOrderPartner == "asc"){ $("#barracks-area-div").append(appendBarracksDiv).off('click','.down-count').on('click','.down-count',function(){ actionCounterValue(this); }).off('click','.up-count').on('click','.up-count',function(){ actionCounterValue(this); }).off('click','.save-ability').on('click','.save-ability',function(){ confirmSaveAbilityPartner(this); }).off('click','.activate-ability').on('click', '.activate-ability',function(){ confirmActivateAbility(this); }).off('click','.ability-menu').on('click', '.ability-menu',function(){ showHideAbility(this); }); }else{ $("#barracks-area-div").prepend(appendBarracksDiv).off('click','.down-count').on('click','.down-count',function(){ actionCounterValue(this); }).off('click','.up-count').on('click','.up-count',function(){ actionCounterValue(this); }).off('click','.save-ability').on('click','.save-ability',function(){ confirmSaveAbilityPartner(this); }).off('click','.activate-ability').on('click', '.activate-ability',function(){ confirmActivateAbility(this); }).off('click','.ability-menu').on('click', '.ability-menu',function(){ showHideAbility(this); }); } for(let i=0;i<hero.highestUnlockPartner.length;i++){ let partnerId = hero.highestUnlockPartner[i].id; let highestUnlockPartner = hero.highestUnlockPartner[i]; for(let a=0;a<highestUnlockPartner.ability.length;a++){ let unlockPartnerAbility = highestUnlockPartner.ability[a]; let abilityId = unlockPartnerAbility.abilityId; let newAbilityBar = unlockPartnerAbility.exp / unlockPartnerAbility.maxExp * 100; if(newAbilityBar > 100) newAbilityBar = 100; componentAction ("ability-bar-"+partnerId+"-"+abilityId, "animate", newAbilityBar); } } } }else{ if( !$("#ability-unlock-div").length){ let unlockInformation = "Unlock this barracks at floor "+setting.unlockReqFloorBarracks; let appendBarracksDiv = '<div id="ability-unlock-div" class="rounded-card middle-align unlock-info">' + unlockInformation + '</div>'; $("#barracks-area-div").append(appendBarracksDiv); } } calcHeightScrollDiv("barracks"); }; var showTrainingArea = function(){ showBarracksTab('training'); if(hero.highestFloor >= setting.unlockReqFloorBarracks){ if( !$("#training-area").length){ $("#training-unlock-div").empty(); let appendTrainingDiv = '<div id="training-area" class="row border-top rounded-card">'; appendTrainingDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 middle-align">'; appendTrainingDiv += '<img src="assets/images/barracks-color.svg" class="barracks-img"></img>'; appendTrainingDiv += '</div>'; for(let i=0;i<hero.activeTrainingSlot;i++){ let slotName = i + 1; let disableButton = ''; let trainingText = 'Training Slot '+slotName; let trainingDesc = ''; let buttonText = 'Click To Choose Partner'; let classButtonTraining = ''; let trainingZone = hero.trainingZone.trainingSlot.find(item => item.slotId === i); appendTrainingDiv += '<div id="training-slot-' + i + '" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 row mt-1 m-0 rounded-card">'; appendTrainingDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">' + trainingText + '</div>'; if(trainingZone){ if(trainingZone.interval >= 0) clearTimeout(trainingZone.interval); let abilityId = trainingZone.abilityId; let partnerId = trainingZone.partnerId; let startTraining = trainingZone.startTraining; let partnerData = partner.find(item => item.id === partnerId); let partnerAbilityData = partnerAbility.find(item => item.id === abilityId); let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let unlockAbilityPartner = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); let arrayValue = partnerId+"="+abilityId+"="+i; let totalTrainingTime = 0; let restTrainingTime = 0; classButtonTraining = 'skill-running'; if(unlockAbilityPartner){ restTrainingTime = calcRestTimeTraining(unlockAbilityPartner.maxLevel); let trainingTime = unlockAbilityPartner.trainingTime; totalTrainingTime = trainingTime + Math.ceil((Date.now() - startTraining)/1000); restTrainingTime = restTrainingTime - totalTrainingTime; } if(restTrainingTime > 0)startTrainingTimer(i); trainingDesc = "On progress training "+partnerAbilityData.name+" ability for "+partnerData.name+" partner"; appendTrainingDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">' + trainingDesc + '</div>'; appendTrainingDiv += '<div id="button-training-div-'+i+'" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'; appendTrainingDiv += '<button id="stop-training-button-' + i + '" class="upgrade-level-button mt-2 training-button ' + classButtonTraining + '" value="' + i + '">Stop Training - '; appendTrainingDiv += '<span id="training-ability-timer-' + i + '">' + offlineTimeText(restTrainingTime) + '</span>'; appendTrainingDiv += '</button>'; appendTrainingDiv += '*Click button to stop training. All training times that have been running are still counted.'; appendTrainingDiv += '</div>'; }else{ appendTrainingDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'; appendTrainingDiv += '<button id="training-button-' + i + '" class="upgrade-level-button training-button"' + disableButton + ' value="' + i + '"><span id="training-text-' + i + '">' + buttonText + '</span></button>'; appendTrainingDiv += '</div>'; appendTrainingDiv += '<div id="list-partner-div-'+i+'" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 d-none"></div>'; appendTrainingDiv += '<div id="list-ability-div-'+i+'" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 d-none"></div>'; appendTrainingDiv += '<div id="button-training-div-'+i+'" class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 d-none"></div>'; } appendTrainingDiv += '</div>'; } appendTrainingDiv += '</div>'; $("#training-area-div").append(appendTrainingDiv).off('click','.training-button').on('click','.training-button',function(){ chooseTrainingPartner(this); }); } }else{ if( !$("#training-unlock-div").length){ let unlockInformation = "Unlock this training ground at floor "+setting.unlockReqFloorBarracks; let appendBarracksDiv = '<div id="training-unlock-div" class="rounded-card middle-align unlock-info">' + unlockInformation + '</div>'; $("#training-area-div").append(appendBarracksDiv); } } calcHeightScrollDiv("barracks"); }; var calcRestTimeTraining = function(maxLevel){ return Math.ceil(setting.baseTrainingAbilityHour * 3600 * Math.ceil(maxLevel/100)); }; var startTrainingTimer = function(trainingSlot){ let trainingZone = hero.trainingZone.trainingSlot.find(item => item.slotId === trainingSlot); let abilityId = trainingZone.abilityId; let partnerId = trainingZone.partnerId; let startTraining = trainingZone.startTraining; let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let unlockAbilityPartner = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); let restTrainingTime = calcRestTimeTraining(unlockAbilityPartner.maxLevel); let trainingTime = unlockAbilityPartner.trainingTime; let totalTrainingTime = trainingTime + Math.floor((Date.now() - startTraining)/1000); restTrainingTime = restTrainingTime - totalTrainingTime; let interval = 0; if(restTrainingTime > 3630) interval = 30000; else if(restTrainingTime > 0) interval = 1000; if(interval > 0){ componentAction("training-ability-timer-"+trainingSlot,"replaceText",offlineTimeText(restTrainingTime)); let trainingInterval = setTimeout(startTrainingTimer,interval,trainingSlot); trainingZone.interval = trainingInterval; }else{ clearTimeout(trainingZone.interval); unlockAbilityPartner.maxLevel += 100; unlockAbilityPartner.trainingTime = 0; if(hero.settingAutoAbilityTraining){ let trainingInterval = setTimeout(startTrainingTimer,interval,trainingSlot); trainingZone.interval = trainingInterval; trainingZone.startTraining = Date.now(); }else stopTrainingAbility(partnerId+"="+abilityId+"="+trainingSlot,true); } }; var showPetArea = function(selectedZoneId=-1,selectedSlotId=-1){ let unlockReqText = ''; let isReachReqFloor = true; let nextUnlockPet = 0; checkCooldownAdventureTimer(); showPetTab('pet'); if( $( "#selected-area").length) $( "#selected-area").remove(); if(selectedZoneId >= 0 && selectedSlotId >= 0){ let zoneData = zone.find(item => item.id === selectedZoneId); let unlockZone = hero.unlockZone.find(item => item.id === selectedZoneId); let totalUpgradeReqCount = unlockZone.level * zoneData.baseUpgradeReq; if( $("#pet-area-div").length) $("#pet-area-div").empty(); let appendAdventureDiv = '<div id="selected-area" class="row border-top rounded-card tab-active">'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += zoneData.name + ' Lv ' + unlockZone.level +' (' + zoneData.adventureTime + ' Hour)'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">' + zoneData.description + '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 animate-bar no-padding">'; appendAdventureDiv += '<div class="progress-bar-div">'; appendAdventureDiv += 'Exp : ' + unlockZone.adventureCount + ' / '+ totalUpgradeReqCount+''; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div id="selected-adventure-exp-bar" class="progress-bar pet-progress-bar-color">&nbsp;</div>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Adventure Slot : ' + setSequenceName(selectedSlotId) + ' Pet Slot'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Bonus Coin : ' + numberFormat(unlockZone.bonusCoin) + ' Coin'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Exp Gain : ' + numberFormat(unlockZone.bonusExp) + ' Exp'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 unlock-info">Please Choose Below Pet to Start ' + zoneData.name + ' Adventure'; $("#pet-area-div").append(appendAdventureDiv); let newAdventureExpBar = unlockZone.adventureCount / totalUpgradeReqCount * 100; componentAction ("selected-adventure-exp-bar", "animate", newAdventureExpBar); } for(let i = 0; i<pet.length; i++){ let petData = pet.find(item => item.id === i); let unlockPet = hero.unlockPet.find(item => item.id === i); let totalUpgradeReqExp = 0; let petDescription = ''; let newPetExpBar = 0; let classButtonAdventure = ''; let disableButtonAdventure = ''; let hyphenName = ''; let slotName = ''; let noteButtonAdventure = ''; let slotId = selectedSlotId; let zoneId = selectedZoneId; if(unlockPet){ totalUpgradeReqExp = unlockPet.level * petData.upgradeReqExp; if(i >= 3){ let partnerId = i - 3; let partnerData = partner.find(item => item.id === partnerId); petDescription = petData.description + ' ' + partnerData.name + ' ' + unlockPet.currBonus + ' ' + petData.unit; }else petDescription = petData.description + ' ' + unlockPet.currBonus + ' ' + petData.unit; newPetExpBar = unlockPet.currExp / totalUpgradeReqExp * 100; } if($( "#pet-area-" + i ).length) nextUnlockPet++; if( !$( "#pet-area-" + i ).length){ if(unlockPet){ if($("#pet-unlock-div-"+i).length) $("#pet-unlock-div-"+i).remove(); let appendPetDiv = '<div id="pet-area-' + i + '" class="row border-top rounded-card">'; appendPetDiv += '<div class="col-xl-3 col-lg-3 col-md-3 col-sm-12 col-12 v-center-flex">'; appendPetDiv += petData.name + '&nbsp;Lv&nbsp;<span id="pet-level-' + i + '">' + unlockPet.level + '</span>'; appendPetDiv += '</div>'; appendPetDiv += '<div class="col-xl-5 col-lg-5 col-md-5 col-sm-12 col-12 v-center-flex">'; appendPetDiv += '<span id="pet-desc-' + i + '">' + petDescription + ' </span>&nbsp;(+<span id="next-pet-damage-' + i + '">' + petData.multiplierBonus + '</span>)'; appendPetDiv += '</div>'; appendPetDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 animate-bar no-padding">'; appendPetDiv += '<div class="progress-bar-div">'; appendPetDiv += 'Exp : <span id="current-pet-exp-' + i + '">' + unlockPet.currExp + '</span> / <span id="max-pet-exp-' + i + '">'+ totalUpgradeReqExp+'</span>'; appendPetDiv += '</div>'; appendPetDiv += '<div id="pet-exp-bar-' + i + '" class="progress-bar pet-progress-bar-color">&nbsp;</div>'; appendPetDiv += '</div>'; appendPetDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 no-padding mt-1">'; if(unlockPet.adventureSlot >= 0 && unlockPet.adventureZone >= 0){ if(unlockPet.statusAdventure == 'running' || unlockPet.statusAdventure == 'cancel' || (unlockPet.statusAdventure == 'complete' && unlockPet.collectReward == '')){ disableButtonAdventure = 'disabled'; if(unlockPet.statusAdventure == 'running'){ noteButtonAdventure = constNoteCancelAdventure; disableButtonAdventure = ''; classButtonAdventure = 'skill-running'; }else if(unlockPet.statusAdventure == 'cancel'){ classButtonAdventure = 'skill-disabled'; } let cooldownTimer = calcCooldownAdventureTime(unlockPet.adventureZone, unlockPet.adventureSlot); hyphenName = '-'; slotName = offlineTimeText(cooldownTimer); }else{ classButtonAdventure = 'collect-reward'; hyphenName = '-'; slotName = 'Collect Reward'; } zoneId = unlockPet.adventureZone; slotId = unlockPet.adventureSlot; }else{ if(zoneId >= 0 && slotId >= 0){ classButtonAdventure = 'skill-active'; slotName = 'Slot '+(slotId+1); }else{ classButtonAdventure = ''; hyphenName = ''; slotName = ''; } } appendPetDiv += '<button id="button-pet-adventure-' + i +'" class="upgrade-level-button '+classButtonAdventure+'" value="' + zoneId + '='+ slotId + '=' + i +'" ' + disableButtonAdventure + '>Adventure <span id="pet-adventure-name-' + i +'">' + petData.name + '</span> <span id="hyphen-' + i +'">'+hyphenName+'</span> <span id="slot-adventure-name-' + i +'">'+slotName+'</span></button>'; appendPetDiv += '</div>'; appendPetDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 no-padding"><span id="note-button-pet-adventure-' + i +'">' + noteButtonAdventure + '</span></div>'; appendPetDiv += '</div>'; appendPetDiv += '</div>'; $("#pet-area-div").append(appendPetDiv).off('click','#button-pet-adventure-'+i).on('click','#button-pet-adventure-'+i,function(){ chooseAdventureArea(this); }); }else{ unlockReqText = 'Unlock this pet at floor '+petData.unlockReqFloor; switch(i){ case 1: if(hero.highestFloor < petData.unlockReqFloor){ unlockReqText += ' and have unlock a weapon once'; nextUnlockPet++; }else{ unlockReqText = 'Unlock this pet if you have unlock a weapon once'; } break; default: if(i >= 3){ let partnerId = i - 3; let partnerData = partner.find(item => item.id === partnerId); if(hero.highestFloor < petData.unlockReqFloor){ unlockReqText += ' and you have unlock partner ' + partnerData.name + ' once'; nextUnlockPet++; }else{ unlockReqText = 'Unlock this pet if you have unlock partner ' + partnerData.name + ' once'; } }else{ if(hero.highestFloor < petData.unlockReqFloor)nextUnlockPet++; } break; } if(nextUnlockPet > 1)isReachReqFloor = false; if(isReachReqFloor){ if(nextUnlockPet <= 1){ if( !$( "#pet-unlock-div-" + i ).length){ let appendPetDiv = '<div id="pet-unlock-div-'+i+'" class="rounded-card unlock-info middle-align">' + unlockReqText + '</div>'; appendPetDiv += '<div id="pet-area-' + i + '" class="row border-top rounded-card d-none"></div>'; $("#pet-area-div").append(appendPetDiv); }else componentAction ("pet-unlock-div-"+i, "replaceText", unlockReqText); if(nextUnlockPet == 1)i = pet.length; } } } }else{ if(unlockPet){ componentAction ("pet-level-"+i, "replaceText", unlockPet.level); componentAction ("current-pet-exp-"+i, "replaceText", unlockPet.currExp); componentAction ("max-pet-exp-"+i, "replaceText", totalUpgradeReqExp); componentAction ("pet-desc-"+i, "replaceText", petDescription); componentAction ("pet-adventure-name-"+i, "replaceText", petData.name); if(unlockPet.adventureSlot >= 0 && unlockPet.adventureZone >= 0){ if(unlockPet.statusAdventure == 'running' || (unlockPet.statusAdventure == 'complete' && unlockPet.collectReward == '')){ let cooldownTimer = calcCooldownAdventureTime(unlockPet.adventureZone, unlockPet.adventureSlot); if(unlockPet.statusAdventure == 'running'){ $("#button-pet-adventure-"+i).prop('disabled', false); }else $("button-pet-adventure-"+i).prop('disabled', true); updateAdventureButtonClass("button-pet-adventure-"+i, "skill-running"); hyphenName = '-'; slotName = offlineTimeText(cooldownTimer); }else{ if(unlockPet.statusAdventure == 'cancel'){ let cooldownTimer = calcCooldownAdventureTime(unlockPet.adventureZone, unlockPet.adventureSlot); updateAdventureButtonClass("button-pet-adventure-"+i, "skill-disabled"); slotName = offlineTimeText(cooldownTimer); }else{ updateAdventureButtonClass("button-pet-adventure-"+i,"collect-reward"); slotName = 'Collect Reward'; } hyphenName = '-'; } zoneId = unlockPet.adventureZone; slotId = unlockPet.adventureSlot; componentAction ("button-pet-adventure-"+i, "inputText", (zoneId + '='+ slotId + '=' + i)); }else{ componentAction ("button-pet-adventure-"+i, "inputText", (zoneId + '='+ slotId + '=' + i)); if(zoneId >= 0 && slotId >= 0){ updateAdventureButtonClass("button-pet-adventure-"+i,"skill-active"); slotName = 'Slot '+(slotId+1); }else{ updateAdventureButtonClass("button-pet-adventure-"+i,""); classButtonAdventure = ''; hyphenName = ''; slotName = ''; } } componentAction ("hyphen-"+i, "replaceText", hyphenName); componentAction ("slot-adventure-name-"+i, "replaceText", slotName); } } componentAction ("pet-exp-bar-"+i, "animate", newPetExpBar); } if(setting.petAreaShow == 1){ componentAction ("pet-area-div", "removeClass", "d-none"); setting.petAreaShow = 1; } calcHeightScrollDiv("pet"); }; var showAdventureArea = function(selectedPetId=-1){ let nextUnlockZone = 0; let selectedPetName = 'Pet'; let slotName = ''; let classButtonAdventure = ''; showPetTab('area'); if($("#zone-unlock-div").length) $("#zone-unlock-div").remove(); if($("#selected-pet").length) $("#selected-pet").remove(); if(selectedPetId >= 0){ let petData = pet.find(item => item.id === selectedPetId); let unlockPet = hero.unlockPet.find(item => item.id === selectedPetId); if( $("#adventure-area-div").length) $("#adventure-area-div").empty(); let totalUpgradeReqExp = unlockPet.level * petData.upgradeReqExp; let appendSelectedPet = '<div id="selected-pet" class="row border-top rounded-card tab-active">'; appendSelectedPet += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendSelectedPet += petData.name + ' Lv ' + unlockPet.level; appendSelectedPet += '</div>'; appendSelectedPet += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendSelectedPet += petData.description + ' ' + unlockPet.currBonus + ' ' + petData.unit + ' (+' + petData.multiplierBonus + ')'; appendSelectedPet += '</div>'; appendSelectedPet += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 pet-exp no-padding">'; appendSelectedPet += '<div class="progress-bar-div">'; appendSelectedPet += 'Exp : ' + unlockPet.currExp + ' / '+ totalUpgradeReqExp; appendSelectedPet += '</div>'; appendSelectedPet += '<div id="selected-pet-exp-bar" class="progress-bar pet-progress-bar-color">&nbsp;</div>'; appendSelectedPet += '</div>'; appendSelectedPet += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 unlock-info">Please Choose Below Adventure Area to Start ' + petData.name + ' Adventure'; appendSelectedPet += '</div>'; $("#adventure-area-div").append(appendSelectedPet); let newPetExpBar = unlockPet.currExp / totalUpgradeReqExp * 100; componentAction ("selected-pet-exp-bar", "animate", newPetExpBar); } for(let i=0;i<hero.countZone;i++){ let zoneData = zone.find(item => item.id === i); let unlockZone = hero.unlockZone.find(item => item.id === i); let totalUpgradeReqCount = unlockZone.level * zoneData.baseUpgradeReq; let petId = selectedPetId; let petName = selectedPetName; let percentAdventureExp = new Decimal(100).plus(hero.bonusAdventureExpPercentage); let percentAdventureCoin = new Decimal(100).plus(hero.bonusAdventureCoinPercentage).plus(hero.bonusAllCoinPercentage); let adventureExp = new Decimal(unlockZone.bonusExp).mul(percentAdventureExp).div(100); let adventureCoin = new Decimal(unlockZone.bonusCoin).mul(percentAdventureCoin).div(100); let adventureTime = zoneData.adventureTime * 3600 * (100 - hero.bonusAdventureTimePercentage) / 100; let noteButtonAdventure = ''; let disabledButton = ''; if(petId >= 0){ let petData = pet.find(item => item.id === petId); selectedPetName = petData.name; classButtonAdventure = 'skill-active'; }else{ selectedPetName = 'Pet'; classButtonAdventure = ''; petId = -1; } if(!$("#adventure-area-"+i).length){ if(unlockZone){ if($("#zone-unlock-div-"+i).length) $("#zone-unlock-div-"+i).remove(); let appendAdventureDiv = '<div id="adventure-area-' + i + '" class="row border-top rounded-card">'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += zoneData.name + ' Lv <span id="adventure-level-' + i + '">' + unlockZone.level +'</span> (<span id="adventure-time-' + i + '">' + offlineTimeText(adventureTime) + '</span>)'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += '<span id="adventure-desc-' + i + '">' + zoneData.description + ' </span>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 pet-exp no-padding">'; appendAdventureDiv += '<div class="progress-bar-div">'; appendAdventureDiv += 'Exp : <span id="current-adventure-count-' + i + '">' + unlockZone.adventureCount + '</span> / <span id="max-adventure-count-' + i + '">'+ totalUpgradeReqCount+'</span>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div id="adventure-exp-bar-' + i + '" class="progress-bar pet-progress-bar-color">&nbsp;</div>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Adventure Slot : <span id="adventure-slot-' + i + '">' + unlockZone.currSlot + '</span> Pet Slot'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Bonus Coin : <span id="adventure-coin-' + i + '">' + numberFormat(adventureCoin) + '</span> Coin'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12">'; appendAdventureDiv += 'Exp Gain : <span id="adventure-exp-' + i + '">' + numberFormat(adventureExp) + '</span> Exp'; appendAdventureDiv += '</div>'; appendAdventureDiv += '<div id="adventure-slot-' + i + '" class="col-xl-4 col-lg-4 col-md-4 col-sm-12 col-12 no-padding mt-2">'; for(let a=0;a<unlockZone.currSlot;a++){ let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === a); petId = selectedPetId; petName = selectedPetName; slotName = "Slot "+(a+1); if(unlockZoneSlot){ petId = unlockZoneSlot.petId; let petData = pet.find(item => item.id === petId); let cooldownTimer = calcCooldownAdventureTime(i, a); if(unlockZoneSlot.statusAdventure == 'running'){ noteButtonAdventure = constNoteCancelAdventure; classButtonAdventure = 'skill-running'; petName = petData.name; slotName = offlineTimeText(cooldownTimer); }else if(unlockZoneSlot.statusAdventure == 'complete'){ classButtonAdventure = 'collect-reward'; petName = 'Complete'; slotName = 'Collect Reward'; petId = unlockZoneSlot.petId; petName = petData.name; }else if(unlockZoneSlot.statusAdventure == 'cancel'){ classButtonAdventure = 'skill-disabled'; petName = petData.name; petId = unlockZoneSlot.petId; disabledButton = 'disabled'; slotName = offlineTimeText(cooldownTimer); } }else{ if(petId >= 0) classButtonAdventure = 'skill-active'; else classButtonAdventure = ''; } appendAdventureDiv += '<button id="button-adventure-slot-' + i + '-'+ a +'" class="upgrade-level-button adventure-slot-class '+classButtonAdventure+'" value="' + i + '='+ a + '=' + petId +'"' + disabledButton + '>Adventure <span id="adventure-pet-name-' + i + '-'+ a +'">' + petName + '</span> - <span id="adventure-slot-name-' + i + '-'+ a +'">' + slotName + '</span></button>'; } appendAdventureDiv += '</div>'; appendAdventureDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12 no-padding"><span id="note-button-adventure-slot-' + i +'">' + noteButtonAdventure + '</span></div>'; appendAdventureDiv += '</div>'; appendAdventureDiv += '</div>'; $("#adventure-area-div").append(appendAdventureDiv).off('click','.adventure-slot-class').on('click','.adventure-slot-class',function(){ insertAdventurePet(this); }); for(let a=0;a<unlockZone.currSlot;a++){ let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === a); if(unlockZoneSlot){ let statusAdventure = unlockZoneSlot.statusAdventure; let collectReward = unlockZoneSlot.collectReward; if(statusAdventure == 'running' || statusAdventure == 'cancel' || (statusAdventure == 'complete' && collectReward == ''))startCooldownAdventureTimer(unlockZoneSlot.petId, i, a); } } } }else{ let totalUpgradeReqCount = unlockZone.level * zoneData.baseUpgradeReq; let statusRunningAdventure = false; for(let a=0;a<unlockZone.currSlot;a++){ petId = selectedPetId; petName = selectedPetName; let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === a); if(!unlockZoneSlot){ if(petId >= 0) updateAdventureButtonClass("button-adventure-slot-"+i+"-"+a, "skill-active"); else updateAdventureButtonClass("button-adventure-slot-"+i+"-"+a, ""); }else{ if(unlockZoneSlot.statusAdventure == 'running'){ let cooldownTimer = calcCooldownAdventureTime(i, a); updateAdventureButtonClass("button-adventure-slot-"+i+"-"+a, "skill-running"); statusRunningAdventure = true; slotName = offlineTimeText(cooldownTimer); }else if(unlockZoneSlot.statusAdventure == 'complete'){ updateAdventureButtonClass("button-adventure-slot-"+i+"-"+a, "collect-reward"); slotName = "Collect Reward"; }else if(unlockZoneSlot.statusAdventure == 'cancel'){ updateAdventureButtonClass("button-adventure-slot-"+i+"-"+a, "skill-disabled"); let cooldownTimer = calcCooldownAdventureTime(i, a); slotName = offlineTimeText(cooldownTimer); } petId = unlockZoneSlot.petId; let petData = pet.find(item => item.id === petId); petName = petData.name; componentAction ("adventure-slot-name-"+i+"-"+a, "replaceText", slotName); } componentAction ("adventure-pet-name-"+i+"-"+a, "replaceText", petName); componentAction ("button-adventure-slot-"+i+"-"+a, "inputText", (i+'='+a+'='+petId)); } componentAction ("current-adventure-count-"+i, "replaceText", unlockZone.adventureCount); componentAction ("max-adventure-count-"+i, "replaceText", totalUpgradeReqCount); componentAction ("adventure-coin-"+i, "replaceText", adventureCoin); componentAction ("adventure-exp-"+i, "replaceText", adventureExp); componentAction ("adventure-slot-"+i, "replaceText", unlockZone.currSlot); componentAction ("adventure-level-"+i, "replaceText", unlockZone.level); componentAction ("adventure-time-"+i, "replaceText", offlineTimeText(adventureTime)); if(statusRunningAdventure) componentAction ("note-button-adventure-slot-"+i, "replaceText", constNoteCancelAdventure); } let newAdventureExpBar = unlockZone.adventureCount / totalUpgradeReqCount * 100; componentAction ("adventure-exp-bar-"+i, "animate", newAdventureExpBar); } if(hero.countZone < zone.length){ let unlockInformation = ''; let nextZoneRequirement = ''; if(hero.countZone > 0){ let prevZone = zone[hero.countZone-1]; let nextZone = zone[hero.countZone]; unlockInformation = 'Unlock Area at '+prevZone.name+' level '+nextZone.unlockReqLevel; }else{ let petData = pet.find(item => item.id === 0); unlockInformation = 'Unlock this area at floor '+petData.unlockReqFloor; } let appendZoneDiv = '<div id="zone-unlock-div" class="rounded-card middle-align unlock-info">' + unlockInformation + '</div>'; $("#adventure-area-div").append(appendZoneDiv); } calcHeightScrollDiv("pet"); }; var showTutorialArea = function(){ hideAllContent(); componentAction ("tutorial-div", "removeClass", "d-none"); componentAction ("tutorial", "updateClass", "cursor-button,active"); calcHeightScrollDiv("tutorial"); switchTutorPage(1); }; var showSettingArea = function(){ hideAllContent(); componentAction ("setting-div", "removeClass", "d-none"); componentAction ("setting", "updateClass", "cursor-button,active"); if(hero.settingOrderPartner == "asc"){ $("#partner-sequence-asc").prop('checked', true); $("#partner-sequence-desc").prop('checked', false); }else{ $("#partner-sequence-asc").prop('checked', false); $("#partner-sequence-desc").prop('checked', true); } if(hero.settingShowIcon){ $("#show-icon-true").prop('checked', true); $("#show-icon-false").prop('checked', false); }else{ $("#show-icon-true").prop('checked', false); $("#show-icon-false").prop('checked', true); } if(hero.settingFormatNumber == "number"){ $("#setting-format-number").prop('checked', true); $("#setting-format-letter").prop('checked', false); }else{ $("#setting-format-number").prop('checked', false); $("#setting-format-letter").prop('checked', true); } if(hero.settingAutoAbilityTraining){ $("#setting-ability-training-auto").prop('checked', true); $("#setting-ability-training-nonauto").prop('checked', false); }else{ $("#setting-ability-training-auto").prop('checked', false); $("#setting-ability-training-nonauto").prop('checked', true); } switch(hero.settingBackground){ case "light": $("#setting-background-light").prop('checked', true); $("#setting-background-grey").prop('checked', false); $("#setting-background-dark").prop('checked', false); break; case "grey": $("#setting-background-light").prop('checked', false); $("#setting-background-grey").prop('checked', true); $("#setting-background-dark").prop('checked', false); break; case "dark": $("#setting-background-light").prop('checked', false); $("#setting-background-grey").prop('checked', false); $("#setting-background-dark").prop('checked', true); break; }; calcHeightScrollDiv("setting"); }; var showExportImportArea = function(){ hideAllContent(); componentAction ("export-data", "replaceText", ""); componentAction ("export-import-div", "removeClass", "d-none"); componentAction ("export-import", "updateClass", "cursor-button,active"); calcHeightScrollDiv("export-import"); }; var calcHeightScrollDiv = function(headerName){ lastActiveMenu = headerName; let heightScreen = $(window).height(); let topBar = $("#sticky-topbar").height() + 10; let footBar = $("#sticky-footbar").height() + 30; let contentHeader = 0; if($("#"+headerName+"-header").length) contentHeader += $("#"+headerName+"-header").height() + 16; if($("#"+headerName+"-header2").length) contentHeader += $("#"+headerName+"-header2").height() + 16; if(headerName == "modal"){ contentHeader += 180; topBar = 0; footBar = 0; } let scrollHeight = heightScreen - topBar - footBar - contentHeader - 15; $('.pre-scrollable').css({"max-height":scrollHeight}); checkCssSetting(); }; var loopAction = function(showAnimation=false, newDpsInterval){ let totalDps = new Decimal(calcTotalDps()); let maxHpEnemy = new Decimal(enemy.maxHp); let firstDamage = new Decimal(hitGodsDamage()); let partnerAbilityDamage = new Decimal(calcTotalAbility()); if(stealCoinTimer > 0){ stealCoinInterval = new Decimal(stealCoinInterval).plus(newDpsInterval); if(stealCoinInterval.greaterThanOrEqualTo(stealCoinTimer)){ runStealCoin(); stealCoinInterval = new Decimal(0); } } if(dpcToCoinTimer > 0){ dpcToCoinInterval = new Decimal(dpcToCoinInterval).plus(newDpsInterval); if(dpcToCoinInterval.greaterThanOrEqualTo(dpcToCoinTimer)){ runDpcToCoin(); dpcToCoinInterval = new Decimal(0); } } if(dpsToCoinTimer > 0){ dpsToCoinInterval = new Decimal(dpsToCoinInterval).plus(newDpsInterval); if(dpsToCoinInterval.greaterThanOrEqualTo(dpsToCoinTimer)){ runDpsToCoin(totalDps); dpsToCoinInterval = new Decimal(0); } } currentEnemyHP = currentEnemyHP.sub(totalDps).sub(firstDamage).sub(partnerAbilityDamage); if(showAnimation){ let newHPBarWidth = new Decimal(currentEnemyHP).div(maxHpEnemy).mul(100); componentAction ("current-enemy-hp", "replaceText", numberFormat(currentEnemyHP)); componentAction ("progress-bar", "animate", newHPBarWidth); } checkAction(showAnimation); }; var checkLoopAction = function(newDpsInterval, interval, callback){ while(interval >= newDpsInterval){ loopAction(false, newDpsInterval); interval -= newDpsInterval; lastDpsHit += newDpsInterval; } lastDpsHit += newDpsInterval; loopAction(true, newDpsInterval); callback(); }; var loopDpsTimer = function(){ let newDpsInterval = 1000 - (hero.bonusIntervalDps*1); let interval = Date.now() - lastDpsHit; runBackgroundCalculation(true, function(){ checkLoopAction(newDpsInterval, interval, function(){ runBackgroundCalculation(false, function(){ dpsTimeout = setTimeout(loopDpsTimer, (newDpsInterval - interval)); }); }); }); }; var startDpsInterval = function(isClearTimeout=false){ if(isClearTimeout) dpsTimeout = clearTimeout(dpsTimeout); if(!dpsTimeout){ let heroDps = new Decimal(hero.dps); if(heroDps.greaterThan(0)){ lastDpsHit = Date.now(); loopDpsTimer(); }else dpsTimeout = clearTimeout(dpsTimeout); } }; var addCountSkillUsed = function(skillId){ let statisticSkill = hero.totalSkillUsed.find(item => item.id === skillId); if(statisticSkill) statisticSkill.count++; else{ let newObjSkillUsed = { id: skillId, count: 1 }; hero.totalSkillUsed.push(newObjSkillUsed); } }; var startAllSkill = function(){ for(let i=0;i<hero.unlockSkill.length;i++) if(!hero.unlockSkill[i].isActive && !hero.unlockSkill[i].isCooldown) useSkill(hero.unlockSkill[i].id); }; var startAutoClickerInterval = function (skillId){ let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let restDurationSkill = totalDurationSkill; let totalSkillDamage = new Decimal(unlockSkill.damage).plus(artifactSkillDamage(skillId)); let intervalSkill = new Decimal(1000).div(totalSkillDamage).floor(); if(autoClickerInterval || autoClickerDuration){ autoClickerInterval = clearInterval(autoClickerInterval); autoClickerDuration = clearInterval(autoClickerDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); hitDPC(); autoClickerDuration = setInterval (function (){ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); if(restDurationSkill.lessThanOrEqualTo(0)){ autoClickerDuration = clearInterval(autoClickerDuration); autoClickerInterval = clearInterval(autoClickerInterval); startCooldownSkill(skillId); } },1000); autoClickerInterval = setInterval(function() { hitDPC(); },intervalSkill); } }; var startPowerShotInterval = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let restDurationSkill = totalDurationSkill; if(powerShotDuration){ powerShotDuration = clearInterval(powerShotDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); powerShotDuration = setInterval (function (){ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); if(restDurationSkill.lessThanOrEqualTo(0)){ powerShotDuration = clearInterval(powerShotDuration); startCooldownSkill(skillId); initDisplay(); } },1000); initDisplay(); } }; var startSpecialForceInterval = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let restDurationSkill = totalDurationSkill; if(specialForceDuration){ specialForceDuration = clearInterval(specialForceDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); specialForceDuration = setInterval (function (){ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); if(restDurationSkill.lessThanOrEqualTo(0)){ specialForceDuration = clearInterval(specialForceDuration); startCooldownSkill(skillId); initDisplay(); } },1000); initDisplay(); } }; var startLuckyCoinInterval = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let restDurationSkill = totalDurationSkill; if(luckyCoinDuration){ luckyCoinDuration = clearInterval(luckyCoinDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); luckyCoinDuration = setInterval (function (){ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); if(restDurationSkill.lessThanOrEqualTo(0)){ luckyCoinDuration = clearInterval(luckyCoinDuration); startCooldownSkill(skillId); } },1000); } }; var loopBillionaire = function(){ let skillId = 4; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); let endSkillDateTime = unlockSkill.lastStartDatetime + (totalDurationSkill*1000); let newBillionaireInterval = new Decimal(1000); let interval = Date.now() - lastBillionaireHit; while(interval >= newBillionaireInterval){ runBillionaire(skillId); interval -= newBillionaireInterval; lastBillionaireHit += newBillionaireInterval*1; } if(lastBillionaireHit < endSkillDateTime){ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); runBillionaire(skillId); lastBillionaireHit += newBillionaireInterval*1; } if(restDurationSkill.lessThanOrEqualTo(0))startCooldownSkill(skillId); else billionaireTimeout = setTimeout(loopBillionaire, (newBillionaireInterval - interval)); }; var startBillionaireInterval = function (skillId){ let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let restDurationSkill = totalDurationSkill; if(billionaireTimeout){ billionaireTimeout = clearTimeout(billionaireTimeout); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); lastBillionaireHit = Date.now(); loopBillionaire(); } }; var loopGrimReaper = function(){ let skillId = 5; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId).mul(1000)); let endSkillDateTime = unlockSkill.lastStartDatetime + (totalDurationSkill*1000); let newGrimReaperInterval = new Decimal(5000).sub(hero.bonusIntervalGrimReaper); let interval = Date.now() - lastGrimReaperHit; while(interval >= newGrimReaperInterval){ runGrimReaper(skillId); interval -= newGrimReaperInterval; lastGrimReaperHit += newGrimReaperInterval*1; } if(lastGrimReaperHit < endSkillDateTime){ runGrimReaper(skillId); lastGrimReaperHit += newGrimReaperInterval*1; grimReaperTimeout = setTimeout(loopGrimReaper, (newGrimReaperInterval - interval)); } }; var startGrimReaperInterval = function (skillId){ let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalDurationSkill = new Decimal(unlockSkill.duration).plus(artifactSkillDuration(skillId)); let restDurationSkill = totalDurationSkill; if(grimReaperTimeout || grimReaperDuration){ grimReaperTimeout = clearTimeout(grimReaperTimeout); grimReaperDuration = clearInterval(grimReaperDuration); unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; startCooldownSkill(skillId); }else{ if(unlockSkill.lastStartDatetime == 0){ unlockSkill.lastStartDatetime = Date.now(); unlockSkill.isActive = true; addCountSkillUsed(skillId); }else{ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); } updateDailyTask(3); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-active,skill-running"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); lastGrimReaperHit = Date.now(); loopGrimReaper(); grimReaperDuration = setInterval (function (){ restDurationSkill = totalDurationSkill.sub(Math.floor((Date.now() - unlockSkill.lastStartDatetime) / 1000)); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Click to Stop - "+offlineTimeText(restDurationSkill)); if(restDurationSkill.lessThanOrEqualTo(0)){ grimReaperDuration = clearInterval(grimReaperDuration); grimReaperTimeout = clearTimeout(grimReaperTimeout); startCooldownSkill(skillId); } },1000); } }; var calcCooldownSkillTimer = function(totalCooldownSkill, lastCooldownDatetime){ let cooldownTimer = new Decimal(totalCooldownSkill).sub(Math.floor((Date.now()-lastCooldownDatetime) / 1000)); return cooldownTimer; }; var startCooldownSkill = function(skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let totalCooldownSkill = new Decimal(unlockSkill.cooldown).sub(artifactSkillCooldown(skillId)); let cooldownTimer = 0; unlockSkill.lastStartDatetime = 0; unlockSkill.isActive = false; if(unlockSkill.lastCooldownDatetime == 0){ unlockSkill.lastCooldownDatetime = Date.now(); unlockSkill.isCooldown = true; cooldownTimer = new Decimal(totalCooldownSkill); }else cooldownTimer = calcCooldownSkillTimer(totalCooldownSkill, unlockSkill.lastCooldownDatetime); $("#use-skill-button-"+skillId).prop('disabled', true); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Cooldown Timer - "+offlineTimeText(cooldownTimer)); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-running,skill-disabled"); let skillCooldown = setInterval(function() { cooldownTimer = calcCooldownSkillTimer(totalCooldownSkill, unlockSkill.lastCooldownDatetime); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Cooldown Timer - "+offlineTimeText(cooldownTimer)); if(cooldownTimer.lessThanOrEqualTo(0)){ $("#use-skill-button-"+skillId).prop('disabled', false); componentAction ("use-skill-button-"+skillId, "updateClass", "skill-disabled,skill-active"); componentAction ("skill-timer-desc-"+skillId, "replaceText", "Use Skill - Ready To Use"); let removeIndex = skillCooldownInterval.map(function(item) { return item.id; }).indexOf(skillId); if(removeIndex!== -1) skillCooldownInterval.splice(removeIndex, 1); skillCooldown = clearInterval(skillCooldown); unlockSkill.lastCooldownDatetime = 0; unlockSkill.isCooldown = false; } },1000); let newObjInterval = { id: skillId, lastUse: Date.now(), cooldown: unlockSkill.cooldown, interval: skillCooldown }; skillCooldownInterval.push(newObjInterval); }; var artifactSkillDamage = function(skillId){ let bonusArtifactSkillDamage; switch(skillId){ case 0: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 12); break; case 1: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 15); break; case 2: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 18); break; case 3: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 21); break; case 4: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 35); break; case 5: bonusArtifactSkillDamage = hero.unlockArtifact.find(item => item.id === 24); break; } if(bonusArtifactSkillDamage) return new Decimal(bonusArtifactSkillDamage.damage); else return new Decimal(0); }; var artifactSkillDuration = function(skillId){ let bonusArtifactSkillDuration; switch(skillId){ case 0: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 13); break; case 1: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 16); break; case 2: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 19); break; case 3: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 22); break; case 4: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 36); break; case 5: bonusArtifactSkillDuration = hero.unlockArtifact.find(item => item.id === 25); break; } if(bonusArtifactSkillDuration) return new Decimal(bonusArtifactSkillDuration.damage); else return new Decimal(0); }; var artifactSkillCooldown = function(skillId){ let bonusArtifactSkillCooldown; switch(skillId){ case 0: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 14); break; case 1: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 17); break; case 2: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 20); break; case 3: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 23); break; case 4: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 37); break; case 5: bonusArtifactSkillCooldown = hero.unlockArtifact.find(item => item.id === 26); break; } if(bonusArtifactSkillCooldown) return new Decimal(bonusArtifactSkillCooldown.damage); else return new Decimal(0); }; var startPrestige = function(){ if(hero.maxFloor >= setting.unlockReqFloorPrestige){ let totalOrbs = new Decimal(calcTotalOrbs()); let textOrbs = "Orb"; if(totalOrbs > 1) textOrbs = "Orbs"; componentAction ("prestige-text-confirm", "replaceText", numberFormat(totalOrbs)+" "+textOrbs); $("#modalPrestigeConfirm").modal('show'); } }; var runPrestige = function(){ if(hero.maxFloor >= setting.unlockReqFloorPrestige){ let totalOrbs = new Decimal(calcTotalOrbs()); let extraOrbs = new Decimal(runExtraOrbs(totalOrbs)); let textOrbs = "Orb"; let totalGainOrbs = new Decimal(hero.totalGainOrbs); hero.orbs = new Decimal(hero.orbs).plus(totalOrbs).plus(extraOrbs); hero.lastPrestigeDatetime = Date.now(); hero.lastPrestigeOrbs = totalOrbs.plus(extraOrbs); hero.lastPrestigeShow = false; totalGainOrbs = totalGainOrbs.plus(totalOrbs); hero.totalGainOrbs = totalGainOrbs; updateDailyTask(2); hero.totalCountPrestige++; resetGame(true); saveGame(); location.reload(); } }; var upgradeLevelHero = function (){ maxHeroLevelBuy = 0; let upgradeFee = updateUpgradeLevelFeeHero(); let heroCoin = new Decimal(hero.coin); if(heroCoin.greaterThanOrEqualTo(upgradeFee) && upgradeFee.greaterThan(0)){ let heroDPC = new Decimal(hero.dpc); let totalSpentCoin = new Decimal(hero.totalSpentCoin); upgradeFee = runUpgradeDisc(upgradeFee); heroCoin = heroCoin.sub(upgradeFee); hero.coin = heroCoin; totalSpentCoin = totalSpentCoin.plus(upgradeFee); hero.totalSpentCoin = totalSpentCoin; heroDPC = heroDPC.plus(calcNextHeroDpc()); hero.dpc = heroDPC; if(setting.levelUpgradeMultiplier > 0){ hero.heroLevel += setting.levelUpgradeMultiplier; updateDailyTask(7,setting.levelUpgradeMultiplier); }else if(setting.levelUpgradeMultiplier == 0){ hero.heroLevel += maxHeroLevelBuy; updateDailyTask(7,maxHeroLevelBuy); } if(hero.highestHeroLevel < hero.heroLevel) hero.highestHeroLevel = hero.heroLevel; initDisplay(); } }; var upgradeLevelWeapon = function (){ maxWeaponLevelBuy = 0; let upgradeFee = updateUpgradeLevelFeeWeapon(); let heroCoin = new Decimal(hero.coin); let unlockPet = hero.unlockPet.find(item => item.id === 1); if(heroCoin.greaterThanOrEqualTo(upgradeFee)){ let weaponDpc = new Decimal(hero.weaponDpc); let totalSpentCoin = new Decimal(hero.totalSpentCoin); upgradeFee = runUpgradeDisc(upgradeFee); heroCoin = heroCoin.sub(upgradeFee); hero.coin = heroCoin; totalSpentCoin = totalSpentCoin.plus(upgradeFee); hero.totalSpentCoin = totalSpentCoin; weaponDpc = weaponDpc.plus(calcNextWeaponDpc()); hero.weaponDpc = weaponDpc; if(hero.weaponLevel == 0){ hero.weaponLevel += 1; updateDailyTask(8); }else{ if(setting.levelUpgradeMultiplier > 0){ hero.weaponLevel += setting.levelUpgradeMultiplier; updateDailyTask(8, setting.levelUpgradeMultiplier); }else if(setting.levelUpgradeMultiplier == 0){ hero.weaponLevel += maxWeaponLevelBuy; updateDailyTask(8, maxWeaponLevelBuy); } } if(hero.highestWeaponLevel < hero.weaponLevel) hero.highestWeaponLevel = hero.weaponLevel; if(!unlockPet) unlockNewPet(1); initDisplay(); } }; var upgradeLevelPartner = function(e){ if(e){ let partnerId = parseInt(e.value,10); let petId = partnerId + 3; let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === partnerId); let unlockPet = hero.unlockPet.find(item => item.id === petId); if(localMaxPartnerLevelBuy) localMaxPartnerLevelBuy.maxLevelBuy = 0; let upgradeFee = updateUpgradeLevelFeePartner(partnerId); let heroCoin = new Decimal(hero.coin); if(heroCoin.greaterThanOrEqualTo(upgradeFee)){ let partnerDps = new Decimal(hero.dps); let nextDps = new Decimal(calcNextPartnerDps(partnerId)); let totalSpentCoin = new Decimal(hero.totalSpentCoin); let canStartDpsInterval = false; upgradeFee = runUpgradeDisc(upgradeFee); heroCoin = heroCoin.sub(upgradeFee); hero.coin = heroCoin; totalSpentCoin = totalSpentCoin.plus(upgradeFee); hero.totalSpentCoin = totalSpentCoin; if(partnerDps.equals(0) && nextDps.greaterThan(0)) canStartDpsInterval = true; partnerDps = partnerDps.plus(nextDps); hero.dps = partnerDps; if(canStartDpsInterval) startDpsInterval(true); let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); if(unlockPartner){ let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); unlockPartner.status = highestUnlockPartner.status; let unlockPartnerDps = new Decimal(unlockPartner.dps); if(setting.levelUpgradeMultiplier > 0){ if(unlockPartner.level > 0) unlockPartner.level += setting.levelUpgradeMultiplier; else unlockPartner.level += 1; updateDailyTask(9, setting.levelUpgradeMultiplier); }else if(setting.levelUpgradeMultiplier == 0){ if(unlockPartner.level == 0){ unlockPartner.level += 1; updateDailyTask(9, 1); }else{ let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === partnerId); unlockPartner.level += localMaxPartnerLevelBuy.maxLevelBuy; updateDailyTask(9, localMaxPartnerLevelBuy.maxLevelBuy); } } unlockPartnerDps = unlockPartnerDps.plus(nextDps); unlockPartner.dps = unlockPartnerDps; }else{ let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let partnerStatus = 'Battling'; if(highestUnlockPartner) partnerStatus = highestUnlockPartner.status; let newObjPartner = { id: partnerId, level: 1, dps: nextDps, status: partnerStatus, abilityId: -1, abilityCounter: 0, }; hero.unlockPartner.push(newObjPartner); hero.countPartner += 1; updateDailyTask(9); } let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); if(highestUnlockPartner){ let highestUnlockPartnerDps = new Decimal(highestUnlockPartner.dps); if(highestUnlockPartner.level < unlockPartner.level) highestUnlockPartner.level = unlockPartner.level; if(!highestUnlockPartner.dps) highestUnlockPartner.dps = unlockPartner.dps; if(highestUnlockPartnerDps.lessThan(unlockPartner.dps)) highestUnlockPartner.dps = unlockPartner.dps; }else{ let newObjHighestPartner = { id: partnerId, level: unlockPartner.level, dps: unlockPartner.dps, status: "Battling", ability: [] }; hero.highestUnlockPartner.push(newObjHighestPartner); if(hero.highestFloor >= setting.unlockReqFloorBarracks){ let partnerData = partner.find(item => item.id === partnerId); insertPartnerAbility(partnerId,partnerData.type); } } if(!unlockPet) unlockNewPet(petId); initDisplay(); } } }; var upgradeLevelSkill = function (e) { if(e){ let skillId = parseInt(e.value,10); let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === skillId); if(localMaxSkillLevelBuy) localMaxSkillLevelBuy.maxLevelBuy = 0; let currentSkillLevel = 0; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); if(unlockSkill)currentSkillLevel = unlockSkill.level; if(currentSkillLevel < 10){ let upgradeFee = updateUpgradeLevelFeeSkill(skillId); let heroCoin = new Decimal(hero.coin); let skillDamage = 0; if(heroCoin.greaterThanOrEqualTo(upgradeFee)){ let nextDamage = calcNextSkillDamage(skillId); let skillData = skill.find(item => item.id === skillId); let totalSpentCoin = new Decimal(hero.totalSpentCoin); upgradeFee = runUpgradeDisc(upgradeFee); heroCoin = heroCoin.sub(upgradeFee); hero.coin = heroCoin; totalSpentCoin = totalSpentCoin.plus(upgradeFee); hero.totalSpentCoin = totalSpentCoin; if(unlockSkill){ if(setting.levelUpgradeMultiplier == 1) unlockSkill.level += setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier >= 0){ let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === skillId); unlockSkill.level += localMaxSkillLevelBuy.maxLevelBuy; } let unlockSkillDamage = new Decimal(unlockSkill.damage); unlockSkill.damage = nextDamage; }else{ let newObjSkill = { id: skillId, level: 1, damage: nextDamage, duration: skillData.baseDuration, cooldown: skillData.baseCooldown, isActive: false, lastStartDatetime: 0, isCooldown: false, lastCooldownDatetime: 0 }; hero.unlockSkill.push(newObjSkill); } initDisplay(); } } } }; var upgradeLevelArtifact = function(e){ let artifactId = parseInt(e,10); if(artifactId >= 0){ let upgradeFee = new Decimal(calcNextUpgradeArtifactFee(artifactId)).mul(100-hero.bonusArtifactUpgradeFeePercentage).div(100).ceil(); let heroOrbs = new Decimal(hero.orbs); let weaponDpc = new Decimal(hero.weaponDpc); if(heroOrbs.greaterThanOrEqualTo(upgradeFee)){ let unlockArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); let artifactDamage = new Decimal(hero.artifactDamagePercentage); if(unlockArtifact){ if(unlockArtifact.level < artifactData.maxLevel || artifactData.maxLevel == 0){ hero.totalSpentOrbs = new Decimal(hero.totalSpentOrbs).plus(upgradeFee); heroOrbs = heroOrbs.sub(upgradeFee); hero.orbs = heroOrbs; updateDailyTask(4); unlockArtifact.level++; unlockArtifact.damage = new Decimal(unlockArtifact.level).mul(artifactData.baseDamage); hero.artifactDamagePercentage = artifactDamage.plus(artifactData.tier*5); calculateAllArtifactDamage(); saveGame(); initDisplay(); showArtifactArea(); } } } } }; var shopTradeToken = function(e){ if(e){ let shopId = parseInt(e.value,10); let shopData = shop.find(item => item.id === shopId); let heroToken = new Decimal(hero.token); let canShop = true; if(heroToken.greaterThanOrEqualTo(shopData.token)){ let shopDescription = ''; if(shopData.duration == 0){ if(shopData.typeName == "Gods Slot"){ if(hero.activeGodsSlot >= setting.maxActiveGodsSlot) canShop = false; shopDescription = shopData.bonusValue+' '+shopData.typeName+' for '+shopData.unit; }else shopDescription = shopData.typeName+' '+shopData.bonusValue+'% for '+shopData.unit; }else shopDescription = shopData.typeName+' '+shopData.bonusValue+'% for '+shopData.duration+' '+shopData.unit; if(canShop){ $("#modalShopForm").modal("show"); componentAction ("shop-ok-button", "inputText", shopId); componentAction ("shop-token", "replaceText", numberFormat(shopData.token)); componentAction ("shop-description", "replaceText", shopDescription); }else{ $("#modalNotification").modal("show"); componentAction ("notification-text", "replaceText", "You already reach maximum Gods Slot"); } }else{ $("#modalNotification").modal("show"); componentAction ("notification-text", "replaceText", "You don't have enough token"); } } }; var runShop = function(shopId){ shopId = parseInt(shopId,10); let successShop = true; let shopData = shop.find(item => item.id === shopId); if(hero.token >= shopData.token){ let currentDatetime = Date.now(); let endDatetime = 0; let bonusDuration = 0; switch(shopData.unit){ case 'Hours': bonusDuration = shopData.duration * 3600 * 1000; break; case 'Days': bonusDuration = shopData.duration * 24 * 3600 * 1000; break; } endDatetime = currentDatetime + bonusDuration; switch(shopData.typeName){ case 'DMG': if(bonusDuration == 0) hero.bonusShopDpcPercentage = new Decimal(hero.bonusShopDpcPercentage).plus(100); else{ if(hero.tempBonusShopDpcTime == 0) hero.tempBonusShopDpcTime = endDatetime; else hero.tempBonusShopDpcTime += bonusDuration; } break; case 'DPS': if(bonusDuration == 0) hero.bonusShopDpsPercentage = new Decimal(hero.bonusShopDpsPercentage).plus(100); else{ if(hero.tempBonusShopDpsTime == 0) hero.tempBonusShopDpsTime = endDatetime; else hero.tempBonusShopDpsTime += bonusDuration; } break; case 'Coin': if(bonusDuration == 0) hero.bonusShopCoinPercentage = new Decimal(hero.bonusShopCoinPercentage).plus(100); else{ if(hero.tempBonusShopCoinTime == 0) hero.tempBonusShopCoinTime = endDatetime; else hero.tempBonusShopCoinTime += bonusDuration; } break; case 'DPS, DMG & Coin': if(bonusDuration == 0){ hero.bonusShopDpcPercentage = new Decimal(hero.bonusShopDpcPercentage).plus(100); hero.bonusShopDpsPercentage = new Decimal(hero.bonusShopDpsPercentage).plus(100); hero.bonusShopCoinPercentage = new Decimal(hero.bonusShopCoinPercentage).plus(100); }else{ if(hero.tempBonusShopDpcTime == 0) hero.tempBonusShopDpcTime = endDatetime; else hero.tempBonusShopDpcTime += bonusDuration; if(hero.tempBonusShopDpsTime == 0) hero.tempBonusShopDpsTime = endDatetime; else hero.tempBonusShopDpsTime += bonusDuration; if(hero.tempBonusShopCoinTime == 0) hero.tempBonusShopCoinTime = endDatetime; else hero.tempBonusShopCoinTime += bonusDuration; } break; case 'Gods Slot': if(hero.activeGodsSlot < setting.maxActiveGodsSlot) hero.activeGodsSlot++; else successShop = false; break; } if(successShop) hero.token -= shopData.token; showShopArea(); } }; var confirmSellArtifact = function(e){ if(e){ let artifactId = parseInt(e.value,10); let unlockArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); let totalOrbsGain = new Decimal(calcSellArtifact(artifactId)); let notifText = "lv "+unlockArtifact.level+" "+artifactData.name+" for "+numberFormat(totalOrbsGain); if(totalOrbsGain > 1) notifText += " Orbs"; else notifText += " Orb"; componentAction ("sell-artifact-notification", "replaceText", notifText); $('#sell-artifact-ok-button').val(artifactId); $("#modalSellArtifactConfirm").modal('show'); } }; var calcSellArtifact = function(artifactId){ let unlockFee = new Decimal(calcNextUnlockArtifactFee()).mul(100-hero.bonusArtifactUnlockFeePercentage).div(100).ceil(); let upgradeFee = new Decimal(calcCurrentUpgradeArtifactFee(artifactId)).mul(100-hero.bonusArtifactUpgradeFeePercentage).div(100).ceil(); let totalFee = new Decimal(unlockFee).plus(upgradeFee); totalFee = totalFee.div(2).floor(); return totalFee; }; var sellArtifact = function(artifactId){ let totalFee = new Decimal(calcSellArtifact(artifactId)); var index = hero.unlockArtifact.findIndex(function(e){ return e.id === artifactId; }); if (index !== -1){ hero.unlockArtifact.splice(index, 1); $("#artifact-area-div").off('click','#upgrade-artifact-button-'+artifactId); $("#artifact-area-"+artifactId).remove(); hero.countArtifact--; hero.orbs = new Decimal(hero.orbs).plus(totalFee); switch (artifactId){ case 0: hero.bonusCoinPercentage = 0; break; case 1: hero.bonusBossCoinPercentage = 0; break; case 2: case 3: hero.bonusDpcPercentage = 0; break; case 4: hero.bonusDpsPercentage = 0; break; case 5: hero.bonusOfflineCoinPercentage = 0; break; case 6: hero.bonusOfflineDpsPercentage = 0; break; case 7: artifactDamage = artifactDamage.sub(totalDamage); break; case 8: hero.bonusOrbsPercentage = 0; break; case 9: hero.bonusOfflineTimeLimit = 0; break; case 10: hero.bonusIntervalDps = 0; startDpsInterval(true); break; case 11: hero.bonusIntervalGrimReaper = 0; break; case 27: hero.bonusBossTimeLimit = 0; break; case 28: hero.bonusEnemyHpPercentage = 0; break; case 29: hero.bonusBossHpPercentage = 0; break; case 30: hero.bonusHeroUpgradeFeePercentage = 0; break; case 31: hero.bonusWeaponUpgradeFeePercentage = 0; break; case 32: hero.bonusPartnerUpgradeFeePercentage = 0; break; case 33: hero.bonusSkillUpgradeFeePercentage = 0; break; case 34: hero.bonusChanceSkipFloorPercentage = 0; break; case 38: hero.bonusAdventureExpPercentage = 0; break; case 39: hero.bonusAdventureCoinPercentage = 0; break; case 40: hero.bonusAdventureTimePercentage = 0; break; case 41: hero.bonusDoubleAdventurePercentage = 0; break; case 42: hero.bonusArtifactRerollFeePercentage = 0; break; case 43: hero.bonusArtifactUnlockFeePercentage = 0; break; case 44: hero.bonusArtifactUpgradeFeePercentage = 0; break; case 45: hero.bonusMeleeDpsPercentage = 0; break; case 46: hero.bonusStealthDpsPercentage = 0; break; case 47: hero.bonusSwordDpsPercentage = 0; break; case 48: hero.bonusRangedDpsPercentage = 0; break; case 49: hero.bonusMagicDpsPercentage = 0; break; case 50: hero.bonusFirearmDpsPercentage = 0; break; case 51: hero.bonusRuneDpsPercentage = 0; break; case 52: hero.bonusAllDamagePercentage = 0; break; case 53: hero.bonusAllCoinPercentage = 0; break; case 54: hero.bonusAbilityPercentage = 0; break; case 55: hero.bonusMeleeAbilityPercentage = 0; break; case 56: hero.bonusStealthAbilityPercentage = 0; break; case 57: hero.bonusSwordAbilityPercentage = 0; break; case 58: hero.bonusRangedAbilityPercentage = 0; break; case 59: hero.bonusMagicAbilityPercentage = 0; break; case 60: hero.bonusFirearmAbilityPercentage = 0; break; case 61: hero.bonusRuneAbilityPercentage = 0; break; } calculateAllArtifactDamage(); insertSellArtifact(artifactId); } showArtifactArea(); saveGame(); }; var actionCounterValue = function(e){ let arrayString = e.value.split("="); let partnerId = parseInt(arrayString[0],10); let abilityId = parseInt(arrayString[1],10); let type = arrayString[2]; let action = arrayString[3]; let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let unlockAbility = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); let totalPoint = unlockAbility.abilityPoint; let value = 0; if(type == "acc"){ if(action == "minus" && unlockAbility.tempAccuracy > unlockAbility.accuracy){ unlockAbility.tempAccuracy -= 1; unlockAbility.tempAbilityPoint += 1; } if(action == "plus" && unlockAbility.tempAbilityPoint > 0){ if(hero.type == "free" && unlockAbility.tempAccuracy < setting.maxFreeLevelAccuracyAbility){ unlockAbility.tempAccuracy += 1; unlockAbility.tempAbilityPoint -= 1; }else if(hero.type == "premium" && unlockAbility.tempAccuracy < setting.maxPremiumLevelAccuracyAbility){ unlockAbility.tempAccuracy += 1; unlockAbility.tempAbilityPoint -= 1; } } if(unlockAbility.tempAccuracy != unlockAbility.accuracy) $("#"+type+"-counter-"+partnerId+"-"+abilityId).css({"color":"#0000FF", "fontWeight": "bold"}); else $("#"+type+"-counter-"+partnerId+"-"+abilityId).css({"color":"#000000", "fontWeight": ""}); componentAction(type+"-counter-"+partnerId+"-"+abilityId, "replaceText", numberFormat(unlockAbility.tempAccuracy)); }else if(type == "dam"){ if(action == "minus" && unlockAbility.tempDamage > unlockAbility.damage){ unlockAbility.tempDamage -= 1; unlockAbility.tempAbilityPoint += 1; } if(action == "plus" && unlockAbility.tempAbilityPoint > 0){ unlockAbility.tempDamage += 1; unlockAbility.tempAbilityPoint -= 1; } if(unlockAbility.tempDamage != unlockAbility.damage) $("#"+type+"-counter-"+partnerId+"-"+abilityId).css({"color":"#0000FF", "fontWeight": "bold"}); else $("#"+type+"-counter-"+partnerId+"-"+abilityId).css({"color":"#000000", "fontWeight": ""}); componentAction(type+"-counter-"+partnerId+"-"+abilityId, "replaceText", numberFormat(unlockAbility.tempDamage)); } componentAction("ability-point-"+partnerId+"-"+abilityId, "replaceText", numberFormat(unlockAbility.tempAbilityPoint)); if(unlockAbility.tempAbilityPoint != unlockAbility.abilityPoint){ $("#save-ability-partner-button-"+partnerId+"-"+abilityId).prop('disabled', false); componentAction("save-ability-partner-button-"+partnerId+"-"+abilityId, "removeClass", "d-none"); componentAction("activate-ability-partner-button-"+partnerId+"-"+abilityId, "addClass", "d-none"); }else{ $("#save-ability-partner-button-"+partnerId+"-"+abilityId).prop('disabled', true); componentAction("save-ability-partner-button-"+partnerId+"-"+abilityId, "addClass", "d-none"); componentAction("activate-ability-partner-button-"+partnerId+"-"+abilityId, "removeClass", "d-none"); } }; var confirmSaveAbilityPartner = function(e){ let arrayString = e.value.split("="); let partnerId = parseInt(arrayString[0],10); let abilityId = parseInt(arrayString[1],10); let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); if(highestUnlockPartner){ let unlockAbility = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); if(unlockAbility){ $("#modalConfirmSaveAbility").modal('show'); componentAction ("save-ability-ok-button", "inputText", e.value); } } }; var confirmActivateAbility = function(e){ let arrayString = e.value.split("="); let partnerId = parseInt(arrayString[0],10); let abilityId = parseInt(arrayString[1],10); let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); let abilityData = partnerAbility.find(item => item.id === abilityId); let currentAction = $("#activate-ability-partner-text-"+partnerId+"-"+abilityId).text(); if(highestUnlockPartner){ let unlockAbility = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); if(unlockAbility){ let activeAbility = highestUnlockPartner.ability.filter(item => item.isActive === true); if(unlockAbility.isActive || activeAbility.length < hero.activeAbilityPartner){ $("#modalConfirmActivateAbility").modal('show'); componentAction("activate-ability-ok-button", "inputText", e.value); componentAction("ability-action", "replaceText", currentAction); componentAction("activate-ability-name", "replaceText", abilityData.name); componentAction("activate-partner-name", "replaceText", partnerData.name); componentAction("activate-ability-ok-button", "replaceText", "Yes, "+currentAction+" It"); }else{ $("#modalNotification").modal('show'); componentAction ("notification-text", "replaceText", "You only have "+hero.activeAbilityPartner+" active ability slot. Please deactive other ability first."); } } } }; var saveAbilityPartner = function(){ let arrayString = $("#save-ability-ok-button").val(); arrayString = arrayString.split("="); let partnerId = parseInt(arrayString[0],10); let abilityId = parseInt(arrayString[1],10); let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); if(highestUnlockPartner){ let unlockAbility = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); if(unlockAbility){ unlockAbility.accuracy = unlockAbility.tempAccuracy; unlockAbility.damage = unlockAbility.tempDamage; unlockAbility.abilityPoint = unlockAbility.tempAbilityPoint; $("#acc-counter-"+partnerId+"-"+abilityId).css({"color":"#000000", "fontWeight": ""}); $("#dam-counter-"+partnerId+"-"+abilityId).css({"color":"#000000", "fontWeight": ""}); componentAction("save-ability-partner-button-"+partnerId+"-"+abilityId, "addClass", "d-none"); componentAction("activate-ability-partner-button-"+partnerId+"-"+abilityId, "removeClass", "d-none"); if(unlockAbility.abilityPoint > 0) componentAction("icon-point-"+partnerId+"-"+abilityId, "removeClass", "d-none"); else componentAction("icon-point-"+partnerId+"-"+abilityId, "addClass", "d-none"); } } showBarracksArea(true); }; var activateAbilityPartner = function(e){ let arrayString = e.split("="); let partnerId = parseInt(arrayString[0],10); let abilityId = parseInt(arrayString[1],10); let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); let abilityData = partnerAbility.find(item => item.id === abilityId); if(highestUnlockPartner){ let unlockAbility = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); if(unlockAbility){ let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); if(!unlockAbility.isActive){ let activeAbility = highestUnlockPartner.ability.filter(item => item.isActive === true); if(activeAbility.length < hero.activeAbilityPartner) unlockAbility.isActive = true; unlockPartner.abilityId = abilityId; }else{ unlockAbility.isActive = false; unlockPartner.abilityId = -1; } unlockAbility.newAbility = false; } } saveGame(); showBarracksArea(true); }; var showHideAbility = function(e){ let partnerId = parseInt(e.id.replace("ability-header-",""),10); let abilityMenuClass = $("#show-hide-menu-"+partnerId).attr("class"); let showIndex = abilityMenuClass.indexOf("show-menu"); let hideIndex = abilityMenuClass.indexOf("hide-menu"); let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let currentAbilityMenu = ''; let nextAbilityMenu = ''; if (showIndex !== -1){ componentAction("show-hide-menu-"+partnerId, "updateClass", "show-menu,hide-menu"); for(let i=0;i<highestUnlockPartner.ability.length;i++){ let abilityId = highestUnlockPartner.ability[i].abilityId; componentAction("ability-partner-area-"+partnerId+"-"+abilityId, "addClass", "d-none"); } }else if(hideIndex !== -1){ componentAction("show-hide-menu-"+partnerId, "updateClass", "hide-menu,show-menu"); for(let i=0;i<highestUnlockPartner.ability.length;i++){ let abilityId = highestUnlockPartner.ability[i].abilityId; componentAction("ability-partner-area-"+partnerId+"-"+abilityId, "removeClass", "d-none"); } } }; var chooseTrainingPartner = function(e){ let slotId = parseInt(e.value,10); let trainingSlot = hero.trainingZone.trainingSlot.find(item => item.slotId === slotId); if(trainingSlot){ let partnerId = trainingSlot.partnerId; let abilityId = trainingSlot.abilityId; let value = partnerId+"="+abilityId+"="+slotId; let partnerData = partner.find(item => item.id === partnerId); let partnerAbilityData = partnerAbility.find(item => item.id === abilityId); $("#modalConfirmStopTrainingAbility").modal('show'); componentAction ("stop-training-ability-ok-button", "inputText", value); componentAction ("stop-training-ability-text", "replaceText", partnerAbilityData.name); componentAction ("stop-training-partner-text", "replaceText", partnerData.name); }else{ let dropDownList = ["-1=-- Please Choose Partner --"]; let availableHighestUnlockPartner = hero.highestUnlockPartner.filter(item => item.status === "Battling" || item.status === "Resting"); if(hero.settingOrderPartner == "asc"){ for(let i=0;i<availableHighestUnlockPartner.length;i++){ let partnerId = availableHighestUnlockPartner[i].id; let partnerData = partner.find(item => item.id === partnerId); dropDownList.push(partnerId+"="+partnerData.name); } }else if(hero.settingOrderPartner == "desc"){ for(let i=(availableHighestUnlockPartner.length-1);i>=0;i--){ let partnerId = availableHighestUnlockPartner[i].id; let partnerData = partner.find(item => item.id === partnerId); dropDownList.push(partnerId+"="+partnerData.name); } } $("#list-partner-div-"+slotId).empty(); $("#list-ability-div-"+slotId).empty(); $("#button-training-div-"+slotId).empty(); componentAction("list-partner-div-"+slotId,"removeClass","d-none"); $("#list-partner-div-"+slotId).append(createDropDownList(dropDownList,"list-partner-"+slotId)).off('change',"#list-partner-"+slotId).on('change',"#list-partner-"+slotId,function(){ chooseTrainingAbility(this,slotId); }); } }; var chooseTrainingAbility = function(e,index){ let partnerId = parseInt(e.value,10); let unlockPartnerAbility = hero.highestUnlockPartner.find(item => item.id === partnerId); let dropDownList = ["-1=-- Please Choose Ability --"]; for(let i=0;i<unlockPartnerAbility.ability.length;i++){ let abilityId = unlockPartnerAbility.ability[i].abilityId; let partnerAbilityData = partnerAbility.find(item => item.id === abilityId); dropDownList.push(partnerId+"-"+abilityId+"="+partnerAbilityData.name); } componentAction("list-ability-div-"+index,"removeClass","d-none"); $("#list-ability-div-"+index).empty(); $("#button-training-div-"+index).empty(); $("#list-ability-div-"+index).append(createDropDownList(dropDownList,"list-ability-"+index)).off('change',"#list-ability-"+index).on('change',"#list-ability-"+index,function(){ showButtonTraining(this,index); }); }; var showButtonTraining = function(e,index){ let arrayValue = e.value; componentAction("button-training-div-"+index,"removeClass","d-none"); let buttonTrainingDiv = '<button id="start-training-button-' + index + '" class="upgrade-level-button mt-2" value="' + arrayValue + '">Start Training</button>'; $("#button-training-div-"+index).append(buttonTrainingDiv).off('click',"#start-training-button-"+index).on('click',"#start-training-button-"+index,function(){ confirmStartTrainingAbility(this,index); }); }; var confirmStartTrainingAbility = function(e,index){ let arrayValue = e.value.split("-"); let partnerId = parseInt(arrayValue[0],10); let abilityId = parseInt(arrayValue[1],10); let value = partnerId+"="+abilityId+"="+index; let partnerData = partner.find(item => item.id === partnerId); let partnerAbilityData = partnerAbility.find(item => item.id === abilityId); $("#modalConfirmStartTrainingAbility").modal('show'); componentAction ("training-ability-ok-button", "inputText", value); componentAction ("training-ability-text", "replaceText", partnerAbilityData.name); componentAction ("training-partner-text", "replaceText", partnerData.name); }; var startTrainingAbility = function(e){ let arrayString = e.split("="); let partnerId = parseInt(arrayString[0],10); let abilityId = parseInt(arrayString[1],10); let slotId = parseInt(arrayString[2],10); let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let unlockAbilityPartner = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); let restTrainingTime = calcRestTimeTraining(unlockAbilityPartner.maxLevel); let totalTrainingTime = unlockAbilityPartner.trainingTime; restTrainingTime = restTrainingTime - totalTrainingTime; if(unlockPartner && highestUnlockPartner && unlockAbilityPartner){ let newTrainingSlot = { slotId: slotId, partnerId: partnerId, abilityId: abilityId, startTraining: Date.now(), statusTraining: 'training', }; hero.trainingZone.trainingSlot.push(newTrainingSlot); componentAction("training-ability-timer-"+slotId,"replaceText",offlineTimeText(restTrainingTime)); unlockPartner.abilityId = -1; unlockPartner.status = "Training"; highestUnlockPartner.status = "Training"; unlockAbilityPartner.trainingStatus = true; unlockAbilityPartner.isActive = false; $("#training-area-div").empty(); showTrainingArea(); } }; var stopTrainingAbility = function(e,completeTraining=false){ let arrayString = e.split("="); let partnerId = parseInt(arrayString[0],10); let abilityId = parseInt(arrayString[1],10); let slotId = parseInt(arrayString[2],10); let trainingSlot = hero.trainingZone.trainingSlot.find(item => item.slotId === slotId); if(trainingSlot){ let highestUnlockPartner = hero.highestUnlockPartner.find(item => item.id === partnerId); let unlockAbilityPartner = highestUnlockPartner.ability.find(item => item.abilityId === abilityId); let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let startTraining = trainingSlot.startTraining; let trainingTime = unlockAbilityPartner.trainingTime + Math.floor((Date.now() - startTraining)/1000); if(completeTraining) unlockAbilityPartner.trainingTime = 0; else unlockAbilityPartner.trainingTime = trainingTime; unlockAbilityPartner.trainingStatus = false; highestUnlockPartner.status = 'Resting'; unlockPartner.status = 'Resting'; if(trainingSlot.interval) clearTimeout(trainingSlot.interval); let removeIndex = hero.trainingZone.trainingSlot.map(function(item) { return item.slotId; }).indexOf(slotId); if(removeIndex!== -1) hero.trainingZone.trainingSlot.splice(removeIndex, 1); $("#training-area-div").empty(); showTrainingArea(); } }; var chooseAdventureArea = function(e){ let arrayString = e.value.split("="); let zoneId = parseInt(arrayString[0],10); let zoneSlot = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); if(zoneId >= 0 && zoneSlot >= 0){ let unlockPet = hero.unlockPet.find(item => item.id === petId); if(unlockPet.statusAdventure == '' && unlockPet.collectReward == '') insertAdventurePet(e); else if(unlockPet.statusAdventure == 'running' && unlockPet.collectReward == '') confirmCancelAdventurePet(e); else confirmCollectReward(e.value); }else showAdventureArea(petId); }; var insertAdventurePet = function(e){ let arrayString = e.value.split("="); let zoneId = parseInt(arrayString[0],10); let zoneSlot = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); if(petId >= 0){ if(zoneId >= 0 && zoneSlot >= 0){ let zoneData = zone.find(item => item.id === zoneId); let petData = pet.find(item => item.id === petId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === zoneSlot); if(!unlockZoneSlot){ $("#modalStartAdventureConfirm").modal('show'); componentAction ("confirm-adventure-ok-button", "inputText", e.value); componentAction ("selected-pet-name", "replaceText", petData.name); componentAction ("selected-adventure-area", "replaceText", zoneData.name); }else{ if(unlockZoneSlot.statusAdventure == 'running' && unlockZoneSlot.collectReward == '') confirmCancelAdventurePet(e); else if(unlockZoneSlot.statusAdventure == 'complete' && unlockZoneSlot.collectReward == 'later') confirmCollectReward(e.value); } } }else{ showPetArea(zoneId,zoneSlot); } }; var confirmCancelAdventurePet = function(e){ let arrayString = e.value.split("="); let zoneId = parseInt(arrayString[0],10); let zoneSlot = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); let zoneData = zone.find(item => item.id === zoneId); let petData = pet.find(item => item.id === petId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === zoneSlot); if(unlockZoneSlot){ $("#modalCancelAdventureConfirm").modal('show'); componentAction ("cancel-adventure-ok-button", "inputText", e.value); componentAction ("cancel-pet-name", "replaceText", petData.name); componentAction ("cancel-adventure-area", "replaceText", zoneData.name); } }; var startAdventurePet = function(arrayString){ arrayString = arrayString.split("="); let zoneId = parseInt(arrayString[0],10); let slotId = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); let petData = pet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); let unlockPet = hero.unlockPet.find(item => item.id === petId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); if(unlockZone){ let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slot === slotId); if(!unlockZoneSlot){ let startAdventureTime = Date.now(); let endAdventureTime = startAdventureTime + (zoneData.adventureTime * 3600 * 1000 * (100 - hero.bonusAdventureTimePercentage) / 100); let newObjAdventureSlot = { slotId: slotId, petId: petId, startAdventure: startAdventureTime, endAdventure: endAdventureTime, statusAdventure: 'running', collectReward: '' }; unlockZone.adventureSlot.push(newObjAdventureSlot); if(unlockPet){ unlockPet.adventureZone = zoneId; unlockPet.adventureSlot = slotId; if(!unlockPet.statusAdventure) unlockPet.statusAdventure = 'running'; if(!unlockPet.collectReward) unlockPet.collectReward = ''; } updateDailyTask(12); switch(zoneId){ case 0: updateDailyTask(13); break; case 1: updateDailyTask(14); break; case 2: updateDailyTask(15); break; case 3: updateDailyTask(16); break; case 4: updateDailyTask(17); break; } } } if(!($("#pet-div").hasClass("d-none"))){ if(!$("#pet-area-div").hasClass("d-none")) showPetArea(); if(!$("#adventure-area-div").hasClass("d-none")) showAdventureArea(); } startCooldownAdventureTimer(petId, zoneId, slotId); }; var cancelAdventurePet = function(arrayString){ arrayString = arrayString.split("="); let zoneId = parseInt(arrayString[0],10); let slotId = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); let petData = pet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); let unlockPet = hero.unlockPet.find(item => item.id === petId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === slotId); let endAdventureTime = unlockZoneSlot.endAdventure; let restAdventureTime = Math.ceil((endAdventureTime - Date.now()) / 2000); if(unlockPet){ unlockPet.statusAdventure = "cancel"; componentAction ("note-button-pet-adventure-"+petId, "clearText", ""); } if(unlockZoneSlot){ unlockZoneSlot.statusAdventure = "cancel"; unlockZoneSlot.endAdventure = Date.now() + (restAdventureTime*1000); if(!checkAdventureZoneStatus(unlockZoneSlot)){ componentAction ("note-button-adventure-slot-"+zoneId, "clearText", "");} } startCooldownAdventureTimer(petId, zoneId, slotId); }; var calcCooldownAdventureTime = function(zoneId, slotId){ let cooldownTimer = 0; let unlockZone = hero.unlockZone.find(item => item.id === zoneId); if(unlockZone){ let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === slotId); if(unlockZoneSlot)cooldownTimer = Math.ceil((unlockZoneSlot.endAdventure - Date.now()) / 1000); } return cooldownTimer; }; var checkCooldownAdventureTimer = function(afterOffline=false){ if(!($("#modalOfflineForm").data('bs.modal') || {})._isShown ){ updateAdventureStatus(); if(hero.countZone > 0 && hero.countPet > 0){ for(let i=0;i<hero.unlockPet.length;i++){ let statusAdventure = hero.unlockPet[i].statusAdventure; let collectReward = hero.unlockPet[i].collectReward; if(statusAdventure == 'running' || statusAdventure == 'cancel' || (statusAdventure == 'complete' && collectReward == '')){ let petId = hero.unlockPet[i].id; let zoneId = hero.unlockPet[i].adventureZone; let slotId = hero.unlockPet[i].adventureSlot; if(i == (hero.unlockPet.length - 1)) afterOffline = false; startCooldownAdventureTimer(petId, zoneId, slotId, afterOffline); } } } } }; var startCooldownAdventureTimer = function(petId, zoneId, slotId, afterOffline=false){ let petData = pet.find(item => item.id === petId); let unlockPet = hero.unlockPet.find(item => item.id === petId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let cooldownTimer = calcCooldownAdventureTime(zoneId, slotId); let adventureIntervalId; let adventureInterval; if(cooldownTimer > 0){ if(unlockPet && unlockPet.statusAdventure == "cancel"){ updateAdventureButtonClass("button-pet-adventure-"+petId, "skill-disabled"); $("#button-pet-adventure-"+petId).prop('disabled', true); updateAdventureButtonClass("button-adventure-slot-"+zoneId+"-"+slotId, "skill-disabled"); $("#button-adventure-slot-"+zoneId+"-"+slotId).prop('disabled', true); }else if(unlockPet && unlockPet.statusAdventure == "running"){ $("#button-pet-adventure-"+petId).prop('disabled', false); componentAction ("note-button-pet-adventure-"+petId, "replaceText", constNoteCancelAdventure); updateAdventureButtonClass("button-pet-adventure-"+petId, "skill-running"); $("#button-adventure-slot-"+zoneId+"-"+slotId).prop('disabled', false); componentAction ("note-button-adventure-slot-"+zoneId, "replaceText", constNoteCancelAdventure); updateAdventureButtonClass("button-adventure-slot-"+zoneId+"-"+slotId, "skill-running"); } componentAction ("pet-adventure-name-"+petId, "replaceText", petData.name); componentAction ("hyphen-"+petId, "replaceText", "-"); componentAction ("slot-adventure-name-"+petId, "replaceText", offlineTimeText(cooldownTimer)); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", petData.name); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", offlineTimeText(cooldownTimer)); adventureIntervalId = zoneId+'='+slotId+'='+petId; let objAdventureInterval = adventureTimerInterval.find(item => item.id === adventureIntervalId); if(!objAdventureInterval){ adventureInterval = setTimeout(function loopCooldownAdventureTimer() { cooldownTimer = calcCooldownAdventureTime(zoneId, slotId); if(unlockPet && unlockPet.statusAdventure == "cancel"){ updateAdventureButtonClass("button-pet-adventure-"+petId, "skill-disabled"); updateAdventureButtonClass("button-adventure-slot-"+zoneId+"-"+slotId, "skill-disabled"); }else if(unlockPet && unlockPet.statusAdventure == "running"){ updateAdventureButtonClass("button-pet-adventure-"+petId, "skill-running"); updateAdventureButtonClass("button-adventure-slot-"+zoneId+"-"+slotId, "skill-running"); } componentAction ("pet-adventure-name-"+petId, "replaceText", petData.name); componentAction ("hyphen-"+petId, "replaceText", "-"); componentAction ("slot-adventure-name-"+petId, "replaceText", offlineTimeText(cooldownTimer)); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", petData.name); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", offlineTimeText(cooldownTimer)); if(cooldownTimer <= 0) stopCooldownAdventureTimer(petId, zoneId, slotId, afterOffline); else{ if(adventureInterval) adventureInterval = clearTimeout(adventureInterval); adventureInterval = setTimeout(loopCooldownAdventureTimer, 1000); adventureTimerInterval.interval = adventureInterval; } },1000); let newObjInterval = { id: adventureIntervalId, interval: adventureInterval }; adventureTimerInterval.push(newObjInterval); }else adventureInterval = objAdventureInterval.interval; }else stopCooldownAdventureTimer(petId, zoneId, slotId, afterOffline); saveGame(); }; var stopCooldownAdventureTimer = function(petId, zoneId, slotId, afterOffline=false){ let petData = pet.find(item => item.id === petId); let unlockPet = hero.unlockPet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === slotId); let removeIndex = -1; if(unlockZoneSlot){ if(unlockZoneSlot.statusAdventure == 'cancel'){ removeIndex = unlockZone.adventureSlot.map(function(item) { return item.slotId; }).indexOf(slotId); if(removeIndex!== -1)unlockZone.adventureSlot.splice(removeIndex, 1); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "inputText", (zoneId+'='+slotId+'=-1')); updateAdventureButtonClass("button-adventure-slot-"+zoneId+"-"+slotId, ""); }else if(unlockZoneSlot.statusAdventure == 'running') unlockZoneSlot.statusAdventure = 'complete'; } if(unlockPet){ if(unlockPet.statusAdventure == 'cancel'){ unlockPet.statusAdventure = ''; unlockPet.collectReward = ''; componentAction ("button-pet-adventure-"+petId, "inputText", "-1=-1="+petId); updateAdventureButtonClass("button-pet-adventure-"+petId, ""); }else if(unlockPet.statusAdventure == 'running') unlockPet.statusAdventure = 'complete'; } let searchId = zoneId+'='+slotId+'='+petId; let searchAdventureInterval = adventureTimerInterval.find(item => item.id === searchId); if(searchAdventureInterval) searchAdventureInterval.interval = clearTimeout(searchAdventureInterval.interval); removeIndex = adventureTimerInterval.map(function(item) { return item.id; }).indexOf(searchId); if(removeIndex!== -1)adventureTimerInterval.splice(removeIndex, 1); let statusRunningAdventureZone = false; $("#button-pet-adventure-"+petId).prop('disabled', false); componentAction ("note-button-pet-adventure-"+petId, "replaceText", ""); componentAction ("pet-adventure-name-"+petId, "replaceText", petData.name); componentAction ("hyphen-"+petId, "clearText", ""); componentAction ("slot-adventure-name-"+petId, "clearText", ""); $("#button-adventure-slot-"+zoneId+"-"+slotId).prop('disabled', false); if(!checkAdventureZoneStatus(unlockZone.adventureSlot)) componentAction ("note-button-adventure-slot-"+zoneId, "replaceText", ""); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", "Pet"); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", "Slot "+(slotId+1)); checkAdventureStatus(afterOffline); saveGame(); }; var updateAdventureButtonClass = function(buttonId,buttonClass){ if($(buttonId)){ componentAction (buttonId, "removeClass", "skill-active"); componentAction (buttonId, "removeClass", "skill-running"); componentAction (buttonId, "removeClass", "skill-disabled"); componentAction (buttonId, "removeClass", "collect-reward"); componentAction (buttonId, "addClass", buttonClass); } }; var checkAdventureZoneStatus = function(unlockZoneSlot){ let statusRunningAdventureZone = false; for(let i=0;i<unlockZoneSlot.length;i++){ if(unlockZoneSlot[i].statusAdventure == 'running'){ statusRunningAdventureZone = true; } } return statusRunningAdventureZone; }; var updateAdventureStatus = function(){ for(let i=0;i<hero.unlockPet.length;i++){ hero.unlockPet[i].adventureSlot = -1; hero.unlockPet[i].adventureZone = -1; hero.unlockPet[i].collectReward = ""; hero.unlockPet[i].statusAdventure = ""; } for(let i=0;i<hero.unlockZone.length;i++){ hero.unlockZone[i].adventureSlot = checkDuplicateAdventure(hero.unlockZone[i].adventureSlot); let adventureSlot = hero.unlockZone[i].adventureSlot; for(let a=0;a<hero.unlockZone[i].currSlot;a++){ let activeAdventureSlot = adventureSlot.find(item => item.slotId === a); if(activeAdventureSlot){ let unlockPet = hero.unlockPet.find(item => item.id === activeAdventureSlot.petId); if(!unlockPet) hero.unlockZone[i].adventureSlot.splice(a, 1); let zoneData = zone.find(item => item.id === hero.unlockZone[i].id); if(activeAdventureSlot.statusAdventure != "cancel"){ let endAdventureTime = activeAdventureSlot.startAdventure + (zoneData.adventureTime * 3600 * 1000); if(!(activeAdventureSlot.endAdventure == endAdventureTime))activeAdventureSlot.endAdventure = endAdventureTime; } if(activeAdventureSlot.endAdventure < Date.now()){ activeAdventureSlot.statusAdventure = "complete"; if(activeAdventureSlot.collectReward != "later") activeAdventureSlot.collectReward = ""; if(unlockPet){ unlockPet.adventureSlot = activeAdventureSlot.slotId; unlockPet.adventureZone = hero.unlockZone[i].id; unlockPet.statusAdventure = activeAdventureSlot.statusAdventure; unlockPet.collectReward = activeAdventureSlot.collectReward; } }else{ if(activeAdventureSlot.statusAdventure != "running" && activeAdventureSlot.statusAdventure != "cancel"){ activeAdventureSlot.statusAdventure = "running"; activeAdventureSlot.collectReward = ""; } if(unlockPet){ unlockPet.adventureSlot = activeAdventureSlot.slotId; unlockPet.adventureZone = hero.unlockZone[i].id; unlockPet.statusAdventure = activeAdventureSlot.statusAdventure; unlockPet.collectReward = activeAdventureSlot.collectReward; } } } } } }; var checkAdventureStatus = function(afterOffline=false){ let countCompleteAdventure = 0; let arrayAdventureValue = []; for(let i=0;i<hero.unlockPet.length;i++){ let statusAdventure = hero.unlockPet[i].statusAdventure; let collectReward = hero.unlockPet[i].collectReward; if (statusAdventure == 'complete' && collectReward == ''){ let petId = hero.unlockPet[i].id; let zoneId = hero.unlockPet[i].adventureZone; let slotId = hero.unlockPet[i].adventureSlot; arrayAdventureValue.push(zoneId+"="+slotId+"="+petId); countCompleteAdventure++; } } if(afterOffline){ if(!($("#modalOfflineForm").data('bs.modal') || {})._isShown ) afterOffline = false; } if(countCompleteAdventure > 0 && !afterOffline){ if(countCompleteAdventure == 1){ let adventureValue = arrayAdventureValue[0]; let arrayString = adventureValue.split("="); let zoneId = parseInt(arrayString[0],10); let slotId = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); let zoneData = zone.find(item => item.id === zoneId); let petData = pet.find(item => item.id === petId); if(!($("#modalListRewardAdventureConfirm").data('bs.modal') || {})._isShown ) $("#modalRewardAdventureConfirm").modal("show"); componentAction ("confirm-reward-adventure-ok-button", "inputText", adventureValue); componentAction ("stop-adventure-pet-name", "replaceText", petData.name); componentAction ("stop-adventure-area-name", "replaceText", zoneData.name); }else{ let adventureString = ""; for(let i=0;i<countCompleteAdventure;i++){ let adventureValue = arrayAdventureValue[i]; let arrayString = adventureValue.split("="); let zoneId = parseInt(arrayString[0],10); let petId = parseInt(arrayString[2],10); let zoneData = zone.find(item => item.id === zoneId); let petData = pet.find(item => item.id === petId); adventureString += (i+1)+". Pet "+petData.name+" at "+zoneData.name+"\n"; } if(($("#modalRewardAdventureConfirm").data('bs.modal') || {})._isShown ) $("#modalRewardAdventureConfirm").modal("toggle"); $("#modalListRewardAdventureConfirm").modal("show"); componentAction ("listAdventureName", "replaceText", adventureString); } } }; var confirmCollectReward = function(e){ let arrayString = e.split("="); let zoneId = parseInt(arrayString[0],10); let zoneSlot = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); let petData = pet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); $("#modalCollectRewardAdventureConfirm").modal("show"); componentAction ("collect-reward-pet-name", "replaceText", petData.name); componentAction ("collect-reward-area-name", "replaceText", zoneData.name); componentAction ("collect-reward-adventure-ok-button", "inputText", e); }; var confirmCollectRewardAdventurePet = function(arrayString,isCollectLater=false){ if(arrayString == 'complete'){ let petId = -1; let zoneId = -1; let slotId = -1; for(let i=0;i<hero.unlockPet.length;i++){ petId = -1; zoneId = -1; slotId = -1; let statusAdventure = hero.unlockPet[i].statusAdventure; let collectReward = hero.unlockPet[i].collectReward; if (statusAdventure == 'complete' && collectReward == ''){ petId = hero.unlockPet[i].id; zoneId = hero.unlockPet[i].adventureZone; slotId = hero.unlockPet[i].adventureSlot; } if(zoneId >= 0 && slotId >= 0 && petId >= 0) collectRewardAdventurePet(zoneId,slotId,petId,isCollectLater); } }else{ arrayString = arrayString.split("="); let zoneId = parseInt(arrayString[0],10); let slotId = parseInt(arrayString[1],10); let petId = parseInt(arrayString[2],10); collectRewardAdventurePet(zoneId,slotId,petId,isCollectLater); } initDisplay(); }; var collectRewardAdventurePet = function(zoneId,slotId,petId,isCollectLater=false){ let addSlotStatus = false; let petData = pet.find(item => item.id === petId); let zoneData = zone.find(item => item.id === zoneId); let unlockZone = hero.unlockZone.find(item => item.id === zoneId); let unlockZoneSlot = unlockZone.adventureSlot.find(item => item.slotId === slotId); let unlockPet = hero.unlockPet.find(item => item.id === petId); if(isCollectLater){ if(unlockPet) unlockPet.collectReward = "later"; if(unlockZoneSlot) unlockZoneSlot.collectReward = "later"; componentAction ("button-pet-adventure-"+petId, "updateClass", "skill-active,collect-reward"); componentAction ("pet-adventure-name-"+petId, "replaceText", "Complete"); componentAction ("hyphen-"+petId, "replaceText", "-"); componentAction ("slot-adventure-name-"+petId, "replaceText", "Collect Reward"); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "skill-active,collect-reward"); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", "Complete"); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", "Collect Reward"); }else{ componentAction ("button-pet-adventure-"+petId, "updateClass", "skill-running,skill-active"); componentAction ("button-pet-adventure-"+petId, "updateClass", "collect-reward,skill-active"); componentAction ("pet-adventure-name-"+petId, "replaceText", petData.name); componentAction ("hyphen-"+petId, "clearText", ""); componentAction ("slot-adventure-name-"+petId, "clearText", ""); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "skill-running,skill-active"); componentAction ("button-adventure-slot-"+zoneId+"-"+slotId, "updateClass", "collect-reward,skill-active"); componentAction ("adventure-pet-name-"+zoneId+"-"+slotId, "replaceText", "Pet"); componentAction ("adventure-slot-name-"+zoneId+"-"+slotId, "replaceText", "Slot "+(slotId+1)); if(unlockPet){ unlockPet.adventureZone = -1; unlockPet.adventureSlot = -1; unlockPet.statusAdventure = ''; unlockPet.collectReward = ''; } let removeIndex = unlockZone.adventureSlot.map(function(item) { return item.slotId; }).indexOf(slotId); if (removeIndex !== -1)unlockZone.adventureSlot.splice(removeIndex, 1); let percentAdventureExp = new Decimal(100).plus(hero.bonusAdventureExpPercentage); let percentAdventureCoin = new Decimal(100).plus(hero.bonusAdventureCoinPercentage).plus(hero.bonusAllCoinPercentage); let adventureExp = new Decimal(unlockZone.bonusExp).mul(percentAdventureExp).div(100); let adventureCoin = new Decimal(unlockZone.bonusCoin).mul(percentAdventureCoin).div(100); let petReqLevelUp = unlockPet.level * petData.upgradeReqExp; let randomPercentage = Math.random()*100; if(randomPercentage <= hero.bonusDoubleAdventurePercentage) unlockZone.adventureCount+=2; else unlockZone.adventureCount++; hero.coin = new Decimal(hero.coin).plus(adventureCoin); unlockPet.currExp = new Decimal(unlockPet.currExp).plus(adventureExp); updateDailyTask(18,unlockZone.bonusExp*1); updateDailyTask(19,unlockZone.bonusCoin*1); let adventureReqLevelUp = unlockZone.level * zoneData.baseUpgradeReq; if(unlockZone.adventureCount >= adventureReqLevelUp){ unlockZone.level++; if(unlockZone.level % setting.bonusZoneSlot == 0 || unlockZone.level / 5 == 1){ unlockZone.currSlot += 1; addSlotStatus = true; } unlockZone.adventureCount -= adventureReqLevelUp; unlockZone.bonusCoin = new Decimal(unlockZone.level - 1).mul(zoneData.baseCoin / 2).plus(zoneData.baseCoin).floor(); unlockZone.bonusExp = new Decimal(unlockZone.level - 1).mul(zoneData.baseExp / 2).plus(zoneData.baseExp).floor(); let nextZoneId = zoneId+1; let nextZoneData = zone.find(item => item.id === nextZoneId); if(nextZoneData){ if(unlockZone.level == nextZoneData.unlockReqLevel){ let nextUnlockZone = hero.unlockZone.find(item => item.id === nextZoneId); if(!nextUnlockZone) insertNewUnlockZone(nextZoneId,nextZoneData); } } } while(unlockPet.currExp >= petReqLevelUp){ unlockPet.level++; unlockPet.currExp = new Decimal(unlockPet.currExp).sub(petReqLevelUp); unlockPet.currBonus = petData.multiplierBonus * unlockPet.level; petReqLevelUp = unlockPet.level * petData.upgradeReqExp; }; if(!($("#pet-div").hasClass("d-none"))){ if(addSlotStatus) $("#adventure-area-div").empty(); } } if(!($("#pet-div").hasClass("d-none"))){ if(!$("#pet-area-div").hasClass("d-none")) showPetArea(); if(!$("#adventure-area-div").hasClass("d-none")) showAdventureArea(); } saveGame(); }; var collectAchievementReward = function(e){ let achievementId = parseInt(e.value,10); let achievementData = achievement.find(item => item.id === achievementId); let unlockAchievement = hero.achievement.find(item => item.id === achievementId); let achievementReward = (unlockAchievement.level%2==0 ? (unlockAchievement.level+1): unlockAchievement.level); let achievementBalance = new Decimal(unlockAchievement.balance); let achievementTarget = new Decimal(unlockAchievement.target); if(achievementBalance.greaterThanOrEqualTo(achievementTarget) && unlockAchievement.level < achievementData.maxLoop){ unlockAchievement.level++; unlockAchievement.prevTarget = unlockAchievement.target; if(achievementData.targetMultiplier > 1) unlockAchievement.target = new Decimal(unlockAchievement.target).mul(achievementData.targetMultiplier); else unlockAchievement.target = new Decimal(unlockAchievement.target).plus(achievementData.targetMultiplier); hero.token += achievementReward; saveGame(); showAchievementArea(); } }; var insertNewUnlockZone = function(zoneId,zoneData){ hero.countZone++; let newObjZone = { id: zoneId, level: 1, bonusExp: zoneData.baseExp, bonusCoin: zoneData.baseCoin, currSlot: zoneData.baseSlot, adventureCount: 0, adventureSlot: [] }; hero.unlockZone.push(newObjZone); }; var confirmTradeGodsFragment = function(selectedFragmentCount){ let fragmentCount = 0; let soulCount = 0; switch(selectedFragmentCount){ case 'All': fragmentCount = Math.floor(hero.soul / setting.soulEachFragment); break; default: fragmentCount = parseInt(selectedFragmentCount,10); break; } soulCount = fragmentCount * setting.soulEachFragment; if(hero.soul >= soulCount){ $("#modalConfirmTradeSoul").modal("show"); componentAction ("trade-soul-ok-button", "inputText", fragmentCount); componentAction ("soul-trade-text", "replaceText", soulCount); componentAction ("gods-fragment-text", "replaceText", fragmentCount); }else{ $("#modalNotification").modal("show"); componentAction ("notification-text", "replaceText", "You don't have enough soul to exchange"); } }; var tradeGodsFragment = function(e){ let fragmentCount = parseInt((e*1),10); let soulCount = fragmentCount * setting.soulEachFragment; let listFragment = []; let notifString = 'You receive '; if(hero.soul >= soulCount){ for(let i=0;i<fragmentCount;i++){ let godsId = availableGods[Math.floor(Math.random() * availableGods.length)]; let godsData = gods.find(item => item.id === godsId); let unlockFragment = hero.unlockFragment.find(item => item.id === godsId); if(unlockFragment) unlockFragment.count++; else{ let newObjFragment = { id: godsId, count: 1, }; hero.unlockFragment.push(newObjFragment); } hero.soul -= setting.soulEachFragment; let searchFragment = listFragment.find(item => item.id === godsId); if(searchFragment) searchFragment.count++; else{ let newObjListFragment = { id: godsId, name: godsData.name, count: 1, }; listFragment.push(newObjListFragment); } } if(listFragment.length > 1) notifString += fragmentCount+" Fragments\n"; else notifString += fragmentCount+" Fragment\n"; for(let i=0;i<listFragment.length;i++){ if(listFragment[i].count > 1) notifString += listFragment[i].count+" Fragments of "; else notifString += listFragment[i].count+" Fragment of "; notifString += listFragment[i].name+"\n"; } $("#modalNotification").modal("show"); componentAction ("notification-text", "replaceText", notifString); showTempleArea(); } }; var calcTotalDpc = function () { let skillId = 1; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let baseDpc = new Decimal(hero.dpc).plus(hero.weaponDpc); baseDpc = increaseDpc(baseDpc); let subTotalPercentage = new Decimal(100).plus(hero.bonusDpcPercentage).plus(hero.bonusAllDamagePercentage).plus(hero.artifactDamagePercentage); let totalPercentage; if(hero.tempBonusShopDpcTime > 0) totalPercentage = new Decimal(200).plus(hero.bonusShopDpcPercentage).mul(subTotalPercentage).div(10000); else totalPercentage = new Decimal(100).plus(hero.bonusShopDpcPercentage).mul(subTotalPercentage).div(10000); let totalDpc = new Decimal(baseDpc).mul(totalPercentage); let percentageBonusDpc = new Decimal(hero.percentageBonusDpc); hero.percentageBonusDpc = totalPercentage.mul(100); if(unlockSkill && unlockSkill.isActive){ let totalDamagePercentage = new Decimal(100).plus(unlockSkill.damage).plus(artifactSkillDamage(skillId)).div(100); totalDpc = totalDpc.mul(totalDamagePercentage).round(); } if(totalDpc.round().greaterThan(hero.highestDpc)) hero.highestDpc = totalDpc.round(); return totalDpc.round(); }; var calcBattlingDps = function(){ let battlingPartner = hero.unlockPartner.filter(item => item.status === "Battling"); let totalDps = new Decimal(0); for(let i=0;i<battlingPartner.length;i++){ totalDps = totalDps.plus(calcTotalPartnerDps(battlingPartner[i].id,"current")); } hero.dps = totalDps; return totalDps; }; var calcTotalDps = function (isOnline=true) { let baseDps = new Decimal(increaseGodsDps(calcBattlingDps())); let subTotalPercentage = new Decimal(100).plus(hero.bonusAllDamagePercentage).plus(hero.artifactDamagePercentage); if(isOnline) subTotalPercentage = subTotalPercentage.plus(hero.bonusDpsPercentage); else subTotalPercentage = subTotalPercentage.plus(hero.bonusOfflineDpsPercentage); let totalPercentage = new Decimal(100).plus(hero.bonusShopDpsPercentage); if(hero.tempBonusShopDpsTime > 0 && isOnline) totalPercentage = totalPercentage.plus(100); totalPercentage = totalPercentage.mul(subTotalPercentage).div(10000); let totalDps = new Decimal(baseDps).mul(totalPercentage); if(isOnline){ let percentageBonusDps = new Decimal(hero.percentageBonusDps); hero.percentageBonusDps = totalPercentage.mul(100); let skillId = 2; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); if(unlockSkill && unlockSkill.isActive){ let totalDamagePercentage = new Decimal(100).plus(unlockSkill.damage).plus(artifactSkillDamage(skillId)).div(100); totalDps = totalDps.mul(totalDamagePercentage).round(); } } if(totalDps.round().greaterThan(hero.highestDps)) hero.highestDps = totalDps.round(); return totalDps.round(); }; var calcTotalRewardCoin = function (isOnline=true) { let rewardCoin = new Decimal(hero.floor).div(1.2).mul(enemy.baseCoin); let subTotalPercentage = new Decimal(100).plus(hero.bonusAllCoinPercentage).plus(hero.artifactDamagePercentage); if(isOnline) subTotalPercentage = subTotalPercentage.plus(hero.bonusCoinPercentage); else subTotalPercentage = subTotalPercentage.plus(hero.bonusOfflineCoinPercentage); let totalPercentage = new Decimal(100).plus(hero.bonusShopCoinPercentage); if(hero.tempBonusShopCoinTime > 0 && isOnline) totalPercentage = totalPercentage.plus(100); totalPercentage = totalPercentage.mul(subTotalPercentage).div(10000); let totalRewardCoin = new Decimal(rewardCoin).mul(totalPercentage); if(isOnline){ let percentageBonusCoin = new Decimal(hero.percentageBonusCoin); hero.percentageBonusCoin = totalPercentage.mul(100); let skillId = 3; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); if(unlockSkill && unlockSkill.isActive){ let totalDamagePercentage = new Decimal(100).plus(unlockSkill.damage).plus(artifactSkillDamage(skillId)).div(100); totalRewardCoin = totalRewardCoin.mul(totalDamagePercentage).round(); } } if(hero.floor % enemy.bossFloor == 0){ let bossCoinPercentage = new Decimal(hero.bonusBossCoinPercentage).plus(100).div(100); totalRewardCoin = totalRewardCoin.mul(bossCoinPercentage).mul(2); } return totalRewardCoin.ceil(); }; var calcTotalOrbs = function (){ let baseOrbs = new Decimal(((hero.maxFloor - setting.unlockReqFloorPrestige)/setting.prestigeFloorBonus)+(setting.baseGainOrbsCalculation)).pow(setting.orbsMultiplier); let partnerOrbs = new Decimal(calcTotalPartnerLevel()).plus(hero.heroLevel).plus(hero.weaponLevel).div(setting.prestigePartnerLevelBonus); let subTotalPercentage = new Decimal(100).plus(hero.bonusOrbsPercentage); let totalPercentage = new Decimal(100).plus(hero.bonusShopOrbsPercentage).mul(subTotalPercentage).div(10000); let totalOrbs = baseOrbs.plus(partnerOrbs).mul(totalPercentage); let percentageBonusOrbs = new Decimal(hero.percentageBonusOrbs); let totalPercentageStat = totalPercentage.mul(100); if(percentageBonusOrbs.lessThan(totalPercentageStat)) hero.percentageBonusOrbs = totalPercentage*100; return totalOrbs.floor(); }; var calcTotalAbility = function(){ let totalAbilityDamage = new Decimal(0); let abilityChanges = false; for(let i=0;i<hero.countPartner;i++){ let unlockPartner = hero.unlockPartner[i]; let abilityId = unlockPartner.abilityId; let highestPartnerLevel = hero.highestUnlockPartner.find(item => item.id === unlockPartner.id); if(highestPartnerLevel){ let unlockPartnerAbility = highestPartnerLevel.ability.find(item => item.abilityId === abilityId); if(unlockPartnerAbility && unlockPartnerAbility.isActive){ unlockPartner.abilityCounter += 1; let abilityInterval = unlockPartnerAbility.interval; let abilityAccuracy = unlockPartnerAbility.accuracy; let abilityDamagePercentage = unlockPartnerAbility.damage; if(unlockPartner.abilityCounter == abilityInterval){ let randomAbility = Math.random()*100; unlockPartner.abilityCounter = 0; if(randomAbility <= abilityAccuracy){ let partnerDps = new Decimal(unlockPartner.dps); let partnerData = partner.find(item => item.id === unlockPartner.id); let bonusPartnerTypePercentage = new Decimal(1); switch(partnerData.type){ case "Melee": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusMeleeAbilityPercentage).div(100); break; case "Stealth": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusStealthAbilityPercentage).div(100); break; case "Sword": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusSwordAbilityPercentage).div(100); break; case "Ranged": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusRangedAbilityPercentage).div(100); break; case "Magic": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusMagicAbilityPercentage).div(100); break; case "Firearm": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusFirearmAbilityPercentage).div(100); break; case "Rune": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusRuneAbilityPercentage).div(100); break; } let abilityDamage = new Decimal(partnerDps).mul(abilityDamagePercentage).mul(hero.percentageBonusDps).div(10000).mul(bonusPartnerTypePercentage); totalAbilityDamage = totalAbilityDamage.plus(abilityDamage); if(unlockPartnerAbility.abilityLevel < unlockPartnerAbility.maxLevel){ unlockPartnerAbility.exp += 1; abilityChanges = true; if(unlockPartnerAbility.exp >= unlockPartnerAbility.maxExp){ unlockPartnerAbility.exp -= unlockPartnerAbility.maxExp; unlockPartnerAbility.abilityLevel += 1; unlockPartnerAbility.abilityPoint += 1; unlockPartnerAbility.tempAbilityPoint += 1; unlockPartnerAbility.maxExp = Math.ceil(unlockPartnerAbility.abilityLevel/5)*10; if(unlockPartnerAbility.abilityLevel == setting.reqLevelUnlockNewAbility){ let partnerAbilityData = partnerAbility.find(item => item.id === abilityId); if(partnerAbilityData.abilityTypeId < 4){ let nextAbilityTypeId = partnerAbilityData.abilityTypeId + 1; insertPartnerAbility(unlockPartner.id,partnerData.type,nextAbilityTypeId); $("#barracks-area-div").empty(); } } } } } } } } } if(abilityChanges && !$("#barracks-div").hasClass("d-none") && !$("#barracks-area-div").hasClass("d-none")) showBarracksArea(); let totalPercentage = new Decimal(100).plus(hero.bonusAbilityPercentage).plus(hero.bonusAllDamagePercentage).plus(hero.artifactDamagePercentage); totalAbilityDamage = totalAbilityDamage.mul(totalPercentage).div(100); return totalAbilityDamage.floor(); }; var calcTotalPartnerLevel = function (){ let totalLevel = 0; for(let i=0;i<hero.unlockPartner.length;i++){ totalLevel += hero.unlockPartner[i].level; } return totalLevel; }; var calcCurrentUnlockArtifactFee = function(){ let unlockFee = new Decimal(hero.countArtifact).mul(Math.pow(setting.unlockArtifactMultiplier,hero.countArtifact)).floor(); return unlockFee; }; var calcNextUnlockArtifactFee = function(){ let unlockFee = new Decimal(hero.countArtifact+1).mul(Math.pow(setting.unlockArtifactMultiplier,(hero.countArtifact+1))).floor(); return unlockFee; }; var calcCurrentUpgradeArtifactFee = function(artifactId){ let upgradeArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); let upgradeFee = new Decimal(0); let lastUpgradeFee = new Decimal(0); if(upgradeArtifact){ for(let a=1; a<upgradeArtifact.level; a++){ lastUpgradeFee = new Decimal(setting.upgradeArtifactBaseTier + (artifactData.tier*setting.upgradeArtifactTierMultiplier)).mul(Math.pow((setting.upgradeArtifactMultiplier*artifactData.upgradeMultiplier),(a+1))).ceil(); upgradeFee = upgradeFee.plus(lastUpgradeFee); } } return upgradeFee; }; var calcNextUpgradeArtifactFee = function(artifactId){ let upgradeArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); let upgradeFee = 0; if(upgradeArtifact){ upgradeFee = new Decimal(setting.upgradeArtifactBaseTier + (artifactData.tier*setting.upgradeArtifactTierMultiplier)).mul(Math.pow((setting.upgradeArtifactMultiplier*artifactData.upgradeMultiplier),(upgradeArtifact.level+1))).ceil(); } return upgradeFee; }; var calcOfflineTime = function () { let onDateTime = Date.now(); let offlineTime = new Decimal(onDateTime).sub(hero.lastActiveDatetime).div(1000).floor(); if(offlineTime.greaterThanOrEqualTo(0)){ let offlineDps = new Decimal(calcTotalDps(false)); let totalOfflineTimeLimit = new Decimal(setting.baseOfflineTimeLimit).plus(hero.bonusOfflineTimeLimit).mul(60); let offlineTimeReward = offlineTime; if(offlineTime.greaterThan(totalOfflineTimeLimit)) offlineTimeReward = totalOfflineTimeLimit; if(offlineDps.greaterThan(0) && offlineTimeReward.greaterThanOrEqualTo(3)){ if(hero.floor % enemy.bossFloor == 0) hero.floor--; let enemyHP = initEnemy(); let rewardCoin = new Decimal(calcTotalRewardCoin(false)); let killingTime = new Decimal(enemyHP).div(offlineDps).ceil(); let killingCount = new Decimal(offlineTimeReward).div(killingTime).floor(); hero.totalOfflineDuration = new Decimal(hero.totalOfflineDuration).plus(offlineTimeReward); let totalRewardCoin = new Decimal(rewardCoin).mul(killingCount); hero.coin = new Decimal(hero.coin).plus(totalRewardCoin); hero.totalOfflineCoin = new Decimal(hero.totalOfflineCoin).plus(totalRewardCoin); let enemyText = (killingCount > 1? " Enemies": " Enemy"); let totalRewardCoinText = (totalRewardCoin.greaterThan(1)? " Coins": " Coin"); let offlineText = "Welcome Back "+hero.userName+"\n"; offlineText += "You are offline for "+offlineTimeText(offlineTime)+"\n"; if(offlineTimeReward.lessThan(offlineTime)) offlineText += "Max offline reward "+offlineTimeText(offlineTimeReward)+"\n"; offlineText += "You are killing "+killingCount+enemyText+"\n"; offlineText += "And you got "+numberFormat(totalRewardCoin)+totalRewardCoinText+"\n"; componentAction ("offline-text", "replaceText", offlineText); $("#modalOfflineForm").modal('show'); } return false; }else return true; }; var offlineTimeText = function (offlineSecond) { if(offlineSecond >= 0){ let offlineYear = Math.floor(offlineSecond / 31104000); let offlineMonth = Math.floor((offlineSecond - (offlineYear*31104000)) / 2592000); let offlineDay = Math.floor((offlineSecond - (offlineYear*31104000) - (offlineMonth*2592000)) / 86400); let offlineHour = Math.floor((offlineSecond - (offlineYear*31104000) - (offlineMonth*2592000) - (offlineDay*86400)) / 3600); let offlineMin = Math.floor((offlineSecond - (offlineYear*31104000) - (offlineMonth*2592000) - (offlineDay*86400) - (offlineHour*3600)) / 60); let offlineSec = Math.floor(offlineSecond - (offlineYear*31104000) - (offlineMonth*2592000) - (offlineDay*86400) - (offlineHour*3600) - (offlineMin * 60)); let timerText = ""; if(offlineSecond >= 31104000) timerText += offlineYear+" Year "; if(offlineSecond >= 2592000) timerText += offlineMonth+" Month "; if(offlineSecond >= 86400 && offlineYear == 0) timerText += offlineDay+" Day "; if(offlineSecond >= 3600 && offlineMonth == 0) timerText += offlineHour+" Hour "; if(offlineSecond >= 60 && offlineDay == 0) timerText += offlineMin+" Min "; if(offlineHour == 0)timerText += offlineSec+" Sec"; return timerText; }else return "-"; }; var calcNextHeroDpc = function (level=0){ let totalNextHeroDpc = new Decimal(0); let levelMultiplier = 0; if(level > 0) levelMultiplier = level; else{ if(setting.levelUpgradeMultiplier > 0) levelMultiplier = setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier == 0) levelMultiplier = maxHeroLevelBuy; } for(let a=0; a<levelMultiplier; a++){ let nextHeroDpc = new Decimal(hero.heroLevel + a + 1).div(setting.heroDpcMultiplier).ceil(); totalNextHeroDpc = totalNextHeroDpc.plus(nextHeroDpc); if((hero.heroLevel + a + 1) / 10 == 1 || (hero.heroLevel + a + 1) % 25 == 0){ totalNextHeroDpc = totalNextHeroDpc.plus(hero.heroLevel + a + 1); } } return totalNextHeroDpc.ceil(); }; var calcNextWeaponDpc = function (level=0){ let totalNextWeaponDpc = new Decimal(0); let loopNextLevel = 0; if(level > 0) loopNextLevel = level; else{ if(hero.weaponLevel == 0) loopNextLevel = 1; else{ if(setting.levelUpgradeMultiplier > 0)loopNextLevel = setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier == 0)loopNextLevel = maxWeaponLevelBuy; } } for(let a=0; a<loopNextLevel; a++){ let nextWeaponDpc = new Decimal(hero.weaponLevel + a + 1).div(setting.weaponDpcMultiplier).ceil().mul(setting.baseWeaponDpc); totalNextWeaponDpc = totalNextWeaponDpc.plus(nextWeaponDpc); if((hero.weaponLevel + a + 1) / 10 == 1 || (hero.weaponLevel + a + 1) % 25 == 0){ totalNextWeaponDpc = totalNextWeaponDpc.plus((hero.weaponLevel + a + 1)*1.5); } } return totalNextWeaponDpc.ceil(); }; var calcCurrentPartnerDps = function(partnerId){ let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); if(unlockPartner) return new Decimal(unlockPartner.dps).plus(unlockPartner.bonusDps); else return new Decimal(0); }; var calcNextPartnerDps = function (partnerId,level=0){ let totalNextPartnerDps = new Decimal(0); let loopNextLevel = 0; let currentPartnerLevel = 0; let unlockPartner = hero.unlockPartner.find(item => item.id === partnerId); let partnerData = partner.find(item => item.id === partnerId); if(unlockPartner && unlockPartner.level > 0){ if(level > 0) loopNextLevel = level; else{ if(setting.levelUpgradeMultiplier > 0)loopNextLevel = setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier == 0){ let localMaxPartnerLevelBuy = maxPartnerLevelBuy.find(item => item.id === partnerId); if(localMaxPartnerLevelBuy) loopNextLevel = localMaxPartnerLevelBuy.maxLevelBuy; } } currentPartnerLevel = unlockPartner.level; }else loopNextLevel = 1; for(let a=0; a<loopNextLevel; a++){ let nextPartnerDps = new Decimal(currentPartnerLevel + a + 1).div(setting.partnerDpsMultiplier).ceil().mul(partnerData.baseDps); totalNextPartnerDps = totalNextPartnerDps.plus(nextPartnerDps); if((currentPartnerLevel + a + 1) / 10 == 1 || (currentPartnerLevel + a + 1) % 25 == 0){ totalNextPartnerDps = totalNextPartnerDps.plus((currentPartnerLevel + a + 1)*1.5); } } return totalNextPartnerDps; }; var calcTotalPartnerDps = function(partnerId=-1,type){ let totalPartnerDps = new Decimal(0); if(type == "current") totalPartnerDps = calcCurrentPartnerDps(partnerId); else if(type == "next") totalPartnerDps = calcNextPartnerDps(partnerId); let partnerData = partner.find(item => item.id === partnerId); let bonusPartnerTypePercentage = new Decimal(0); switch(partnerData.type){ case "Melee": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusMeleeDpsPercentage).div(100); break; case "Stealth": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusStealthDpsPercentage).div(100); break; case "Sword": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusSwordDpsPercentage).div(100); break; case "Ranged": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusRangedDpsPercentage).div(100); break; case "Magic": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusMagicDpsPercentage).div(100); break; case "Firearm": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusFirearmDpsPercentage).div(100); break; case "Rune": bonusPartnerTypePercentage = new Decimal(100).plus(hero.bonusRuneDpsPercentage).div(100); break; }; return totalPartnerDps.mul(bonusPartnerTypePercentage).ceil(); }; var calcNextSkillDamage = function (skillId){ let nextSkillDamage = new Decimal(0); let loopNextLevel = 0; let currentSkillLevel = 0; let nextSkillLevel = 0; let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let skillData = skill.find(item => item.id === skillId); if(unlockSkill){ if(setting.levelUpgradeMultiplier == 1)loopNextLevel = setting.levelUpgradeMultiplier; else if(setting.levelUpgradeMultiplier >= 0){ let localMaxSkillLevelBuy = maxSkillLevelBuy.find(item => item.id === skillId); loopNextLevel = localMaxSkillLevelBuy.maxLevelBuy; } currentSkillLevel = unlockSkill.level; }else loopNextLevel = 1; nextSkillLevel = currentSkillLevel + loopNextLevel; if(nextSkillLevel >= 10) nextSkillDamage = (10 * skillData.damageMultiplier) + skillData.baseDamage; else nextSkillDamage = ((nextSkillLevel-1) * skillData.damageMultiplier) + skillData.baseDamage; return nextSkillDamage; }; var setSequenceName = function(a){ let textName = ''; switch(a){ case 0: case 20: textName = "1<sup>st</sup>"; break; case 1: case 21: textName = "2<sup>nd</sup>"; break; case 2: case 22: textName = "3<sup>rd</sup>"; break; default: textName = (a+1)+"<sup>th</sup>"; break; } return textName; }; var runStealCoin = function(){ if(hero.bonusChanceStealCoinPercentage > 0){ let totalRewardCoin = calcTotalRewardCoin(); let randomPercentage = Math.random()*100; let godsData = gods.find(item => item.id === 0); if(randomPercentage <= hero.bonusChanceStealCoinPercentage){ let stealCoinAmount = new Decimal(godsData.buffValue).mul(totalRewardCoin).div(100).floor(); hero.coin = new Decimal(hero.coin).plus(stealCoinAmount).ceil(); hero.totalGainCoin = new Decimal(hero.totalGainCoin).plus(stealCoinAmount).ceil(); updateHeroCoin(); saveGame(); } } }; var runDpcToCoin = function(){ if(hero.bonusChanceDpcToCoinPercentage > 0){ let totalDpc = new Decimal(calcTotalDpc()); let randomPercentage = Math.random()*100; let godsData = gods.find(item => item.id === 1); if(randomPercentage <= hero.bonusChanceDpcToCoinPercentage){ let convertCoinAmount = new Decimal(godsData.buffValue).mul(totalDpc).div(100).floor(); hero.coin = new Decimal(hero.coin).plus(convertCoinAmount).ceil(); hero.totalGainCoin = new Decimal(hero.totalGainCoin).plus(convertCoinAmount).ceil(); updateHeroCoin(); saveGame(); } } }; var runDpsToCoin = function(totalDps){ if(hero.bonusChanceDpsToCoinPercentage > 0){ let randomPercentage = Math.random()*100; let godsData = gods.find(item => item.id === 2); if(randomPercentage <= hero.bonusChanceDpsToCoinPercentage){ let convertCoinAmount = new Decimal(godsData.buffValue).mul(totalDps).div(100).floor(); hero.coin = new Decimal(hero.coin).plus(convertCoinAmount).ceil(); hero.totalGainCoin = new Decimal(hero.totalGainCoin).plus(convertCoinAmount).ceil(); updateHeroCoin(); saveGame(); } } }; var runExtraCoin = function(totalRewardCoin){ let extraCoinAmount = new Decimal(0); if(hero.bonusChanceExtraCoinPercentage > 0){ let randomPercentage = Math.random()*100; let godsData = gods.find(item => item.id === 3); if(randomPercentage <= hero.bonusChanceExtraCoinPercentage) extraCoinAmount = new Decimal(godsData.buffValue).mul(totalRewardCoin).div(100); } return extraCoinAmount; }; var runExtraOrbs = function(totalOrbs){ let extraOrbsAmount = new Decimal(0); if(hero.bonusChanceAddOrbsPrestigePercentage > 0){ let randomPercentage = Math.random()*100; let godsData = gods.find(item => item.id === 4); if(randomPercentage <= hero.bonusChanceAddOrbsPrestigePercentage) extraOrbsAmount = new Decimal(godsData.buffValue).mul(totalOrbs).div(100).floor(); } return extraOrbsAmount; }; var runStealOrbs = function(){ let extraOrbsAmount = new Decimal(0); if(hero.bonusChanceAddOrbsFloorPercentage > 0){ let randomPercentage = Math.random()*100; let godsData = gods.find(item => item.id === 5); if(hero.maxFloor % godsData.buffTimer == 0){ if(randomPercentage <= hero.bonusChanceAddOrbsFloorPercentage){ let stealOrbsAmount = new Decimal(godsData.buffValue); hero.orbs = new Decimal(hero.orbs).plus(stealOrbsAmount).floor(); hero.totalGainOrbs = new Decimal(hero.totalGainOrbs).plus(stealOrbsAmount).floor(); updateHeroOrbs(); saveGame(); } } } }; var runCarriedCoin = function(lastCoin){ let carriedCoin = new Decimal(0); if(hero.bonusChanceCarriedCoinPercentage > 0) carriedCoin = new Decimal(hero.bonusChanceCarriedCoinPercentage).mul(lastCoin).div(100).floor(); return carriedCoin; }; var runUpgradeDisc = function(normalUpgradeFee){ let upgradeFee = new Decimal(normalUpgradeFee); if(hero.bonusChanceUpgradeDiscountPercentage > 0){ let randomPercentage = Math.random()*100; let godsData = gods.find(item => item.id === 7); if(randomPercentage <= hero.bonusChanceUpgradeDiscountPercentage){ upgradeFee = new Decimal(godsData.buffValue).mul(upgradeFee).div(100).ceil(); } } return upgradeFee; }; var increaseDpc = function(currentDpc){ let totalDpc = new Decimal(currentDpc); if(hero.bonusGodsDpcPercentage > 0) totalDpc = new Decimal(100+hero.bonusGodsDpcPercentage).mul(currentDpc).div(100).floor(); return totalDpc; }; var increaseGodsDps = function(currentDps){ let totalDps = new Decimal(currentDps); if(hero.bonusGodsDpsPercentage > 0) totalDps = new Decimal(100).plus(hero.bonusGodsDpsPercentage).mul(currentDps).div(100).floor(); return totalDps; }; var hitGodsDamage = function(){ let totalHitDamage = new Decimal(0); totalHitDamage = new Decimal(hitHighestDpc()).plus(hitHighestDps()).plus(hitCurrentSlashDamage()).plus(hitCurrentDpc()).plus(hitCurrentDps()); return totalHitDamage; }; var hitHighestDpc = function(){ let hitDamage = new Decimal(0); if(hero.bonusChanceHitHighestDpcPercentage > 0){ let godsData = gods.find(item => item.id === 10); if(countHitHighestDpc < godsData.buffValue){ hitDamage = new Decimal(hero.highestDpc).mul(hero.bonusChanceHitHighestDpcPercentage).div(100).floor(); countHitHighestDpc++; } } return hitDamage; }; var hitHighestDps = function(){ let hitDamage = new Decimal(0); if(hero.bonusChanceHitHighestDpsPercentage > 0){ let godsData = gods.find(item => item.id === 11); if(countHitHighestDps < godsData.buffValue){ hitDamage = new Decimal(hero.highestDps).mul(hero.bonusChanceHitHighestDpsPercentage).div(100).floor(); countHitHighestDps++; } } return hitDamage; }; var hitCurrentSlashDamage = function(){ let hitDamage = new Decimal(0); if(hero.bonusChanceHitCurrentSlashPercentage > 0){ let godsData = gods.find(item => item.id === 12); if(countHitCurrentSlash < godsData.buffValue){ let slashDamage = new Decimal(calcTotalDpc()).plus(calcTotalDps()).mul(2).floor(); hitDamage = new Decimal(slashDamage).mul(hero.bonusChanceHitCurrentSlashPercentage).div(100).floor(); countHitCurrentSlash++; } } return hitDamage; }; var hitCurrentDpc = function(){ let hitDamage = new Decimal(0); if(hero.bonusChanceHitCurrentDpcPercentage > 0){ let godsData = gods.find(item => item.id === 13); if(countHitCurrentDpc < godsData.buffValue){ hitDamage = new Decimal(calcTotalDpc()).mul(hero.bonusChanceHitCurrentDpcPercentage).div(100).floor(); countHitCurrentDpc++; } } return hitDamage; }; var hitCurrentDps = function(){ let hitDamage = new Decimal(0); if(hero.bonusChanceHitCurrentDpsPercentage > 0){ let godsData = gods.find(item => item.id === 14); if(countHitCurrentDps < godsData.buffValue){ hitDamage = new Decimal(calcTotalDps()).mul(hero.bonusChanceHitCurrentDpsPercentage).div(100).floor(); countHitCurrentDps++; } } return hitDamage; }; var updateTab = function(menuName){ let tabName = ''; componentAction ("hero-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("partner-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("skill-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("shop-tab-button", "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("hero-area-div", "addClass", "d-none"); componentAction ("partner-area-div", "addClass", "d-none"); componentAction ("skill-area-div", "addClass", "d-none"); componentAction ("shop-area-div", "addClass", "d-none"); switch (menuName) { case 'hero': tabName = "hero-tab-button"; componentAction ("buy-multiplier-div", "updateClass", "d-none,d-flex"); break; case 'partner': tabName = "partner-tab-button"; componentAction ("buy-multiplier-div", "updateClass", "d-none,d-flex"); break; case 'skill': tabName = "skill-tab-button"; componentAction ("buy-multiplier-div", "updateClass", "d-none,d-flex"); break; case 'shop': tabName = "shop-tab-button"; componentAction ("buy-multiplier-div", "updateClass", "d-flex,d-none"); break; }; componentAction (tabName, "updateClass", "tab-button-unactive,tab-button-active"); componentAction (menuName+"-area-div", "removeClass", "d-none"); checkCssSetting(); }; var clickDPC = function() { let start = Date.now(); let diffMiliSec = start - lastDateTimeClick; if(diffMiliSec > 85){ lastDateTimeClick = start; hero.totalClick = new Decimal(hero.totalClick).plus(1); if(hero.fastestClickInterval > diffMiliSec) hero.fastestClickInterval = diffMiliSec; hitDPC(); }; }; var hitDPC = function (){ let maxHpEnemy = new Decimal(enemy.maxHp); if(setting.cheat == 1) currentEnemyHP = new Decimal(0); else{let totalDPC = new Decimal(calcTotalDpc());currentEnemyHP = currentEnemyHP.sub(totalDPC);}let newHPBarWidth = new Decimal(currentEnemyHP).div(maxHpEnemy).mul(100); componentAction ("current-enemy-hp", "replaceText", numberFormat(currentEnemyHP)); componentAction ("progress-bar", "animate", newHPBarWidth); checkAction(true); }; var runBillionaire = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let skillDamage = unlockSkill.damage; let rewardCoin = calcTotalRewardCoin(); rewardCoin = rewardCoin.mul(skillDamage).div(100); hero.coin = new Decimal(hero.coin).plus(rewardCoin).ceil(); hero.totalGainCoin = new Decimal(hero.totalGainCoin).plus(rewardCoin).ceil(); updateHeroCoin(); }; var runGrimReaper = function (skillId) { let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); let maxHpEnemy = new Decimal(enemy.maxHp); let skillDamage = unlockSkill.damage; let randomPercentage = Math.random()*100; if(hero.floor % enemy.bossFloor == 0)skillDamage -= 10; if(randomPercentage <= skillDamage && hero.floor < hero.highestFloor){ currentEnemyHP = new Decimal(0); }else{ let totalDamage = new Decimal(calcTotalDpc()).plus(calcTotalDps()).mul(2).floor(); currentEnemyHP = currentEnemyHP.sub(totalDamage); } let newHPBarWidth = new Decimal(currentEnemyHP).div(maxHpEnemy).mul(100); componentAction ("current-enemy-hp", "replaceText", numberFormat(currentEnemyHP)); componentAction ("progress-bar", "animate", newHPBarWidth); checkAction(true); }; var useSkill = function (skillId){ let unlockSkill = hero.unlockSkill.find(item => item.id === skillId); if(!unlockSkill.isCooldown){ switch(skillId){ case 0: startAutoClickerInterval(skillId); break; case 1: startPowerShotInterval(skillId); break; case 2: startSpecialForceInterval(skillId); break; case 3: startLuckyCoinInterval(skillId); break; case 4: startBillionaireInterval(skillId); break; case 5: startGrimReaperInterval(skillId); break; }; saveGame(); } }; var insertAvailableGods = function(){ if(availableGods.length > 0) availableGods = []; let canInsert = false; for(let i=0;i < gods.length; i++){ let godsId = gods[i].id; let unlockGods = hero.unlockGods.find(item => item.id === godsId); let godsData = gods.find(item => item.id === godsId); if(!unlockGods) canInsert = true; else if(unlockGods.level < godsData.maxLevel) canInsert = true; if(canInsert){ let godsChance = 6 - godsData.tier; for(let j=0; j<godsChance; j++){ availableGods.push(godsId); } } } }; var insertAvailableArtifact = function(){ if(availableArtifact.length > 0) availableArtifact = []; for(let i=0;i < artifact.length; i++){ let artifactId = artifact[i].id; let unlockArtifact = hero.unlockArtifact.find(item => item.id === artifactId); let artifactData = artifact.find(item => item.id === artifactId); if(!unlockArtifact){ let artifactChance = 5 - artifactData.tier; for(let j=0; j<artifactChance; j++){ availableArtifact.push(artifactId); } } } }; var insertAvailableArtifactForDebug = function(artifactArray){ let artifactArrayId = artifactArray.split(","); if(availableArtifact.length > 0) availableArtifact = []; for(let i=0; i<artifactArrayId.length; i++){ let artifactId = parseInt(artifactArrayId[i],10); let artifactData = artifact.find(item => item.id === artifactId); let unlockArtifact = hero.unlockArtifact.find(item => item.id === artifactId); if(!unlockArtifact){ let artifactChance = 5 - artifactData.tier; for(let j=0; j<artifactChance; j++){ availableArtifact.push(artifactId); } } } }; var insertSellArtifact = function(artifactId){ let artifactData = artifact.find(item => item.id === artifactId); let loopInsert = 5 - artifactData.tier; for(let i=0;i<loopInsert;i++){ availableArtifact.push(artifactId); } }; var showRandomArtifact = function(isReroll=false){ let rerollFee = new Decimal(calcNextUnlockArtifactFee()).div(2).mul(100-hero.bonusArtifactRerollFeePercentage).div(100).ceil(); let tempAvailableArtifact = availableArtifact; let cleanArtifact = cleanDuplicateArray(availableArtifact); let randomArtifactId = []; let countRandomArtifact = 0; let heroOrbs = new Decimal(hero.orbs); if(isReroll && heroOrbs.greaterThanOrEqualTo(rerollFee)){ hero.randomArtifactId = []; hero.orbs = new Decimal(hero.orbs).sub(rerollFee); hero.totalSpentOrbs = new Decimal(hero.totalSpentOrbs).plus(rerollFee); } componentAction ("reroll-artifact-fee", "replaceText", numberFormat(rerollFee)+" Orbs"); componentAction ("unlock-artifact-confirm", "replaceText", numberFormat(calcNextUnlockArtifactFee())+" Orbs"); componentAction ("modal-orbs", "replaceText", numberFormat(hero.orbs)); $("#list-artifact-div").empty(); if(hero.randomArtifactId.length == 0){ randomArtifactId = []; while(randomArtifactId.length < setting.countArtifactForChoose && randomArtifactId.length < cleanArtifact.length){ let unlockArtifactId = tempAvailableArtifact[Math.floor(Math.random() * tempAvailableArtifact.length)]; let searchIndex = randomArtifactId.indexOf(unlockArtifactId); if (searchIndex === -1){ randomArtifactId.push(unlockArtifactId); countRandomArtifact++; } } hero.randomArtifactId = randomArtifactId; saveGame(); }else randomArtifactId = hero.randomArtifactId; for(let i=0;i<randomArtifactId.length;i++){ let artifactData = artifact.find(item => item.id === randomArtifactId[i]); let appendListArtifactDiv = '<div class="row border-top rounded-card m-1 p-1">'; appendListArtifactDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">' + artifactData.name +'</div>'; appendListArtifactDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">' + artifactData.description + ' ' + artifactData.baseDamage + artifactData.descDamage + ' / level</div>'; appendListArtifactDiv += '<div class="col-xl-12 col-lg-12 col-md-12 col-sm-12 col-12">'; appendListArtifactDiv += '<button id="random-artifact-button-' + artifactData.id + '" class="upgrade-level-button" value="' + artifactData.id + '">Unlock - ' + artifactData.name + '</button>'; appendListArtifactDiv += '</div>'; appendListArtifactDiv += '</div>'; $("#list-artifact-div").append(appendListArtifactDiv).off('click','#random-artifact-button-'+artifactData.id).on('click','#random-artifact-button-'+artifactData.id,function(){ confirmUnlockNewArtifact(artifactData.id); }); showArtifactArea(); } }; var confirmUnlockNewArtifact = function(artifactId){ let artifactData = artifact.find(item => item.id === artifactId); componentAction ("selected-unlock-artifact", "replaceText", artifactData.name); componentAction ("selected-unlock-fee", "replaceText", numberFormat(calcNextUnlockArtifactFee())); $("#modalRandomArtifactConfirm").modal('toggle'); $("#modalUnlockArtifactConfirm").modal("show"); componentAction ("unlock-artifact-ok-button", "inputText", artifactId); }; var unlockNewArtifact = function(artifactId=-1){ let unlockArtifactId = parseInt(artifactId,10); let unlockFee = new Decimal(calcNextUnlockArtifactFee()).mul(100-hero.bonusArtifactUnlockFeePercentage).div(100).ceil(); let heroOrbs = new Decimal(hero.orbs); let artifactDamage = new Decimal(hero.artifactDamagePercentage); if(heroOrbs.greaterThanOrEqualTo(unlockFee)){ if(availableArtifact.length > 0){ let artifactData = artifact.find(item => item.id === unlockArtifactId); let unlockArtifact = hero.unlockArtifact.find(item => item.id === unlockArtifactId); if(!unlockArtifact){ let newObjArtifact = { id: unlockArtifactId, level: 1, grade: 0, damage: artifactData.baseDamage }; hero.unlockArtifact.push(newObjArtifact); if(hero.totalArtifactUnlock < hero.countArtifact) hero.totalArtifactUnlock = hero.countArtifact; hero.countArtifact++; hero.totalSpentOrbs = new Decimal(hero.totalSpentOrbs).plus(unlockFee); hero.totalArtifactUnlock++; hero.artifactDamagePercentage = artifactDamage.plus(artifactData.tier*5); hero.orbs = heroOrbs.sub(unlockFee); hero.randomArtifactId = []; calculateAllArtifactDamage(); saveGame(); initDisplay(); showArtifactArea(); } removeArtifactId(unlockArtifactId); } } }; var removeArtifactId = function(unlockArtifactId){ let unlockIndex = availableArtifact.indexOf(unlockArtifactId); if (unlockIndex !== -1){ availableArtifact.splice(unlockIndex, 1); removeArtifactId(unlockArtifactId); } }; var summonGods = function(e){ let godsId = parseInt(e.value, 10); let unlockFragment = hero.unlockFragment.find(item => item.id === godsId); let godsData = gods.find(item => item.id === godsId); let unlockGods = hero.unlockGods.find(item => item.id === godsId); let godsLevel = 0; if(unlockGods) godsLevel = unlockGods.level; let targetFragment = Math.ceil((godsLevel+1)/5)*10; if(unlockFragment.count >= targetFragment){ if(unlockGods){ if(unlockGods.level < godsData.maxLevel){ unlockGods.level++; unlockGods.damage += godsData.levelMultiplier; } }else{ let newObjGods = { id: godsId, level: 1, damage: godsData.levelMultiplier, grade: 0, isActive: false }; hero.unlockGods.push(newObjGods); $("#gods-area-div").empty(); } unlockFragment.count -= targetFragment; calculateAllActiveGods(); showGodsArea(godsId); } }; var activateGods = function(e){ let godsId = parseInt(e.value, 10); let unlockGods = hero.unlockGods.find(item => item.id === godsId); let activeGodsCount = checkActiveGods(); if(unlockGods){ if(unlockGods.isActive){ unlockGods.isActive = false; godsId = null; } else{ if(activeGodsCount < hero.activeGodsSlot){ unlockGods.isActive = true; }else{ $("#modalNotification").modal('show'); $('#notification-ok-button').val(false); componentAction ("notification-text", "replaceText", "You only have " + hero.activeGodsSlot + " Gods slot. Please deactive other gods first"); } } } saveGame(); calculateAllActiveGods(); $("#gods-area-div").empty(); showGodsArea(godsId); }; var checkActiveGods = function(){ let count = 0; for(let i=0;i<hero.unlockGods.length;i++){ if(hero.unlockGods[i].isActive) count++; else hero.unlockGods[i].isActive = false; } return count; }; var createDropDownList = function(arrayValueList, componentName){ let dropDownListDiv = '<select name="'+componentName+'" id="'+componentName+'" class="drop-down-list mt-2">'; for(let i=0;i<arrayValueList.length;i++){ let valueList = arrayValueList[i].split("="); dropDownListDiv += '<option value="'+valueList[0]+'">'+valueList[1]+'</option>'; } dropDownListDiv += '</select>'; return dropDownListDiv; }; var switchTutorPage = function(tutorNumber){ componentAction ("tutor-content-div-"+tutorNumber, "removeClass", "d-none"); if(activeTutorNumber != tutorNumber) componentAction ("tutor-content-div-"+activeTutorNumber, "addClass", "d-none"); componentAction ("tutor-div-"+activeTutorNumber, "updateClass", "tab-button-active,tab-button-unactive"); componentAction ("tutor-div-"+tutorNumber, "updateClass", "tab-button-unactive,tab-button-active"); activeTutorNumber = tutorNumber; }; var numberFormat = function(x) { let value = new Decimal(x); if(value.greaterThan(9999)){ if(hero.settingFormatNumber == "letter") return letterFormat(value); else return value.toPrecision(3).toString(); } else return roundFormat(value,2); }; var letterFormat = function(e){ let value = e.mantissa; let exponent = e.exponent; let letterUnit = ""; let roundExponent = Math.floor(exponent/3); let restValue = value * Math.pow(10,exponent%3); if(roundExponent < 5){ let letterDictionary = ["", "K", "M", "B", "T"]; letterUnit = letterDictionary[roundExponent]; return roundFormat(restValue,2)+letterUnit }else if(roundExponent <= 680){ let letterDictionary = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]; let countExponent = roundExponent - 5; let secondLetter = countExponent % 26; let firstLetter = Math.floor(countExponent / 26); return roundFormat(restValue,2)+letterDictionary[firstLetter]+letterDictionary[secondLetter]; }else if(roundExponent <= 18256){ let letterDictionary = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]; let countExponent = roundExponent - 681; let firstLetter = Math.floor(countExponent / 676); let secondLetter = Math.floor((countExponent - (firstLetter*676)) / 26); let thirdLetter = countExponent % 26; return roundFormat(restValue,2)+letterDictionary[firstLetter]+letterDictionary[secondLetter]+letterDictionary[thirdLetter]; } }; var roundFormat = function(value, decimals) { return Number(Math.round(value+'e'+decimals)+'e-'+decimals).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }; var alphaNumericSpaceFormat = function(value){ var reg_exp = /^[A-Za-z0-9 ]+$/; var is_valid = reg_exp.test(String.fromCharCode(value)); return is_valid; }; var dateFormat = function(milliseconds){ let dateObject = new Date(milliseconds); let humanDateFormat = dateObject.toLocaleString(); return humanDateFormat; }; var hideAllMenu = function(){ if ($("#info-status-div").hasClass("show-menu")) componentAction ("info-status-div", "updateClass", "show-menu,hide-menu"); componentAction ("profile", "addClass", "d-none"); componentAction ("statistic", "addClass", "d-none"); componentAction ("achievement", "addClass", "d-none"); if ($("#gameplay-status-div").hasClass("show-menu")) componentAction ("gameplay-status-div", "updateClass", "show-menu,hide-menu"); componentAction ("dungeon", "addClass", "d-none"); componentAction ("daily-task", "addClass", "d-none"); componentAction ("artifact", "addClass", "d-none"); if ($("#town-status-div").hasClass("show-menu")) componentAction ("town-status-div", "updateClass", "show-menu,hide-menu"); componentAction ("barracks", "addClass", "d-none"); componentAction ("pet", "addClass", "d-none"); componentAction ("gods", "addClass", "d-none"); if ($("#other-status-div").hasClass("show-menu")) componentAction ("other-status-div", "updateClass", "show-menu,hide-menu"); componentAction ("tutorial", "addClass", "d-none"); componentAction ("setting", "addClass", "d-none"); componentAction ("save-game", "addClass", "d-none"); componentAction ("export-import", "addClass", "d-none"); componentAction ("clear-game", "addClass", "d-none"); componentAction ("contact-dev", "addClass", "d-none"); }; var hideAllContent = function(){ componentAction ("profile-div", "addClass", "d-none", true); componentAction ("statistic-div", "addClass", "d-none", true); componentAction ("achievement-div", "addClass", "d-none", true); componentAction ("dungeon-div", "addClass", "d-none", true); componentAction ("daily-task-div", "addClass", "d-none", true); componentAction ("artifact-div", "addClass", "d-none", true); componentAction ("barracks-div", "addClass", "d-none", true); componentAction ("pet-div", "addClass", "d-none", true); componentAction ("gods-div", "addClass", "d-none", true); componentAction ("tutorial-div", "addClass", "d-none", true); componentAction ("setting-div", "addClass", "d-none", true); componentAction ("export-import-div", "addClass", "d-none", true); componentAction ("profile", "updateClass", "active,cursor-button"); componentAction ("statistic", "updateClass", "active,cursor-button"); componentAction ("achievement", "updateClass", "active,cursor-button"); componentAction ("dungeon", "updateClass", "active,cursor-button"); componentAction ("daily-task", "updateClass", "active,cursor-button"); componentAction ("artifact", "updateClass", "active,cursor-button"); componentAction ("barracks", "updateClass", "active,cursor-button"); componentAction ("pet", "updateClass", "active,cursor-button"); componentAction ("gods", "updateClass", "active,cursor-button"); componentAction ("tutorial", "updateClass", "active,cursor-button"); componentAction ("setting", "updateClass", "active,cursor-button"); componentAction ("export-import", "updateClass", "active,cursor-button"); }; var showLastContent = function(){ switch(lastActiveMenu.toLowerCase()){ case 'profile': showProfileArea(); break; case 'statistic': showStatisticArea(); break; case 'achievement': showAchievementArea(); break; case 'dungeon': showDungeonArea(); break; case 'daily-task': showDailyTaskArea(); break; case 'artifact': showArtifactArea(); break; case 'barracks': showBarracksArea(); break; case 'pet': showPetArea(); break; case 'gods': showGodsArea(); break; case 'tutorial': showTutorialArea(); break; case 'setting': showSettingArea(); break; case 'export-import': showExportImportArea(); break; }; }; var showMenu = function(menuName){ switch(menuName){ case 'info': componentAction ("info-status-div", "updateClass", "hide-menu,show-menu"); componentAction ("profile", "removeClass", "d-none"); componentAction ("statistic", "removeClass", "d-none"); componentAction ("achievement", "removeClass", "d-none"); break; case 'gameplay': componentAction ("gameplay-status-div", "updateClass", "hide-menu,show-menu"); componentAction ("dungeon", "removeClass", "d-none"); componentAction ("daily-task", "removeClass", "d-none"); componentAction ("artifact", "removeClass", "d-none"); break; case 'town': componentAction ("town-status-div", "updateClass", "hide-menu,show-menu"); componentAction ("barracks", "removeClass", "d-none"); componentAction ("pet", "removeClass", "d-none"); componentAction ("gods", "removeClass", "d-none"); break; case 'other': componentAction ("other-status-div", "updateClass", "hide-menu,show-menu"); componentAction ("tutorial", "removeClass", "d-none"); componentAction ("setting", "removeClass", "d-none"); componentAction ("save-game", "removeClass", "d-none"); componentAction ("export-import", "removeClass", "d-none"); componentAction ("clear-game", "removeClass", "d-none"); componentAction ("contact-dev", "removeClass", "d-none"); break; } }; initGame(); $("#dpc-button").on('click', function(e) { clickDPC(); }); $("#auto-progress-switch").on('click', function() { setting.autoProgress = $("#auto-progress-switch").prop("checked"); }); $("#play-button").on('click', function() { let userID = $("#user-id").val(); let userName = $("#user-name").val(); if(userName != ""){ hero.userId = userID; hero.userName = userName; hero.firstPlayDateTime = Date.now(), hero.firstGameVersion = setting.gameVersion, initGame(); $("#modalLoginForm").modal('toggle'); } }); $("#new-player-button").on('click', function() { $("#modalNewPlayer").modal('toggle'); showTutorialArea(); }); $("#dev-log-ok-button").on('click', function() { $("#modalDevLog").modal('toggle'); if(hero.totalGainOrbs == 0) showTutorialArea(); }); $("#continue-button").on('click', function() { $("#modalOfflineForm").modal('toggle'); checkCooldownAdventureTimer(true); saveGame(); }); $("#continue-prestige-ok-button").on('click', function() { $("#modalPrestigeForm").modal('toggle'); hideAllContent(); showArtifactArea(); }); $("#continue-prestige-no-button").on('click', function() { $("#modalPrestigeForm").modal('toggle'); }); $("#upgrade-level-button").on('click', function() { upgradeLevelHero(); }); $("#hero-tab-button").on('click', function() { updateTab("hero"); }); $("#partner-tab-button").on('click', function() { updateTab("partner"); }); $("#skill-tab-button").on('click', function(e) { updateTab("skill"); }); $("#shop-tab-button").on('click', function() { updateTab("shop"); }); $("#pet-tab-button").on('click', function() { showPetArea(); }); $("#area-tab-button").on('click', function() { showAdventureArea(); }); $("#gods-tab-button").on('click', function() { showGodsArea(); }); $("#temple-tab-button").on('click', function() { showTempleArea(); }); $("#barracks-tab-button").on('click', function() { showBarracksArea(true); }); $("#training-tab-button").on('click', function() { showTrainingArea(); }); $("[id^=floor-number-div-]").on("click", function() { let floorNumber = parseInt($(this).text().replace(",",""),10); if(floorNumber <= hero.maxFloor && floorNumber <= setting.limitFloor){ hero.floor = floorNumber; componentAction ("progress-bar", "animate", 100); currentEnemyHP = initDungeon(); } }); $("#upgrade-weapon-button").on('click', function() { upgradeLevelWeapon(); }); $("#prestige-ok-button").on('click', function() { runPrestige(); }); $("#prestige-no-button").on('click', function() { $("#modalPrestigeConfirm").modal('toggle'); }); $("#clear-ok-button").on('click', function() { $("#modalClearConfirm").modal('toggle'); $("#modalAnotherClearConfirm").modal('show'); }); $("#clear-no-button").on('click', function() { $("#modalClearConfirm").modal('toggle'); }); $("#another-clear-ok-button").on('click', function() { localStorage.removeItem("hero"); location.reload(); }); $("#another-clear-no-button").on('click', function() { $("#modalAnotherClearConfirm").modal('toggle'); }); $("#sell-artifact-ok-button").on('click', function() { let artifactId = parseInt($('#sell-artifact-ok-button').val(),10); sellArtifact(artifactId); $("#modalSellArtifactConfirm").modal('toggle'); }); $("#sell-artifact-no-button").on('click', function() { $("#modalSellArtifactConfirm").modal('toggle'); }); $("#notif-prestige-ok-button").on('click', function() { $("#modalNotifPrestige").modal('toggle'); startPrestige(); }); $("#notif-prestige-no-button").on('click', function() { $("#modalNotifPrestige").modal('toggle'); }); $("#notif-pet-ok-button").on('click', function() { $("#modalNotifPet").modal('toggle'); hideAllContent(); showPetArea(); }); $("#notif-pet-no-button").on('click', function() { $("#modalNotifPet").modal('toggle'); }); $("#notif-features-ok-button").on('click', function() { let featureName = $("#notif-features-ok-button").val(); $("#modalNotifNewFeatures").modal('toggle'); hideAllContent(); switch(featureName){ case "barracks": showBarracksArea(true); break; case "pet": showPetArea(); break; case "gods": showTempleArea(); break; }; }); $("#notif-features-no-button").on('click', function() { $("#modalNotifNewFeatures").modal('toggle'); }); $("#user-name").keypress(function (e) { var value = e.keyCode || e.which; return alphaNumericSpaceFormat(value); }); $("#profile").on('click', function() { hideAllContent(); showProfileArea(); }); $("#profile-user-name").keypress(function (e) { var value = e.keyCode || e.which; return alphaNumericSpaceFormat(value); }); $("#update-profile-button").on('click', function() { let userName = $("#profile-user-name").val(); if(userName != ""){ hero.userName = userName; componentAction ("view-username", "replaceText", hero.userName); saveGame(); $("#modalSaveForm").modal('show'); componentAction("save-text", "replaceText", "Update Profile Success"); let intervalModalSaveForm = setTimeout (function() { $("#modalSaveForm").modal('toggle'); },2000); } }); $("#statistic").on('click', function() { hideAllContent(); showStatisticArea(); }); $("#achievement").on('click', function() { hideAllContent(); showAchievementArea(); }); $("#dungeon").on('click', function() { showDungeonArea(); }); $("[id^=button-buy-multiplier-]").on("click", function() { setting.levelUpgradeMultiplier = parseInt(this.value,10); initDisplay(); }); $("#artifact").on('click', function() { hideAllContent(); showArtifactArea(); }); $("#pet").on('click', function() { hideAllContent(); showPetArea(); }); $("#barracks").on('click', function() { hideAllContent(); showBarracksArea(true); }); $("#daily-task").on('click', function() { hideAllContent(); showDailyTaskArea(); }); $("#gods").on('click', function() { hideAllContent(); showTempleArea(); }); $("#tutorial").on('click', function() { showTutorialArea(); }); $("#setting").on('click', function() { showSettingArea(); }); $("[id^=partner-sequence-]").on('click', function() { hero.settingOrderPartner = $(this).val(); saveGame(); $("#partner-area-div").empty(); $("#barracks-area-div").empty(); checkCssSetting(); }); $("[id^=show-icon-]").on('click', function() { if($(this).val() == "true") hero.settingShowIcon = true; else hero.settingShowIcon = false; saveGame(); checkCssSetting(); }); $("[id^=setting-format-]").on('click', function() { hero.settingFormatNumber = $(this).val(); saveGame(); componentAction ("max-enemy-hp", "replaceText", numberFormat(enemy.maxHp)); }); $("[id^=setting-ability-training-]").on('click', function() { if($(this).val() == "true") hero.settingAutoAbilityTraining = true; else hero.settingAutoAbilityTraining = false; saveGame(); }); $("[id^=setting-background-]").on('click', function() { hero.settingBackground = $(this).val(); saveGame(); checkCssSetting(); }); $("[id^=tutor-div-]").on("click", function() { let tutorNumber = parseInt($(this).text(),10); switchTutorPage(tutorNumber); }); $("[id^=tutor-button-prev-]").on("click", function() { let tutorNumber = activeTutorNumber - 1; if(tutorNumber < 1) tutorNumber = 1; switchTutorPage(tutorNumber); }); $("[id^=tutor-button-next-]").on("click", function() { let tutorNumber = activeTutorNumber + 1; if(tutorNumber > setting.maxTutorPage) tutorNumber = setting.maxTutorPage; switchTutorPage(tutorNumber); }); $("[id^=tutor-div-]").on("click", function() { let tutorNumber = parseInt($(this).text(),10); switchTutorPage(tutorNumber); }); $("#tutor-button-finish").on("click",function (){ showDungeonArea(); }); $("#unlock-artifact-button").on('click', function() { let unlockFee = new Decimal(calcNextUnlockArtifactFee()).mul(100-hero.bonusArtifactUnlockFeePercentage).div(100).ceil(); let heroOrbs = new Decimal(hero.orbs); if(heroOrbs.greaterThanOrEqualTo(unlockFee)){ $("#modalRandomArtifactConfirm").modal('show'); showRandomArtifact(); }else $("#modalUnlockArtifactFailed").modal('show'); }); $("#random-artifact-ok-button").on('click', function() { let rerollFee = new Decimal(calcNextUnlockArtifactFee()).div(2).mul(100-hero.bonusArtifactRerollFeePercentage).div(100).ceil(); let heroOrbs = new Decimal(hero.orbs); $("#modalRandomArtifactConfirm").modal('toggle'); if(heroOrbs.greaterThanOrEqualTo(rerollFee)){ $("#modalRerollArtifactConfirm").modal('show'); componentAction ("confirm-reroll-artifact-fee", "replaceText", rerollFee); }else{ $("#modalNotification").modal('show'); $('#notification-ok-button').val(false); componentAction ("notification-text", "replaceText", "You don't have enough orbs to reroll artifact."); } }); $("#random-artifact-no-button").on('click', function() { $("#modalRandomArtifactConfirm").modal('toggle'); }); $("#reroll-artifact-ok-button").on('click', function() { $("#modalRerollArtifactConfirm").modal('toggle'); $("#modalRandomArtifactConfirm").modal('show'); showRandomArtifact(true); showArtifactArea(); }); $("#reroll-artifact-no-button").on('click', function() { $("#modalRerollArtifactConfirm").modal('toggle'); $("#modalRandomArtifactConfirm").modal('show'); }); $("#unlock-artifact-ok-button").on('click', function() { $("#modalUnlockArtifactConfirm").modal("toggle"); unlockNewArtifact($('#unlock-artifact-ok-button').val()); }); $("#unlock-artifact-no-button").on('click', function() { $("#modalUnlockArtifactConfirm").modal("toggle"); $("#modalRandomArtifactConfirm").modal('show'); }); $("#continue-failed-unlock-artifact-button").on('click', function() { $("#modalUnlockArtifactFailed").modal('toggle'); }); $("#confirm-adventure-ok-button").on('click', function() { $("#modalStartAdventureConfirm").modal('toggle'); startAdventurePet($('#confirm-adventure-ok-button').val()); }); $("#confirm-adventure-no-button").on('click', function() { $("#modalStartAdventureConfirm").modal('toggle'); }); $("#cancel-adventure-ok-button").on('click', function() { $("#modalCancelAdventureConfirm").modal('toggle'); cancelAdventurePet($('#cancel-adventure-ok-button').val()); }); $("#cancel-adventure-no-button").on('click', function() { $("#modalCancelAdventureConfirm").modal('toggle'); }); $("#collect-reward-adventure-ok-button").on('click', function() { $("#modalCollectRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet($('#collect-reward-adventure-ok-button').val()); }); $("#collect-reward-adventure-no-button").on('click', function() { $("#modalCollectRewardAdventureConfirm").modal('toggle'); }); $("#confirm-reward-adventure-ok-button").on('click', function() { $("#modalRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet($('#confirm-reward-adventure-ok-button').val()); }); $("#confirm-reward-adventure-no-button").on('click', function() { $("#modalRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet($('#confirm-reward-adventure-ok-button').val(),true); }); $("#confirm-list-reward-adventure-ok-button").on('click', function() { $("#modalListRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet('complete'); }); $("#confirm-list-reward-adventure-no-button").on('click', function() { $("#modalListRewardAdventureConfirm").modal('toggle'); confirmCollectRewardAdventurePet('complete',true); }); $("#shop-ok-button").on('click', function() { $("#modalShopForm").modal('toggle'); runShop($("#shop-ok-button").val()); }); $("#shop-no-button").on('click', function() { $("#modalShopForm").modal('toggle'); }); $("#trade-soul-ok-button").on('click', function() { $("#modalConfirmTradeSoul").modal('toggle'); tradeGodsFragment($("#trade-soul-ok-button").val()); }); $("#trade-soul-no-button").on('click', function() { $("#modalConfirmTradeSoul").modal('toggle'); }); $("#save-ability-ok-button").on('click', function() { $("#modalConfirmSaveAbility").modal('toggle'); saveAbilityPartner($("#save-ability-ok-button").val()); }); $("#save-ability-no-button").on('click', function() { $("#modalConfirmSaveAbility").modal('toggle'); }); $("#activate-ability-ok-button").on('click', function() { $("#modalConfirmActivateAbility").modal('toggle'); activateAbilityPartner($("#activate-ability-ok-button").val()); }); $("#activate-ability-no-button").on('click', function() { $("#modalConfirmActivateAbility").modal('toggle'); }); $("#training-ability-ok-button").on('click', function() { $("#modalConfirmStartTrainingAbility").modal('toggle'); startTrainingAbility($("#training-ability-ok-button").val()); }); $("#training-ability-no-button").on('click', function() { $("#modalConfirmStartTrainingAbility").modal('toggle'); }); $("#stop-training-ability-ok-button").on('click', function() { $("#modalConfirmStopTrainingAbility").modal('toggle'); stopTrainingAbility($("#stop-training-ability-ok-button").val()); }); $("#stop-training-ability-no-button").on('click', function() { $("#modalConfirmStopTrainingAbility").modal('toggle'); }); $("#save-game").on('click', function() { saveGame(); componentAction ("save-text", "replaceText", "Save Data Success"); $("#modalSaveForm").modal('show'); let intervalModalSaveForm = setTimeout (function() { $("#modalSaveForm").modal('toggle'); },2000); }); $("#export-import").on('click', function() { hideAllContent(); showExportImportArea(); }); $("#export-data-button").on('click', function() { exportData(); }); $("#download-data-button").on('click', function() { exportData(true); }); $("#import-data-button").on('click', function() { let importData = $("#import-data").val().trim(); if(importData != '') $("#modalImportDataForm").modal('show'); }); $("#import-data-ok-button").on('click', function() { $("#modalImportDataForm").modal('toggle'); importData(); }); $("#import-data-no-button").on('click', function() { $("#modalImportDataForm").modal('toggle'); }); $("#notification-ok-button").on('click', function() { $("#modalNotification").modal('toggle'); if($("#notification-ok-button").val() == "true") location.reload(); }); $("#clear-game").on('click', function() { $("#modalClearConfirm").modal('show'); }); $("#contact-dev").on('click', function() { let bodyEmail = 'KuroIdleDungeon v'+setting.gameVersion+'\r\n'; bodyEmail += 'UserID : '+hero.userId+'\r\n'; bodyEmail += 'UserName : '+hero.userName+'\r\n'; window.open('mailto:kuropone.solodev@gmail.com?subject=Kuro Idle Dungeon Contact Dev&body='+encodeURIComponent(bodyEmail)); }); $("#info-div").on('click', function() { if ($("#info-status-div").hasClass("hide-menu")){ hideAllMenu(); showMenu('info'); } }); $("#gameplay-div").on('click', function() { if ($("#gameplay-status-div").hasClass("hide-menu")){ hideAllMenu(); showMenu('gameplay'); } }); $("#town-div").on('click', function() { if ($("#town-status-div").hasClass("hide-menu")){ hideAllMenu(); showMenu('town'); } }); $("#other-div").on('click', function() { if ($("#other-status-div").hasClass("hide-menu")){ hideAllMenu(); showMenu('other'); } }); })(jQuery);